<!DOCTYPE html>

<html lang="it">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<title>Platform Fighter - Complete</title>
<!-- Link ai font da Google Fonts -->
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&amp;family=VT323&amp;display=swap" rel="stylesheet"/>
<style>
    *{margin:0;padding:0;box-sizing:border-box}
    html,body{height:100%}
    body{
      font-family:'VT323', monospace; /* Font di gioco */
      background:#000;
      color:#fff;
      display:flex;
      justify-content:center;
      align-items:center;
      height:100vh;
      overflow:hidden;
      position:relative;
    }

    #bgDefault,#bgDark{
      position:absolute;left:0;top:0;width:100%;height:100%;
      background-size:cover;background-position:center;
      transition:opacity 900ms ease;z-index:0;pointer-events:none
    }
    #bgDefault{opacity:1}
    #bgDark{opacity:0}

    #fadeOverlay{position:absolute;left:0;top:0;width:100%;height:100%;background:#000;opacity:0;transition:opacity 650ms ease;z-index:3;pointer-events:none}

    #gameContainer{
      position:relative;width:1200px;height:700px;
      max-width:calc(100vw - 40px);max-height:calc(100vh - 40px);
      z-index:2;display:flex;justify-content:center;align-items:center
    }

    #gameCanvas{
      background:transparent;border:4px solid #fff;
      box-shadow:0 0 30px rgba(255,255,255,0.5);
      image-rendering:pixelated;display:block
    }

    .ui-overlay{position:absolute;top:18px;left:18px;z-index:10;text-shadow:2px 2px 4px #000}

    .hp-bar{width:200px;height:30px;background:#333;border:3px solid #fff;margin-top:8px;position:relative}
    .hp-fill{height:100%;background:linear-gradient(90deg,#e74c3c,#c0392b);transition:width 0.25s}

    .score{position:absolute;top:18px;right:18px;color:#f39c12;font-size:22px;text-shadow:2px 2px 4px #000;z-index:10}
    .timer{position:absolute;top:18px;left:50%;transform:translateX(-50%);font-size:32px;color:#f39c12;text-shadow:2px 2px 4px #000;z-index:10}
    .level-indicator{position:absolute;top:60px;left:50%;transform:translateX(-50%);font-size:18px;z-index:10}
    .super-cooldown{position:absolute;top:100px;left:18px;font-size:14px;color:#f39c12;z-index:10}

    .evo-banner{
      position:absolute;left:50%;top:45%;
      transform:translate(-50%,-50%);
      z-index:50;
      padding:18px 24px;
      border:4px solid #fff;
      background:rgba(0,0,0,0.85);
      font-family:'Press Start 2P', cursive;
      text-align:center;
      pointer-events:none;
      box-shadow:0 0 28px rgba(255,255,255,0.35);
      opacity:0;
    }
    .evo-banner.show{
      display:block !important;
      animation:evoPop 520ms ease forwards;
    }
    @keyframes evoPop{
      0%{opacity:0;transform:translate(-50%,-50%) scale(0.85)}
      25%{opacity:1;transform:translate(-50%,-50%) scale(1.08)}
      100%{opacity:0;transform:translate(-50%,-50%) scale(1.00)}
    }


    .menu,.end-screen{
      position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);
      background:rgba(0,0,0,0.9);padding:30px;border:4px solid #fff;
      text-align:center;z-index:20;width:calc(100% - 80px);max-width:760px;
      font-family:'Press Start 2P', cursive; /* Font menu */
    }

    .menu h1,.end-screen h1{
      font-size:38;color:#e74c3c;text-shadow:3px 3px 6px #000;margin-bottom:12px
    }

    .character-select{
      display:block;
      margin:18px 0;
      max-height:420px;
      overflow-y:auto;
      overflow-x:hidden;
      padding:6px;
      box-sizing:border-box;
    }
    .character-select::-webkit-scrollbar{width:10px}
    .character-select::-webkit-scrollbar-thumb{background:#555;border:2px solid #111;border-radius:10px}
    .character-select::-webkit-scrollbar-track{background:#111}

    .character-select::-webkit-scrollbar{width:10px}
    .character-select::-webkit-scrollbar-thumb{background:#555;border:2px solid #111;border-radius:10px}
    .character-select::-webkit-scrollbar-track{background:#111}

    /* Ridotte leggermente le card personaggio per evitare sovrapposizioni */
    .character-card{
      background:#222;border:3px solid #555;padding:10px 12px;
      width:100%;
      cursor:pointer;transition:all .12s;position:relative;
      display:flex;flex-direction:row;align-items:center;gap:12px;
      min-height:64px;box-sizing:border-box;
    }
    .character-card:hover{transform:translateY(-3px);border-color:#e74c3c;background:#222}
    .character-card.selected{border-left:6px solid #f39c12;background:#2b2b2b}
    .character-card.disabled{ filter:grayscale(1); opacity:0.55; cursor:not-allowed; transform:none; }
    .character-card img{
      width:56px;
      height:56px;
      display:block;
      image-rendering:pixelated;
      margin:0;
      flex:0 0 auto;
    }
    .character-card h3{
      flex:0 0 160px;
      text-align:left;
      margin:0;
      font-size:16px;
      color:#fff;
    }
    .character-card .menu-stats{font-size:13px;color:#ddd;margin-left:8px}
    .record-badge{position:static;margin-left:12px;font-size:12px}
    .lock-badge{position:absolute;right:10px;top:10px;font-size:12px;color:#f39c12;background:#000;padding:3px 6px;border:1px solid #f39c12}
    /* nascondi i vecchi pulsanti interni delle card se presenti */
    .character-card .select-btn{display:none!important}

    .character-card:hover{transform:scale(1.03);border-color:#e74c3c}
    .character-card.selected{border-color:#f39c12;background:#333}
    .character-card.disabled{ filter:grayscale(1); opacity:0.55; cursor:not-allowed; }
.character-card.disabled:hover{ transform:none; border-color:#555; }

/* Coming soon (grey, not clickable) */
.character-card.coming-soon{
  background:#3a3a3a;
  border-color:#777;
}
.character-card.coming-soon .menu-stats{color:#cfcfcf}

    /* Immagine personaggio pi√π piccola per evitare sovrapposizioni */
    .character-card img{
      width:110px; /* dimensione immagine ridotta */
      height:auto;
      display:block;
      image-rendering:pixelated;
      margin-bottom:8px;
    }

    /* Riquadro attorno al "tasto" per selezionare il personaggio */
    .character-card .select-btn{
      display:inline-block;
      border:3px solid #fff; /* riquadro visibile */
      padding:8px 10px;
      margin-top:10px;
      background:transparent;
      color:#fff;
      font-family:'Press Start 2P', cursive;
      font-size:12px;
      text-decoration:none;
      cursor:pointer;
    }
    .character-card .select-btn:active{transform:translateY(1px)}

    /* Riquadro leggermente pi√π grande per il nome (evita sovrapposizione con record) */
    .character-card .name-box{
      min-height:34px; /* ingrandito per non sovrapporre il record */
      padding:6px 8px;
      width:100%;
      text-align:center;
      font-size:13px;
      color:#fff;
      background:rgba(0,0,0,0.15);
      border:2px solid rgba(255,255,255,0.06);
      margin-bottom:6px;
      box-sizing:border-box;
    }

    /* Posizionamento del record: sotto il nome del personaggio, non assoluto */
    .record-badge{
      position:static; /* rimosso absolute per evitare sovrapposizioni */
      margin-top:6px;
      font-size:11px;
      color:#ccc;
      background:transparent;
      z-index:2;
    }

    .lock-badge{
      position:absolute;top:8px;right:8px;
      font-size:12px;color:#f39c12;background:#000;padding:3px 6px;border:1px solid #f39c12
    }

    .btn{ background:#e74c3c;color:#fff;border:none;padding:10px 22px; font-size:16px;cursor:pointer;margin:8px; font-family:'Press Start 2P', cursive; /* Bottoni in stile menu */ }

    /* Extra character button + layout */
    .start-row{display:flex;gap:10px;align-items:center;justify-content:center;margin-top:10px;}
    .mini-btn{padding:8px 14px;font-size:22px;line-height:1;min-width:46px;max-width:60px;}
    .extra-characters{margin-top:14px;}


    .damage-number{position:absolute;font-size:20px;font-weight:bold;color:#e74c3c;text-shadow:2px 2px 4px #000;pointer-events:none;animation:floatUp 1s ease-out forwards;z-index:200}
    @keyframes floatUp{to{transform:translateY(-50px);opacity:0}}

    .pickup-label{position:absolute;font-size:14px;color:#fff;text-shadow:2px 2px 4px #000}
    .menu-stats{font-size:13px;color:#ddd;margin-top:8px}

    @media (max-width:900px){
      #gameContainer{width:900px;height:525px}
      .menu,.end-screen{width:calc(100% - 40px);max-width:680px}
    }
/* Pulsante immagine stile */
.img-btn{
  background:transparent;border:0;padding:6px;cursor:pointer;display:inline-flex;
  align-items:center;justify-content:center;transition:transform 160ms ease, box-shadow 160ms ease;
}
.img-btn img{
  width:72px;height:72px;display:block;image-rendering:pixelated;
  border:3px solid #fff;border-radius:8px;transition:transform 160ms ease, box-shadow 160ms ease;
}
.img-btn:hover img{transform:scale(1.08);box-shadow:0 6px 18px rgba(0,0,0,0.6);}

/* Modale guida */
.guide-modal{
  position:fixed;left:0;top:0;width:100%;height:100%;
  background:rgba(0,0,0,0.75);display:flex;justify-content:center;align-items:center;
  z-index:60;padding:20px;
}
.guide-modal-content{
  background:rgba(10,10,10,0.98);border:4px solid #fff;max-width:980px;width:100%;max-height:90vh;
  overflow:auto;padding:22px;font-family:'VT323', monospace;color:#fff;position:relative;
  box-shadow:0 0 30px rgba(0,0,0,0.8);
}
.guide-close{
  position:absolute;right:12px;top:12px;background:transparent;border:2px solid #fff;color:#fff;
  width:36px;height:36px;border-radius:4px;cursor:pointer;font-size:18px;
}
.guide-body h3{color:#f39c12;margin-top:12px}
.guide-body p, .guide-body ul{font-size:14px;line-height:1.45;color:#ddd}

/* === Bestiario (nemici + boss) === */
.enemy-guide-content{max-width:1020px;}
.enemy-guide-body{margin-top:10px}
.enemy-guide-wrap{
  display:flex;gap:16px;align-items:stretch;
  min-height:420px;
}
.enemy-guide-list{
  width:260px;flex:0 0 260px;
  border:2px solid rgba(255,255,255,0.18);
  background:rgba(255,255,255,0.03);
  padding:10px;overflow:auto;max-height:62vh;
}
.enemy-guide-list button{
  width:100%;
  background:rgba(0,0,0,0.35);
  border:2px solid rgba(255,255,255,0.18);
  color:#fff;
  padding:10px 10px;
  margin:0 0 10px 0;
  cursor:pointer;
  font-family:'Press Start 2P', cursive;
  font-size:11px;
  text-align:left;
  display:flex;gap:10px;align-items:center;
}
.enemy-guide-list button:hover{border-color:#f39c12;transform:translateY(-1px)}
.enemy-guide-list button.active{border-color:#e74c3c;background:rgba(231,76,60,0.12)}
.enemy-guide-list .enemy-mini{
  width:44px;height:44px;image-rendering:pixelated;
  border:2px solid rgba(255,255,255,0.7);
  border-radius:6px;flex:0 0 auto;background:#000;
}
.enemy-guide-detail{
  flex:1;
  border:2px solid rgba(255,255,255,0.18);
  background:rgba(255,255,255,0.03);
  padding:14px;
  display:flex;
  align-items:center;
  justify-content:center;
}
.enemy-guide-detail-inner{
  width:100%;
  display:flex;
  gap:16px;
  align-items:flex-start;
}
.enemy-guide-detail-inner img{
  width:240px;height:240px;object-fit:contain;
  image-rendering:pixelated;
  border:3px solid #fff;border-radius:10px;
  background:rgba(0,0,0,0.35);
  flex:0 0 auto;
}
.enemy-guide-detail-inner h3{
  margin:0 0 10px 0;
  color:#f39c12;
  font-family:'Press Start 2P', cursive;
  font-size:14px;
  line-height:1.35;
}
.enemy-guide-detail-inner p{
  margin:0;
  font-size:15px;
  color:#ddd;
  line-height:1.55;
  font-family:'VT323', monospace;
}
.enemy-guide-hint{
  margin:14px 0 0 0;
  font-size:13px;
  color:#cfcfcf;
  font-family:'VT323', monospace;
}
@media (max-width:900px){
  .enemy-guide-wrap{flex-direction:column}
  .enemy-guide-list{width:100%;flex:0 0 auto;max-height:30vh}
  .enemy-guide-detail-inner{flex-direction:column;align-items:center}
  .enemy-guide-detail-inner img{width:220px;height:220px}
}


.guide-body ul{margin-left:18px}
@media (max-width:900px){
  .guide-modal-content{max-width:calc(100% - 20px);padding:14px}
  .guide-body p{font-size:13px}
}
  
    /* menu stat numbers: only numbers, no labels */
    .menu-stats{display:flex;gap:12px;align-items:center;justify-content:center;font-size:14px}
    .menu-stats .stat{min-width:40px;text-align:center;font-weight:bold;color:#f1f1f1}
    .menu-stats .spacer{width:8px}
    

.compact-selector{margin:16px 0}
.char-grid{
  display:grid;
  grid-template-columns:repeat(4,1fr);
  gap:10px;
}
.char-grid button{
  background:#111;
  border:2px solid #555;
  color:#fff;
  font-family:'Press Start 2P', cursive;
  font-size:10px;
  padding:10px 6px;
  cursor:pointer;
}
.char-grid button:hover{border-color:#f39c12}
.char-grid button.empty{
  background:#222;
  border-style:dashed;
  cursor:not-allowed;
  color:#777;
}


/* ==== COMPACT CHARACTER SELECT PATCH ==== */
.characterCard, .charCard, .character-card {
  display:none !important; /* hide big cards */
}

.charBtn, .characterBtn, .selectCharBtn, .char-button {
  padding:10px 14px;
  margin:6px;
  font-size:18px;
  border-radius:12px;
  border:3px solid #555;
  background:#1e1e1e;
  color:#fff;
  cursor:pointer;
}

.charBtn.selected, .characterBtn.selected, .selectCharBtn.selected, .char-button.selected{
  border-color:#ff9800 !important;
  box-shadow:0 0 12px #ff9800;
}

/* collapse container */
#charactersContainerCompact{
  max-height:70vh;
  overflow:auto;
  padding:6px;
}

#moreCharsToggle{
  width:100%;
  margin-top:8px;
  padding:10px;
  border-radius:12px;
  border:3px solid #ff9800;
  background:#2c2c2c;
  color:#ff9800;
  font-size:18px;
  cursor:pointer;
}


/* ==== STRONG SELECT GLOW ==== */
.charBtn.selected, .characterBtn.selected, .selectCharBtn.selected, .char-button.selected{
  border-color:#ff9800 !important;
  box-shadow:
    0 0 8px #ff9800,
    0 0 16px #ff9800,
    0 0 28px rgba(255,152,0,0.9),
    inset 0 0 12px rgba(255,152,0,0.6);
  background: linear-gradient(180deg,#2b1a00,#3a2200);
  transform: scale(1.05);
  transition: all 0.12s ease;
}

.charBtn:hover, .characterBtn:hover, .selectCharBtn:hover, .char-button:hover{
  box-shadow: 0 0 10px rgba(255,152,0,0.6);
}


.ira-glow{
  color:#7a0019;
  border:2px solid #7a0019;
  padding:4px 8px;
  border-radius:6px;
  box-shadow:0 0 10px rgba(122,0,25,0.8), 0 0 20px rgba(122,0,25,0.6);
  font-weight:bold;
}


/* === Account Level UI === */
#accountLevelBtn{
  position:fixed;
  left:14px;
  bottom:14px;
  z-index:9999;
  padding:12px 14px 10px 14px;
  border-radius:16px;
  border:2px solid rgba(255,255,255,0.35);
  background:linear-gradient(180deg, rgba(80,20,140,0.95), rgba(20,10,40,0.92));
  color:#fff;
  cursor:pointer;
  font-weight:900;
  letter-spacing:1px;
  text-transform:uppercase;
  font-family: "Orbitron","Rajdhani","Trebuchet MS","Segoe UI",sans-serif;
  box-shadow:
    0 0 0 2px rgba(0,0,0,0.35) inset,
    0 8px 24px rgba(0,0,0,0.55),
    0 0 20px rgba(155,89,182,0.45);
  text-shadow:
    0 2px 0 rgba(0,0,0,0.55),
    0 0 10px rgba(241,196,15,0.35);
  user-select:none;
}
#accountLevelBtn:hover{
  transform:translateY(-1px);
  box-shadow:
    0 0 0 2px rgba(0,0,0,0.35) inset,
    0 10px 28px rgba(0,0,0,0.58),
    0 0 26px rgba(241,196,15,0.30),
    0 0 22px rgba(155,89,182,0.55);
}
#accountLevelBtn:active{
  transform:translateY(1px) scale(0.99);
}
#accountLevelBtn::after{
  content:"";
  position:absolute;
  inset:2px;
  border-radius:14px;
  pointer-events:none;
  background:linear-gradient(180deg, rgba(255,255,255,0.18), rgba(255,255,255,0));
  mix-blend-mode:screen;
  opacity:0.75;
}
#accountLevelBtn .sub{
  display:block;
  font-weight:700;
  font-size:12px;
  opacity:0.9;
  margin-top:3px;
  letter-spacing:0.5px;
}
@keyframes accPulse{
  0%{ filter:brightness(1); }
  50%{ filter:brightness(1.08); }
  100%{ filter:brightness(1); }
}
#accountLevelBtn{
  animation:accPulse 2.2s ease-in-out infinite;
}
#accountModal{
  position:fixed; inset:0;
  display:none;
  z-index:10000;
  background:rgba(0,0,0,0.72);
  align-items:center;
  justify-content:center;
}
#accountModal .panel{
  width:min(720px, 92vw);
  max-height:min(80vh, 760px);
  overflow:auto;
  background:rgba(20,20,20,0.92);
  border:1px solid rgba(255,255,255,0.25);
  border-radius:18px;
  padding:18px;
  box-shadow:0 0 30px rgba(0,0,0,0.45);
}
#accountModal h3{margin:0 0 10px 0}
#accountModal .row{display:flex;gap:10px;align-items:center;justify-content:space-between;margin:10px 0}
#accountModal .barWrap{
  width:100%;
  height:18px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,0.25);
  background:rgba(255,255,255,0.08);
  overflow:hidden;
}
#accountModal .barFill{
  height:100%;
  width:0%;
  background:linear-gradient(90deg, rgba(46,204,113,0.95), rgba(241,196,15,0.95));
}
#accountModal .mission{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
  padding:10px 12px;
  border-radius:14px;
  border:1px solid rgba(255,255,255,0.18);
  background:rgba(255,255,255,0.06);
  margin:8px 0;
}
#accountModal .mission .meta{opacity:0.9;font-size:14px}
#accountModal .mission .prog{opacity:0.75;font-size:12px;margin-top:4px}
#accountModal .claimBtn{
  padding:8px 12px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,0.25);
  background:rgba(255,255,255,0.08);
  color:#fff;
  cursor:not-allowed;
  opacity:0.55;
  font-weight:700;
}
#accountModal .claimBtn.ready{
  background:rgba(46,204,113,0.28);
  border-color:rgba(46,204,113,0.75);
  cursor:pointer;
  opacity:1;
}
#accountModal .closeBtn{
  padding:8px 12px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,0.25);
  background:rgba(255,255,255,0.08);
  color:#fff;
  cursor:pointer;
}

</style>

<!-- Injected CSS: compact grid selected state -->
<style id="injected-compact-select-style">
.char-grid button.selected{
  border-color:#ff9800 !important;
  box-shadow:
    0 0 8px #ff9800,
    0 0 16px #ff9800,
    0 0 28px rgba(255,152,0,0.9),
    inset 0 0 12px rgba(255,152,0,0.35);
  background: linear-gradient(180deg,#2b1a00,#3a2200);
  color:#fff;
  transform: scale(1.03);
  transition: all 0.12s ease;
}
.char-grid button.selected:focus{
  outline: 3px solid rgba(255,152,0,0.18);
}
</style>


<!-- === LOCKED COMPACT BUTTON STYLE PATCH (added) === -->
<style id="locked-compact-style">
/* locked/disabled compact buttons */
.char-grid button.locked{
  background:#2a2a2a !important;
  border-color:#444 !important;
  color:#888 !important;
  opacity:0.45;
  cursor:not-allowed;
  box-shadow:none !important;
  transform:none !important;
}

/* no hover glow */
.char-grid button.locked:hover{
  border-color:#444 !important;
  box-shadow:none !important;
}

/* prevent orange glow even if .selected accidentally added */
.char-grid button.locked.selected{
  border-color:#444 !important;
  background:#2a2a2a !important;
  box-shadow:none !important;
  transform:none !important;
}
</style>


<style>
/* AUTO-SELECTED HIGHLIGHT */
.char-grid button.selected, .character-card.selected {
  outline: 3px solid transparent;
  box-shadow: 0 0 0 3px rgba(255,165,0,0.15), 0 0 8px rgba(255,165,0,0.2);
  background: linear-gradient(180deg, rgba(255,200,120,0.12), rgba(255,165,0,0.04));
  border-color: #ff8c00;
}
.char-grid button.selected {
  background-color: #fff7ef;
}
</style>

</head>
<body>
<div id="bgDefault"></div>
<div id="bgDark"></div>
<div id="fadeOverlay"></div>
<div id="gameContainer">
<canvas height="780" id="gameCanvas" width="1320"></canvas>

<div id="totalScoreDisplay" style="
  position:absolute;
  bottom:10px;
  right:12px;
  z-index:15;
  font-size:12px;
  opacity:0.85;
  color:#f1c40f;
  text-shadow:1px 1px 2px #000;
  font-family:'Press Start 2P', cursive;
  pointer-events:none;
">
PUNTEGGIO TOTALE: 0
</div>

<div class="ui-overlay" id="uiOverlay" style="display:none;">
<div>HP: <span id="hpText">100</span></div>
<div class="hp-bar"><div class="hp-fill" id="hpFill" style="width:100%"></div></div>
<div id="superCooldown" style="margin-top:6px;font-size:12px;color:#fff;font-family:'Press Start 2P', cursive;;color:#ff9800;">Super: Ready</div>
<div id="bonusTimers" style="margin-top:4px;font-size:11px;line-height:1.4;color:#fff;font-family:'Press Start 2P', cursive;display:none;"></div>




</div>
<div class="score" id="scoreDisplay" style="display:none;">Score: 0</div>
<div class="score" id="killsDisplay" style="display:none; top:52px;">Kill: 0</div>
<div class="timer" id="timerDisplay" style="display:none;">45</div>
<div class="level-indicator" id="levelDisplay" style="display:none;">Level 1</div>

<div class="evo-banner" id="evoBanner" style="display:none;">
<div id="evoBannerText">EVOLUTO!</div>
</div>
<div class="menu" id="startScreen">
  <h1>‚öîÔ∏è JEFF‚ÄôS CHRONICLES‚öîÔ∏è</h1>
  <h2>Scegli la modalit√†</h2>
  <p style="margin-top:10px;font-size:15px;color:#ddd;line-height:1.4;">
    <strong>Difficile</strong>: gioco originale.<br>
    <strong>Facile</strong>: cure tra i livelli (+25% ogni livello, <em>cura totale</em> ogni 5¬∞ livello) ma <em>punteggio dimezzato</em>.
  </p>
  <div class="start-row" style="margin-top:18px;flex-wrap:wrap;">
    <button class="btn" id="modeHardBtn" type="button">MODALIT√Ä DIFFICILE</button>
    <button class="btn" id="modeEasyBtn" type="button">MODALIT√Ä FACILE</button>
  </div>
</div>

<div class="menu" id="mainMenu" style="display:none;">
<h1>‚öîÔ∏è JEFF‚ÄôS CHRONICLES‚öîÔ∏è</h1>
<h2>Seleziona il tuo combattente</h2>

<div class="compact-selector">
  <div class="char-grid"><button data-target="jimmy">JIMMY üî´<br><small class="btn-record" id="btnrec-jimmy">R: 0</small></button>
    <button data-target="rooney">ROONEY üê±<br><small class="btn-record" id="btnrec-rooney">R: 0</small></button>
    <button data-target="jeff">JEFF üó°Ô∏è<br><small class="btn-record" id="btnrec-jeff">R: 0</small></button>
    <button data-target="voltryx">VOLTRYX ü¶ä<br><small class="btn-record" id="btnrec-voltryx">R: 0</small></button>
    <button data-target="kouvagia">KOUVAGIA ü¶â<br><small class="btn-record" id="btnrec-kouvagia">R: 0</small></button>
    <button data-target="salsy">SALSY ‚öúÔ∏è<br><small class="btn-record" id="btnrec-salsy">R: 0</small></button>
    <button data-target="tempostorm">TEMPOSTORM üîã<br><small class="btn-record" id="btnrec-tempostorm">R: 0</small></button>
    <button data-target="marz">MARZ ü™Ñ<br><small class="btn-record" id="btnrec-marz">R: 0</small></button>
    <button data-target="hecate">H√àCATE üåò<br><small class="btn-record" id="btnrec-hecate">R: 0</small></button>
    <button data-target="marcus">MARCUS üé∂<br><small class="btn-record" id="btnrec-marcus">R: 0</small></button>
    <button data-target="lucien">LUCIEN üó∫Ô∏è<br><small class="btn-record" id="btnrec-lucien">R: 0</small></button>
    <button data-target="pdor">PDOR ‚ù§Ô∏è‚Äçüî•<br><small class="btn-record" id="btnrec-pdor">R: 0</small></button>
<button data-target="bane">BANE ü™ì<br><small class="btn-record" id="btnrec-bane">R: 0</small></button>
<button data-target="hendel">HENDEL ü™®<br><small class="btn-record" id="btnrec-hendel">R: 0</small></button>
<button data-target="kaerith">KAERITH üêâ<br><small class="btn-record" id="btnrec-kaerith">R: 0</small></button>
<button class="btn character-btn disabled" data-target="extra2" disabled>‚ùì Nuovo</button>
<button class="btn character-btn disabled" data-target="extra3" disabled>‚ùì Nuovo</button>


</div>
</div>
<div class="character-select">
<div class="character-card" data-char="jimmy" id="card-jimmy">
<h3>JIMMY</h3>
<p>"üî´"</p>
<div class="menu-stats"><span class="stat" id="menu-hp-jimmy">-</span><span class="spacer"> </span><span class="stat" id="menu-dmg-jimmy">-</span></div>
<div class="record-badge" id="record-jimmy">Record: 0</div>
</div>
<div class="character-card" data-char="rooney" id="card-rooney">
<h3>ROONEY</h3>
<p>"üê±"</p>
<div class="menu-stats"><span class="stat" id="menu-hp-rooney">-</span><span class="spacer"> </span><span class="stat" id="menu-dmg-rooney">-</span></div>
<div class="record-badge" id="record-rooney">Record: 0</div>
</div>
<div class="character-card" data-char="jeff" id="card-jeff">
<h3>JEFF</h3>
<p>"üó°Ô∏è"</p>
<div class="menu-stats"><span class="stat" id="menu-hp-jeff">-</span><span class="spacer"> </span><span class="stat" id="menu-dmg-jeff">-</span></div>
<div class="record-badge" id="record-jeff">Record: 0</div>
</div>
<!-- Voltryx card (locked until all three records > 50000) -->
<div class="character-card disabled" data-char="voltryx" id="card-voltryx" title="Sblocca completando 45.000 punti con ogni personaggio">
<h3>VOLTRYX</h3>
<p>"ü¶ä"</p>
<div class="menu-stats"><span class="stat" id="menu-hp-voltryx">-</span><span class="spacer"> </span><span class="stat" id="menu-dmg-voltryx">-</span></div>
<div class="record-badge" id="record-voltryx">Record: 0</div>
<div class="lock-badge" id="voltryxLockBadge">LOCKED</div>
</div>
<!-- Kouvagia card (locked until 51.000 score with Voltryx) -->
<div class="character-card disabled" data-char="kouvagia" id="card-kouvagia" title="Sblocca facendo 51.000 punti con Voltryx">
<h3>KOUVAGIA</h3>
<p>"ü¶â"</p>
<div class="menu-stats"><span class="stat" id="menu-hp-kouvagia">-</span><span class="spacer"> </span><span class="stat" id="menu-dmg-kouvagia">-</span></div>
<div class="record-badge" id="record-kouvagia">Record: 0</div>
<div class="lock-badge" id="kouvagiaLockBadge">LOCKED</div>
</div>
<!-- Salsy card (locked until 60.000 score with Jimmy, Rooney, Jeff, Voltryx and Kouvagia) -->
<div class="character-card disabled" data-char="salsy" id="card-salsy" title="Sblocca facendo 60.000 punti con Jimmy, Rooney, Jeff, Voltryx e Kouvagia">
<h3>SALSY</h3>
<p>"‚öúÔ∏è"</p>
<div class="menu-stats"><span class="stat" id="menu-hp-salsy">-</span><span class="spacer"> </span><span class="stat" id="menu-dmg-salsy">-</span></div>
<div class="record-badge" id="record-salsy">Record: 0</div>
<div class="lock-badge" id="salsyLockBadge">LOCKED</div>
</div>
<!-- Altri personaggi (aperti con +) -->
<div class="character-select extra-characters" id="extraCharacterSelect" style="display:none;">
<!-- Tempostorm card (moved here as FIRST extra character) -->
<div class="character-card disabled" data-char="tempostorm" id="card-tempostorm" style="margin-right:8px;" title="Sblocca facendo 65.000 punti con tutti i personaggi precedenti (Jimmy, Rooney, Jeff, Voltryx, Kouvagia e Salsy)">
<h3>TEMPOSTORM</h3>
<p>"üîã"</p>
<div class="menu-stats"><span class="stat" id="menu-hp-tempostorm">-</span><span class="spacer"> </span><span class="stat" id="menu-dmg-tempostorm">-</span></div>
<div class="record-badge" id="record-tempostorm">Record: 0</div>
<div class="lock-badge" id="tempostormLockBadge">LOCKED</div>
</div>
<!-- Marz card (SECOND, to the right) -->
<div class="character-card disabled" data-char="marz" id="card-marz" title="Sblocca facendo 70.000 punti con tutti i personaggi precedenti (Jimmy, Rooney, Jeff, Voltryx, Kouvagia, Salsy e Tempostorm)">
<h3>MARZ</h3>
<p>"ü™Ñ"</p>
<div class="menu-stats"><span class="stat" id="menu-hp-marz">-</span><span class="spacer"> </span><span class="stat" id="menu-dmg-marz">-</span></div>
<div class="record-badge" id="record-marz">Record: 0</div>
<div class="lock-badge" id="marzLockBadge">LOCKED</div>
</div>
<!-- H√®cate card (locked until 75.000 score with all previous characters) -->
<div class="character-card disabled" data-char="hecate" id="card-hecate" title="Sblocca facendo 75.000 punti con tutti i personaggi precedenti (Jimmy, Rooney, Jeff, Voltryx, Kouvagia, Salsy, Tempostorm e Marz)">
<h3>H√àCATE</h3>
<p>"üåò"</p>
<div class="menu-stats"><span class="stat" id="menu-hp-hecate">-</span><span class="spacer"> </span><span class="stat" id="menu-dmg-hecate">-</span></div>
<div class="record-badge" id="record-hecate">Record: 0</div>
<div class="lock-badge" id="hecateLockBadge">LOCKED</div>
</div>



<!-- Marcus card (locked until at least one record >= 70.000) -->
<div class="character-card disabled" data-char="marcus" id="card-marcus" title="Sblocca facendo almeno 70.000 punti con QUALSIASI personaggio">
<h3>MARCUS</h3>
<p>"üé∂"</p>
<div class="menu-stats"><span class="stat" id="menu-hp-marcus">-</span><span class="spacer"> </span><span class="stat" id="menu-dmg-marcus">-</span></div>
<div class="record-badge" id="record-marcus">Record: 0</div>
<div class="lock-badge" id="marcusLockBadge">LOCKED</div>
</div>

<!-- Lucien card (locked until record Marcus > 25.000) -->
<div class="character-card disabled" data-char="lucien" id="card-lucien" title="Sblocca facendo pi√π di 25.000 punti con Marcus">
<h3>LUCIEN</h3>
<p>"üó∫Ô∏è"</p>
<div class="menu-stats"><span class="stat" id="menu-hp-lucien">-</span><span class="spacer"> </span><span class="stat" id="menu-dmg-lucien">-</span></div>

<!-- Pdor card (locked until record Marcus >= 50.000 AND Lucien >= 50.000) -->
<div class="character-card disabled" data-char="pdor" id="card-pdor" title="Sblocca facendo almeno 50.000 punti di record con Marcus e Lucien">
<h3>PDOR</h3>
<p>"‚ù§Ô∏è‚Äçüî•"</p>
<div class="menu-stats"><span class="stat" id="menu-hp-pdor">-</span><span class="spacer"> </span><span class="stat" id="menu-dmg-pdor">-</span></div>
<div class="record-badge" id="record-pdor">Record: 0</div>
<div class="lock-badge" id="pdorLockBadge">LOCKED</div>
</div>
<!-- Bane card (locked until record PDOR >= 50.000) -->
<div class="character-card disabled" data-char="bane" id="card-bane" title="Sblocca facendo almeno 50.000 punti di record con PDOR">
<h3>BANE</h3>
<p>"ü™ì"</p>
<div class="menu-stats"><span class="stat" id="menu-hp-bane">-</span><span class="spacer"> </span><span class="stat" id="menu-dmg-bane">-</span></div>
<div class="record-badge" id="record-bane">Record: 0</div>
<div class="lock-badge" id="baneLockBadge">LOCKED</div>
</div>
<div class="record-badge" id="record-lucien">Record: 0</div>
<div class="lock-badge" id="lucienLockBadge">LOCKED</div>
</div>

</div>
</div>
<div class=\"start-row\">

<button class="btn" id="startBtn">INIZIA BATTAGLIA</button>
</div>
<!-- Hendel card (locked until record Bane >= 50.000) -->
<div class="character-card disabled" data-char="hendel" id="card-hendel" title="Sblocca facendo almeno 50.000 punti di record con Bane">
<h3>HENDEL</h3>
<p>"ü™®"</p>
<div class="menu-stats"><span class="stat" id="menu-hp-hendel">-</span><span class="spacer"> </span><span class="stat" id="menu-dmg-hendel">-</span></div>
<div class="record-badge" id="record-hendel">Record: 0</div>
<div class="lock-badge" id="hendelLockBadge">LOCKED</div>

<!-- Kaerith card (locked until record Hendel >= 40.000) -->
<div class="character-card disabled" data-char="kaerith" id="card-kaerith" title="Sblocca facendo 40.000 punti con Hendel">
<h3>KAERITH üêâ</h3>
<p>"üêâ"</p>
<div class="menu-stats"><span class="stat" id="menu-hp-kaerith">-</span><span class="spacer"> </span><span class="stat" id="menu-dmg-kaerith">-</span></div>
<div class="record-badge" id="record-kaerith">Record: 0</div>
<div class="lock-badge" id="kaerithLockBadge">LOCKED</div>
</div>

</div>

<!-- Pulsante immagine per aprire la guida -->
<button aria-label="Apri guida" class="img-btn" id="guideImgBtn" style="display:inline-block;" title="Apri guida" type="button">
<img alt="Guida" id="guideImg" src="https://i.postimg.cc/JztT9fJH/bea.png"/>
</button>
<!-- Pulsante immagine per aprire il bestiario (nemici + boss) -->
<button aria-label="Apri bestiario" class="img-btn" id="enemyGuideImgBtn" style="display:inline-block;" title="Bestiario (Nemici &amp; Boss)" type="button">
<img alt="Bestiario" id="enemyGuideImg" src="https://i.postimg.cc/NFVhJNLC/pixelcut-export-(2).png"/>
</button>
<p style="margin-top:12px;font-size:15px;color:#ddd">Controlli: WASD - Muovi | J - Attacco | K - Super Mossa | Spazio - Schivata</p>
</div>

</div>
<div class="end-screen" id="endScreen" style="display:none;">
<h1 id="endTitle">GAME OVER</h1>
<p id="endMessage">Score Finale: 0</p>
<p id="endKills">Kill: 0</p>
<p id="endSub">Hai raggiunto il Livello 1</p>
<p id="recordMessage">Record Personaggio: 0</p>
<button class="btn" id="restartBtn">RIPROVA</button>
<button class="btn" id="menuBtn">TORNA AL MENU</button>
</div>

<!-- Modale guida -->
<div aria-hidden="true" aria-labelledby="guideTitle" class="guide-modal" id="guideModal" role="dialog" style="display:none;">
<div class="guide-modal-content" role="document">
<button aria-label="Chiudi guida" class="guide-close" id="guideClose">‚úï</button>
<h2 id="guideTitle">Guida completa a Jeff‚Äôs Chronicles</h2>
<div class="guide-body">
<h3>1) PANORAMICA GENERALE</h3>
<p><strong>Jeff‚Äôs Chronicles</strong> √® un arena-fighter a schermo fisso. Il giocatore sceglie un combattente e affronta ondate di nemici e boss all‚Äôinterno di un‚Äôarena chiusa, cercando di ottenere il punteggio pi√π alto possibile prima della fine del tempo.</p>
<p>Il gioco combina: azione rapida, gestione dei cooldown, uso intelligente di dash, super e pickup, progressione tramite record personali. Ogni partita √® diversa grazie alla variet√† di nemici, livelli e potenziamenti.</p>
<h3>2) OBIETTIVO, LIVELLI E PUNTEGGIO</h3>
<p><strong>Obiettivo del livello</strong>: eliminare tutti i nemici presenti nell‚Äôarena e sopravvivere fino allo scadere del tempo.</p>
<p><strong>Livelli</strong>: cambiano per tipo di nemici, numero di avversari, tempo disponibile e presenza di boss. La difficolt√† aumenta progressivamente.</p>
<p><strong>Punteggio</strong>: ogni nemico ucciso fornisce <strong>+100 √ó livello corrente</strong>. Subire danno comporta <strong>‚àí50 punti</strong> (il punteggio non scende mai sotto zero). I livelli avanzati permettono di ottenere score molto pi√π elevati.</p>
<h3>3) CONTROLLI</h3>
<ul>
<li><strong>W A S D</strong> ‚Üí Movimento</li>
<li><strong>J</strong> ‚Üí Attacco base</li>
<li><strong>K</strong> ‚Üí Super mossa</li>
<li><strong>Spazio</strong> ‚Üí Dash / Schivata</li>
</ul>
<h3>4) INTERFACCIA (HUD)</h3>
<p>Durante la partita sono sempre visibili: HP e barra della vita, timer del livello, livello corrente, cooldown della super, punteggio totale e indicatori di buff attivi. Tenere d‚Äôocchio il timer e la super √® fondamentale per sopravvivere nei livelli avanzati.</p>
<h3>5) MOVIMENTO E DASH</h3>
<p>Il movimento √® libero in 8 direzioni.</p>
<p><strong>Dash / Schivata</strong>: √® uno scatto rapido che rende pi√π difficile essere colpiti. Ha un cooldown breve. Serve per evitare attacchi corpo a corpo, schivare proiettili e laser e riposizionarsi rapidamente. Alcuni personaggi hanno dash pi√π lunghi o pi√π veloci rispetto ad altri.</p>
<h3>6) ATTACCO BASE</h3>
<p>Ogni personaggio ha: un tipo di attacco unico, un range specifico e un cooldown personale. Il gioco utilizza un aim-assist leggero: quando attacchi, il personaggio tende a orientarsi verso il nemico pi√π vicino per rendere i colpi pi√π fluidi.</p>
<h3>7) SUPER MOSSA</h3>
<p>Ogni personaggio possiede una super unica. Le super hanno cooldown lunghi. Possono colpire pi√π nemici, marchiare bersagli o creare zone di danno. Usarle nel momento giusto √® la chiave per superare i livelli pi√π difficili.</p>
<h3>8) DIFESA, SCUDI E STATUS</h3>
<p><strong>Scudi</strong>: alcuni personaggi possiedono scudi con durabilit√†. Esistono pickup che forniscono invulnerabilit√† temporanea.</p>
<p><strong>Status negativi</strong>: <strong>Poison</strong> (perdita di HP nel tempo). I danni da status possono uccidere se non gestiti.</p>
<h3>9) PICKUP E POTENZIAMENTI</h3>
<p>I pickup iniziano a comparire nei livelli avanzati.</p>
<ul>
<li><strong>Heal</strong>: cura il 25% degli HP massimi.</li>
<li><strong>Atk</strong>: aumenta il danno per alcuni secondi.</li>
<li><strong>Super</strong>: ricarica immediatamente la super.</li>
<li><strong>Speed</strong>: aumenta la velocit√† di movimento.</li>
<li><strong>Shield</strong>: invulnerabilit√† temporanea.</li>
<li><strong>StellarBonus</strong>: <strong>+100 HP</strong> e <strong>+25% velocit√†</strong> per <strong>3s</strong>. Inoltre il personaggio emana un <strong>bagliore bianco luminoso e trasparente</strong> per <strong>1s</strong>. <em>Rilasciato solo dai boss.</em></li>
<li><strong>Gold</strong>: cura totale + grande aumento del danno + super pronta.</li>
<li><strong>Malus</strong>: applica poison.</li>
<li><strong>Furia</strong>: emana 3 grandi onde ad area (sempre pi√π grandi) che infliggono <strong>20 danni</strong> ciascuna; inoltre cura <strong>+10 HP/s</strong> per <strong>10s</strong>.</li>
<li><strong>Ice</strong>: rallenta drasticamente <strong>tutti i nemici presenti</strong> (effetto permanente fino alla loro morte) e infligge <strong>2 danni/s</strong> per <strong>17s</strong>.</li>
</ul>
<p>Usare correttamente i pickup pu√≤ ribaltare completamente una partita.</p>
<h3>10) PERSONAGGI ‚Äì FUNZIONALIT√Ä E MECCANICHE</h3>
<h4>üî´ JIMMY </h4>
<p><strong>Ruolo</strong>: inseguimento e eliminazione rapida di bersagli.</p>
<p><strong>Attacco base (Grapple)</strong>: Jimmy aggancia automaticamente un nemico vicino. Finch√© √® agganciato, lo insegue in modo automatico. Quando lo raggiunge, infligge danni elevati. Se il bersaglio muore o scompare, il grapple termina.</p>
<p><strong>Scudo a durabilit√†</strong>: durante gli attacchi Jimmy attiva uno scudo. Ogni colpo assorbito consuma 1 punto di durabilit√†. Quando la durabilit√† √® zero, lo scudo si rompe e smette di funzionare temporaneamente.</p>
<p><strong>Super</strong>: seleziona pi√π bersagli. Jimmy li insegue uno dopo l‚Äôaltro colpendoli con danni potenziati. Durante la super √® molto pi√π difficile da fermare.</p>
<p><strong>Passiva ‚Äì Jetpack</strong>: ogni tot secondi si attiva automaticamente. Fornisce aumento di velocit√† e garantisce maggiore sicurezza nei movimenti.</p>
<p><strong>Stile consigliato</strong>: aggressivo e mobile.</p>
<h4>üê± ROONEY</h4>
<p><strong>Ruolo</strong>: resistenza e danni ravvicinati.</p>
<p><strong>Attacco base</strong>: serie di pugni potenti a corto raggio. Ottimo contro nemici lenti o raggruppati.</p>
<p><strong>Super</strong>: colpo ad area che frantuma il terreno in una <strong>zona quadrata</strong> centrata su Rooney. Il <strong>danno totale massimo √® 300</strong> (senza buff) e viene distribuito tra tutti i nemici presenti nell‚Äôarea: chi √® pi√π vicino al centro subisce pi√π danno, chi √® verso i bordi ne subisce meno. Perfetta per ripulire ondate e per fare burst se resti vicino al bersaglio principale.</p>
<p><strong>Stile consigliato</strong>: restare vicino ai nemici e controllare lo spazio.</p>
<h4>üó°Ô∏è JEFF </h4>
<p><strong>Ruolo</strong>: controllo dell‚Äôarena.</p>
<p><strong>Attacco base</strong>: fendente ad arco con la spada. Buona velocit√† e affidabilit√†.</p>
<p><strong>Super</strong>: crea una grande area intorno a Jeff. Infligge danni periodici a tutti i nemici all‚Äôinterno. Molto efficace contro boss e gruppi.</p>
<p><strong>Stile consigliato</strong>: posizionamento intelligente.</p>
<div id="guide-voltryx-locked" style="margin-top:10px;padding:10px;border:2px dashed rgba(255,255,255,0.35);background:rgba(255,255,255,0.05);">
<h4>ü¶ä VOLTRYX </h4>
<p><em>Questo personaggio si sblocca facendo oltre 45.000 punti con Jimmy, Rooney e Jeff.. La descrizione apparir√† automaticamente appena lo sblocchi.</em></p>
</div>
<div id="guide-voltryx" style="display:none;">
<h4>ü¶ä VOLTRYX </h4>
<p><strong>Ruolo</strong>: versatilit√† totale.</p>
<p><strong>Attacco base</strong>: da lontano spara un proiettile energetico ad area; da vicino esegue due pugni rapidi.</p>
<p><strong>Super</strong>: genera una sfera energetica che rilascia impulsi di danno ad area, colpendo ripetutamente i nemici nel raggio.</p>
<p><strong>Stile consigliato</strong>: alternare distanza e mischia.</p>
<p><strong>Sblocco</strong>: oltre 45.000 punti con Jimmy, Rooney e Jeff.</p>
</div>
<div id="guide-kouvagia-locked" style="margin-top:10px;padding:10px;border:2px dashed rgba(255,255,255,0.35);background:rgba(255,255,255,0.05);">
<h4>ü¶â KOUVAGIA </h4>
<p><em>Questo personaggio si sblocca facendo 50.000 punti con Voltryx. La descrizione apparir√† automaticamente appena lo sblocchi.</em></p>
</div>
<div id="guide-kouvagia" style="display:none;">
<h4>ü¶â KOUVAGIA </h4>
<p><strong>Ruolo</strong>: sopravvivenza e danni da contatto.</p>
<p><strong>Attacco base</strong>: dash offensivo che infligge danni ai nemici attraversati. Al termine del dash esplode infliggendo danni ad area.</p>
<p><strong>Passiva ‚Äì Dash offensivo</strong>: ogni schivata infligge danni ai nemici vicini.</p>
<p><strong>Passiva ‚Äì Cura su uccisione</strong>: ogni nemico ucciso a distanza ravvicinata cura Kouvagia.</p>
<p><strong>Super</strong>: cura completa e genera un‚Äôonda che respinge i nemici.</p>
<p><strong>Stile consigliato</strong>: usare spesso il dash e restare nel caos.</p>
<p><strong>Sblocco</strong>: 50.000 punti con Voltryx.</p>
</div>
<div id="guide-salsy-locked" style="margin-top:10px;padding:10px;border:2px dashed rgba(255,255,255,0.35);background:rgba(255,255,255,0.05);">
<h4>‚öúÔ∏è SALSY </h4>
<p><em>Questo personaggio si sblocca facendo 60.000 punti con tutti gli altri personaggi.. La descrizione apparir√† automaticamente appena lo sblocchi.</em></p>
</div>
<div id="guide-salsy" style="display:none;">
<h4>‚öúÔ∏è SALSY </h4>
<p><strong>Ruolo</strong>: burst damage e controllo dei bersagli.</p>
<p><strong>Attacco base</strong>: doppio fendente consecutivo. Pu√≤ colpire lo stesso nemico due volte con un singolo attacco.</p>
<p><strong>Super ‚Äì Marchio</strong>: marchia fino a 3 nemici. I nemici marchiati subiscono danni raddoppiati per alcuni secondi.</p>
<p><strong>Passiva ‚Äì Boost velocit√†</strong>: periodicamente ottiene un aumento temporaneo di velocit√†, perfetto per entrare e uscire dai combattimenti.</p>
<p><strong>Stile consigliato</strong>: colpisci, marchia e ritirati.</p>
<p><strong>Sblocco</strong>: 60.000 punti con tutti gli altri personaggi.</p>
</div>
<div id="guide-tempostorm-locked" style="margin-top:10px;padding:10px;border:2px dashed rgba(255,255,255,0.35);background:rgba(255,255,255,0.05);">
<h4>üîã TEMPOSTORM</h4>
<p><em>Questo personaggio si sblocca facendo <strong>70.000 punti</strong> con tutti i personaggi precedenti (Jimmy, Rooney, Jeff, Voltryx, Kouvagia e Salsy). La descrizione completa apparir√† automaticamente appena lo sblocchi.</em></p>
</div>
<div id="guide-tempostorm" style="display:none;">
<h4>üîã TEMPOSTORM</h4>
<p><strong>Ruolo</strong>: controllo di zona + sustain tramite Super.</p>
<p><strong>Statistiche</strong>: 300 HP, velocit√† leggermente superiore a Rooney.</p>
<p><strong>Attacco base</strong>: fasci di energia blu (laser). Infligge <strong>40</strong> danni al primo impatto e altri <strong>30</strong> se il nemico resta dentro il fascio dopo essere stato colpito.</p>
<p><strong>Super ‚Äì Tempesta Centrale</strong>: raggruppa tutti i nemici esattamente al centro dell‚Äôarena, dimezza la loro vita e converte la somma della vita sottratta in una <strong>cura personale</strong> tramite un effetto speciale blu.</p>
<p><strong>Sblocco</strong>: 70.000 punti con tutti i personaggi precedenti.</p>
</div>
<div id="guide-marz-locked" style="margin-top:10px;padding:10px;border:2px dashed rgba(255,255,255,0.35);background:rgba(255,255,255,0.05);">
<h4>ü™Ñ MARZ</h4>
<p><em>Questo personaggio si sblocca facendo <strong>70.000 punti</strong> con tutti i personaggi precedenti (Jimmy, Rooney, Jeff, Voltryx, Kouvagia, Salsy e Tempostorm). La descrizione completa apparir√† automaticamente appena lo sblocchi.</em></p>
</div>
<div id="guide-marz" style="display:none;">
<h4>ü™Ñ MARZ</h4>
<p><strong>Ruolo</strong>: mago da controllo e danno a bersagli multipli.</p>
<p><strong>Statistiche</strong>: 320 HP, velocit√† 7.2.</p>
<p><strong>Attacco base</strong>: spara <strong>tre fasci magici</strong> (corti) con danni diversi: <strong>40</strong>, <strong>50</strong>, <strong>60</strong>. Se ci sono almeno 3 nemici, colpisce fino a 3 bersagli differenti; se i nemici sono meno, i fasci si concentrano sugli stessi bersagli disponibili.</p>
<p><strong>Super ‚Äì Sigillo Arcano</strong>: crea esattamentte al centro della mappa un <strong>cerchi arcano </strong> che si espande molto lentamente causando molti danni ai nemici presenti all'interno inoltre Marz all'interno dell'area del sigillo ottiene <strong>un aumento del 50% della velocit√†</strong> finche la super resta attiva quindi per <strong>10 secondi</strong>.</p>
<p><strong>Sblocco</strong>: 70.000 punti con tutti i personaggi precedenti.</p>
</div>

<div id="guide-hecate-locked" style="margin-top:10px;padding:10px;border:2px dashed rgba(255,255,255,0.35);background:rgba(255,255,255,0.05);">
<h4>üåò H√àCATE</h4>
<p><em>Questo personaggio si sblocca facendo <strong>75.000 punti</strong> con tutti i personaggi precedenti (Jimmy, Rooney, Jeff, Voltryx, Kouvagia, Salsy, Tempostorm e Marz). La descrizione completa apparir√† automaticamente appena lo sblocchi.</em></p>
</div>
<div id="guide-hecate" style="display:none;">
<h4>üåò H√àCATE</h4>
<p><strong>Ruolo</strong>: tiratrice a lunga distanza + sustain tramite Super.</p>
<p><strong>Statistiche</strong>: 325 HP, dash identico a Voltryx.</p>
<p><strong>Attacco base</strong>: scocca una <strong>freccia a lunghissima distanza</strong> che infligge il danno maggiore al <strong>primo nemico colpito</strong>. Nel punto d‚Äôimpatto la freccia si <strong>divide istantaneamente</strong> (effetto visivo) in <strong>tre frecce</strong> che cercano e colpiscono <strong>altri nemici</strong> (non quello gi√† colpito).</p>
<p><strong>Super ‚Äì Richiamo Lunare</strong>: si cura di <strong>5 HP per ogni nemico presente</strong> nell‚Äôarena al momento dell‚Äôattivazione. Inoltre richiama tre lupi che attaccano i nemici con morsi letali il richiamo puo essere attivato piu volte ma in campo ci possono essere massimo 3 lupi</p>
<p><strong>Sblocco</strong>: 75.000 punti con tutti i personaggi precedenti.</p>
</div>


<div id="guide-pdor-locked" style="margin-top:10px;padding:10px;border:2px dashed rgba(255,255,255,0.35);background:rgba(255,255,255,0.05);">
  <h4>ü™Ñ PDOR</h4>
  <p><em>Questo personaggio si sblocca facendo almeno <strong>50.000 punti</strong> di record con <strong>Marcus</strong> e <strong>Lucien</strong>. La descrizione completa apparir√† automaticamente appena lo sblocchi.</em></p>
</div>


<div id="guide-bane-locked" style="margin-top:10px;padding:10px;border:2px dashed rgba(255,255,255,0.35);background:rgba(255,255,255,0.05);">
  <h4>ü™ì BANE</h4>
  <p><em>Questo personaggio si sblocca facendo almeno <strong>50.000 punti</strong> di record con <strong>Pdor</strong>. La descrizione completa apparir√† automaticamente appena lo sblocchi.</em></p>
</div>


<div id="guide-marcus-locked" style="margin-top:10px;padding:10px;border:2px dashed rgba(255,255,255,0.35);background:rgba(255,255,255,0.05);">
  <h4>üé∂ MARCUS</h4>
  <p><em>Questo personaggio si sblocca facendo almeno <strong>70.000 punti</strong> con <strong>qualsiasi</strong> personaggio. La descrizione completa apparir√† automaticamente appena lo sblocchi.</em></p>
</div>
<div id="guide-marcus" style="display:none;">
  <h4>üé∂ MARCUS</h4>
  <p><strong>Ruolo</strong>: supporto offensivo a media distanza + controllo con la Super.</p>
  <p><strong>Statistiche</strong>: 400 HP, velocit√† 7.</p>
  <p><strong>Attacco base ‚Äì Banjo Notes</strong>: Marcus suona il banjo e lancia <strong>note musicali</strong> (proiettili ondulati) che infliggono danni a distanza. Ottimo per tenere i nemici lontani mentre ti riposizioni.</p>
  <p><strong>Super ‚Äì Danza Stordente</strong>: gli avversari vengono <strong>storditi/confusi</strong> e ‚Äúballano‚Äù perdendo controllo per alcuni secondi. In pi√π Marcus ottiene uno <strong>scudo</strong> temporaneo.</p>
  <p><strong>Stile consigliato</strong>: colpisci da media distanza e usa la Super per creare spazio nei momenti critici.</p>
  <p><strong>Sblocco</strong>: 70.000 punti con qualsiasi personaggio.</p>
</div>

<div id="guide-lucien-locked" style="margin-top:10px;padding:10px;border:2px dashed rgba(255,255,255,0.35);background:rgba(255,255,255,0.05);">
  <h4>üó∫Ô∏è LUCIEN</h4>
  <p><em>Questo personaggio si sblocca facendo un record con <strong>Marcus</strong> superiore a <strong>25.000 punti</strong>. La descrizione completa apparir√† automaticamente appena lo sblocchi.</em></p>
</div>
<div id="guide-lucien" style="display:none;">
  <h4>üó∫Ô∏è LUCIEN</h4>
  <p><strong>Ruolo</strong>: ladro furtivo da burst ravvicinato + utilit√† tramite bonus.</p>
  <p><strong>Statistiche</strong>: 380 HP, velocit√† leggermente superiore alla media (dash/scatto pi√π reattivo).</p>
  <p><strong>Attacco base ‚Äì Lama Rapida</strong>: 4 colpi <strong>molto ravvicinati</strong> da <strong>15</strong> danni ciascuno (stile Salsy ma pi√π ‚Äúa raffica‚Äù e a distanza pi√π corta).</p>
  <p><strong>Super ‚Äì Furto di Bonus</strong>: Lucien ‚Äúruba‚Äù <strong>5 bonus casuali</strong> e li rilascia attorno a s√©: sono <strong>prendibili</strong> dal personaggio. La Super <strong>non</strong> pu√≤ generare bonus che ricaricano la Super (quindi niente <strong>Gold</strong> e niente <strong>ricarica Super</strong>).</p>
  <p><strong>Stile consigliato</strong>: entra rapido, scarica i 4 colpi e usa la Super per trasformare il fight in vantaggio di buff.</p>
  <p><strong>Sblocco</strong>: record con Marcus &gt; 25.000.</p>
</div>
<div id="guide-pdor" style="display:none;">
  <h4>ü™Ñ PDOR</h4>
  <p><strong>Ruolo</strong>: mago a distanza con controllo e ‚Äúchain‚Äù sui bersagli.</p>
  <p><strong>Background</strong>: Pdor √® un <strong>tiefling stregone</strong> che canalizza la propria magia per colpire da lontano.</p>
  <p><strong>Attacco base ‚Äì Dardo Arcano</strong>: lancia un dardo magico <strong>auto-mirato</strong> verso il nemico pi√π vicino. Il dardo pu√≤ <strong>rimbalzare/agganciarsi</strong> fino a <strong>5 bersagli</strong> diversi: a ogni salto il <strong>danno si dimezza</strong>. Ottimo per ripulire ondate e punire gruppi.</p>
  <p><strong>Super ‚Äì Luci danzanti</strong>: per circa <strong>8 secondi</strong> compaiono <strong>7 sfere luminose</strong> in posizioni casuali dell‚Äôarena. Ogni sfera emette pulsazioni ad anello: chi viene toccato dall‚Äôanello subisce danno e viene <strong>rallentato</strong> per breve tempo. Perfetta per controllare spazio, spezzare l‚Äôinseguimento e fare DPS costante se ‚Äúchiudi‚Äù i nemici nelle zone.</p>
  <p><strong>Sblocco</strong>: record ‚â• 50.000 con Marcus e Lucien.</p>
</div>
<div id="guide-bane" style="display:none;">
  <h4>ü™ì BANE</h4>
  <p><strong>Ruolo</strong>: melee da ondate, danni pesanti e pressione ravvicinata.</p>
  <p><strong>Background</strong>: Bane √® un <strong>barbaro</strong> armato di <strong>ascia bipenne</strong>, costruito per spaccare gruppi a corto raggio.</p>
  <p><strong>Attacco base ‚Äì Fendente d‚ÄôAscia</strong>: un colpo ampio a ventaglio (quasi a 270¬∞ davanti a te) che pu√≤ colpire fino a <strong>2 nemici</strong> per swing. √à ideale per eliminare rapidamente i minion e tenere pulita la zona vicino al personaggio.</p>
  <p><strong>Super ‚Äì IRA</strong>: entra in uno stato di furia per <strong>10 secondi</strong>. Durante IRA ottieni <strong>+25% velocit√†</strong> e l‚Äôattacco base diventa molto pi√π rapido (cooldown ridotto). Inoltre l‚Äôattacco base riceve un <strong>moltiplicatore danni</strong> in base alle kill che hai al momento dell‚Äôattivazione, rendendo IRA devastante nelle fasi avanzate. Alla fine di IRA il ritmo dell‚Äôattacco torna verso il valore base (con l‚Äôattuale impostazione post-IRA).</p>
  <p><strong>Sblocco</strong>: record ‚â• 50.000 con Pdor.</p>
</div>


<div id="guide-hendel-locked" style="margin-top:10px;padding:10px;border:2px dashed rgba(255,255,255,0.35);background:rgba(255,255,255,0.05);">
  <h4>ü™® HENDEL</h4>
  <p><em>Questo personaggio si sblocca facendo almeno <strong>50.000 punti</strong> di record con <strong>Bane</strong>. La descrizione completa apparir√† automaticamente appena lo sblocchi.</em></p>
</div>

<div id="guide-hendel" style="display:none;">
  <h4>ü™® HENDEL</h4>
  <p><strong>Ruolo</strong>: bruiser difensivo da controllo ravvicinato (punisce chi prova a ingaggiarti).</p>
  <p><strong>Statistiche</strong>: alta resistenza e presenza in mischia.</p>
  <p><strong>Attacco base (J) ‚Äì Martello Rotante</strong>: Hendel esegue uno swing a ‚Äúmartello‚Äù con area composta da <strong>manico vicino</strong> e <strong>testa lontana</strong>. Durante l‚Äôattacco l‚Äôhitbox ruota in <strong>senso orario</strong> per circa <strong>75¬∞</strong> e pu√≤ colpire <strong>un solo avversario</strong> per swing. Infligge <strong>120 danni</strong> e applica <strong>stordimento per 0,5s</strong> al bersaglio colpito.</p>
  <p><strong>Passiva ‚Äì Ritorsione di Pietra</strong>: ogni nemico che colpisce Hendel viene <strong>respinto lontano</strong> (knockback aumentato) e subisce <strong>30 danni</strong>. √à perfetta per spezzare assalti melee e punire anche i ranged quando riesci a farli ‚Äúsporcare‚Äù su di te.</p>
  <p><strong>Super ‚Äì Stone Perimeter Crush</strong>: richiama un perimetro di pietra che si <strong>chiude progressivamente</strong> sull‚Äôarena, danneggiando i nemici e comprimendoli verso il centro. Ottima per ripulire ondate, controllare boss e forzare posizionamenti sfavorevoli.</p>
  <p><strong>Stile consigliato</strong>: gioca ‚Äúfrontline‚Äù. Entra nel gruppo, prendi un hit con la passiva per creare spazio, poi chiudi con J sul bersaglio pi√π pericoloso.</p>
  <p><strong>Sblocco</strong>: record ‚â• 50.000 con Bane.</p>

<div id="guide-kaerith-locked" style="display:block;padding:12px;border-radius:10px;border:1px dashed rgba(255,255,255,0.35);background:rgba(255,255,255,0.05);margin-top:10px;">
  <h4>üêâ KAERITH</h4>
  <p><em>Questo personaggio si sblocca facendo almeno <strong>40.000 punti</strong> di record con <strong>Hendel</strong>. La descrizione completa apparir√† automaticamente appena lo sblocchi.</em></p>
</div>

<div id="guide-kaerith" style="display:none;">
  <h4>üêâ KAERITH</h4>
  <p><strong>Specie</strong>: dragonide (dragonide da battaglia, controlla il campo con fiammate).</p>
  <p><strong>Statistiche</strong>: <strong>410 HP</strong> (molto resistente), mobilit√† media.</p>
  <p><strong>Attacco base (J) ‚Äì Fiammata Continua</strong>: Kaerith sprigiona una <strong>fiammata</strong> in cono davanti a s√© (stile i nemici dei livelli 23‚Äì24). Finch√© la fiammata √® attiva, il danno √® a <strong>tick ripetuti</strong> e <strong>aumenta progressivamente</strong> durante la stessa emissione: i primi istanti bruciano meno, poi la fiammata ‚Äúcarica‚Äù e diventa pi√π devastante.</p>
  <p><strong>Super (K) ‚Äì Inferno Totale</strong>: infuoca l‚Äôintero campo per <strong>9s</strong> con un overlay visivo di fiamme. Durante questo tempo tutti i nemici ottengono lo status <strong>Infuocato</strong>: ogni secondo subiscono danno progressivo che parte da <strong>5</strong> e sale fino a un massimo di <strong>25</strong> (cap). <strong>Ricarica: 21s</strong>.</p>
</div>

</div>

<h3>11) NEMICI E PERICOLI</h3>
<p>Nemici melee, veloci, resistenti e a distanza. Nemici con poison. Nemici con laser che richiedono schivata precisa. Boss con attacchi speciali e grandi quantit√† di HP.</p>
<h3>12) CONSIGLI FINALI</h3>
<ul>
<li>Usa il dash pi√π spesso di quanto pensi.</li>
<li>Le super vanno usate nei momenti critici.</li>
<li>Evitare danni √® importante anche per il punteggio.</li>
<li>Ogni personaggio √® forte se usato nel modo giusto.</li>
</ul>
<h3>‚ú¥Ô∏è EVOLUZIONI </h3>
<p>rappresentano una fase avanzata del combattimento e si attivano automaticamente durante la partita. Non sono potenziamenti temporanei, ma un vero e proprio cambiamento nello stile di gioco del personaggio.</p> <p><strong>Quando avvengono</strong>: dopo aver superato un boss avanzato (oltre met√† progressione), il personaggio entra nello stato <em>Evoluto</em>. L‚Äôevoluzione viene annunciata a schermo con un banner dedicato.</p> <p><strong>Filosofia delle evoluzioni</strong>: le evoluzioni <u>non aumentano direttamente HP, velocit√† o danno base</u>. Al contrario, sbloccano <strong>passive speciali</strong> che premiano l‚Äôuso intelligente delle meccaniche del personaggio. Questo mantiene il gioco bilanciato e strategico.</p> <h4>Effetti generali</h4> <ul> <li>L‚Äôevoluzione dura per il resto della partita.</li> <li>Ogni personaggio ottiene un <strong>vantaggio unico</strong>, coerente con il suo ruolo.</li> <li>Le evoluzioni premiano precisione, timing e gestione dei nemici.</li> </ul> <h4>‚öôÔ∏è Evoluzioni attuali</h4> <p><strong>üî´ Jimmy ‚Äì Predatore Evoluto</strong><br/> Jimmy carica la <strong>Super pi√π velocemente (+25%)</strong> e il <strong>cooldown dell‚Äôattacco base √® ridotto del 15%</strong>.</p>
<p><strong>üê± Rooney ‚Äì Impatto Brutale</strong><br/> Il <strong>primo colpo</strong> inflitto a ogni nemico infligge <strong>+50% danni</strong>.</p>
<p><strong>üó°Ô∏è Jeff ‚Äì Rigenerazione da Combattimento</strong><br/> Ogni nemico ucciso cura Jeff di <strong>5 HP</strong>.</p> <p><em>Nota:</em> i personaggi sbloccabili avanzati potrebbero ottenere evoluzioni dedicate in futuro.</p> <h4> Consigli strategici</h4> <ul> <li>Sfrutta l‚Äôevoluzione per cambiare approccio: da difensivo a aggressivo (o viceversa).</li> <li>Dopo l‚Äôevoluzione, eliminare i nemici velocemente diventa ancora pi√π importante per massimizzare punteggio e controllo.</li> <li>Le evoluzioni non rendono invincibili: il posizionamento resta fondamentale.</li> </ul> <p><strong>Le evoluzioni sono il momento in cui Jeff‚Äôs Chronicles premia davvero la padronanza del personaggio.</strong></p>
<h3>üèÅ CONCLUSIONE</h3>
<p><strong>Jeff‚Äôs Chronicles</strong> premia abilit√†, strategia e conoscenza dei personaggi. Impara i loro meccanismi, sfrutta i pickup e punta al record massimo.</p>
</div>
</div>
</div>
<!-- Modale bestiario (nemici e boss) -->
<div aria-hidden="true" aria-labelledby="enemyGuideTitle" class="guide-modal enemy-guide-modal" id="enemyGuideModal" role="dialog" style="display:none;">
<div class="guide-modal-content enemy-guide-content" role="document">
<button aria-label="Chiudi bestiario" class="guide-close" id="enemyGuideClose">‚úï</button>
<h2 id="enemyGuideTitle">Bestiario ‚Äì Nemici &amp; Boss</h2>
<div class="enemy-guide-body">
<div class="enemy-guide-wrap">
<div aria-label="Lista nemici sbloccati" class="enemy-guide-list" id="enemyGuideList"></div>
<div aria-live="polite" class="enemy-guide-detail" id="enemyGuideDetail">
<div class="enemy-guide-empty">
<h3 style="margin:0 0 8px 0;color:#f39c12;">Nessun nemico sbloccato</h3>
<p style="margin:0;color:#ddd;">Affronta un nemico o un boss almeno una volta per sbloccarlo qui.</p>
</div>
</div>
</div>
<p class="enemy-guide-hint">Nota: nel Bestiario compaiono solo i nemici/boss che hai gi√† sfidato almeno una volta (vale per tutti i personaggi).</p>
</div>
</div>
</div>
<script>
const HP_MULT=1.40;
const DAMAGE_MULT=0.85;
const SUPER_DAMAGE_MULT=0.8;
const JEFF_SUPER_RADIUS=Math.round(320*0.8);
const GOLD_PROB=0.05;
const JEFF_ATTACK_RANGE_MULT=0.8;
const JIMMY_SUPER_ADDITIONAL_MULT=0.85;
const JIMMY_BASE_ADDITIONAL_MULT=1.20;

const URL_DEFAULT='https://i.postimg.cc/8CBFTKs4/Progetto-senza-titolo.png';
const URL_DARK='https://i.postimg.cc/JhpWH3jJ/Copilot-20251209-232827.png';

// --- Hendel SUPER: Stone Perimeter Crush ---
let hendelCrush = null;
function startHendelCrush(duration=3000){
  hendelCrush = { start: Date.now(), duration, last: Date.now(), exploded:false };
}
function _hendelCrushBounds(){
  const now=Date.now();
  if(!hendelCrush) return null;
  const t=Math.max(0, Math.min(1, (now-hendelCrush.start)/hendelCrush.duration));
  const insetMax = Math.max(0, Math.min(canvas.width, canvas.height)/2 - 40);
  const inset = insetMax * t;
  return {t, left: inset, top: inset, right: canvas.width - inset, bottom: canvas.height - inset};
}
function updateHendelCrush(){
  if(!hendelCrush) return;
  const now=Date.now();
  const dt=Math.min(0.05, Math.max(0, (now-hendelCrush.last)/1000));
  hendelCrush.last = now;
  const b=_hendelCrushBounds();
  if(!b) return;

  // DoT while shrinking: 20 DPS to enemies; walls push enemies toward center
  if(enemies && enemies.length){
    for(let i=enemies.length-1;i>=0;i--){
      const e=enemies[i];
      const cx=e.x+e.width/2, cy=e.y+e.height/2;
      let pushed=false;
      if(cx < b.left){ e.x += (b.left - cx); pushed=true; }
      else if(cx > b.right){ e.x -= (cx - b.right); pushed=true; }
      if(cy < b.top){ e.y += (b.top - cy); pushed=true; }
      else if(cy > b.bottom){ e.y -= (cy - b.bottom); pushed=true; }

      // clamp
      e.x = Math.max(0, Math.min(canvas.width - e.width, e.x));
      e.y = Math.max(0, Math.min(canvas.height - e.height, e.y));

      // 20 damage per second during convergence
      const dmg = 20 * dt;
      if(dmg>0){
        applyEnemyDamage(e, dmg);
        if(pushed){
          createParticles(cx,cy,'#8b5a2b',2,2);
        }
        if(e.hp<=0){
          createParticles(e.x,e.y,'#fff176',22,6);
          dropStellarBonusAtIndexIfNeeded(i);
          enemies.splice(i,1);
          applyScore(100*currentLevel);
          addKill();
          if(player && player._baneSuperOnKill) player._baneSuperOnKill();
        }
      }
    }
  }

  // Final explosion at center
  if(b.t>=1 && !hendelCrush.exploded){
    hendelCrush.exploded=true;
    const cx=canvas.width/2, cy=canvas.height/2;
    createParticles(cx,cy,'#8b5a2b',160,8);
    createParticles(cx,cy,'#9e9e9e',160,8);
    shakeScreen();

    if(enemies && enemies.length){
      for(let i=enemies.length-1;i>=0;i--){
        const e=enemies[i];
        const final=applyEnemyDamage(e, 330);
        showDamageNumber(e.x,e.y,Math.round(final));
        createParticles(e.x+e.width/2,e.y+e.height/2,'#8b5a2b',26,6);
        createParticles(e.x+e.width/2,e.y+e.height/2,'#9e9e9e',18,6);
        if(e.hp<=0){
          createParticles(e.x,e.y,'#fff176',26,6);
          dropStellarBonusAtIndexIfNeeded(i);
          enemies.splice(i,1);
          applyScore(100*currentLevel);
          addKill();
          if(player && player._baneSuperOnKill) player._baneSuperOnKill();
        }
      }
    }
  }

  // cleanup shortly after explosion
  if(b.t>=1 && hendelCrush.exploded && (now-hendelCrush.start) > (hendelCrush.duration+350)){
    hendelCrush=null;
  }
}
function drawHendelCrush(){
  if(!hendelCrush) return;
  const b=_hendelCrushBounds();
  if(!b) return;
  const w=b.right-b.left, h=b.bottom-b.top;
  ctx.save();
  ctx.globalAlpha=0.9;
  ctx.lineWidth=6;
  ctx.strokeStyle='rgba(139,61,43,0.95)';
  ctx.strokeRect(b.left,b.top,w,h);
  ctx.globalAlpha=0.12;
  ctx.fillStyle='rgba(139,90,43,0.35)';
  ctx.fillRect(b.left,b.top,w,h);
  ctx.restore();
}



const URL_FINAL='https://i.postimg.cc/pTHFKHgz/Progetto-senza-titolo-(2).png';
const URL_ICE='https://i.postimg.cc/K8pgVhTx/icebiome1.png';
const canvas=document.getElementById('gameCanvas');
const ctx=canvas.getContext('2d');


function getPlayBounds(){
  // Limiti reali del campo giocabile (non per forza identici al canvas).
  // Rispetta il margine HUD in basso e, se attivo, lo shrink di Hendel Crush.
  const bottomLimit = canvas.height-30;
  let b = {left:0, top:0, right:canvas.width, bottom:bottomLimit};

  // Hendel Crush restringe l'arena: usiamo i suoi bounds se presenti
  try{
    if(typeof _hendelCrushBounds==='function'){
      const hb=_hendelCrushBounds();
      if(hb && typeof hb.left==='number'){
        b = {left:hb.left, top:hb.top, right:hb.right, bottom:Math.min(hb.bottom, bottomLimit)};
      }
    }
  }catch(e){}

  return b;
}

const bgDefault=document.getElementById('bgDefault');
const bgDark=document.getElementById('bgDark');
const fadeOverlay=document.getElementById('fadeOverlay');
let _bgTier=0; // 0=default,1=dark,2=final,3=ice

bgDefault.style.backgroundImage=`url('${URL_DEFAULT}')`;
bgDark.style.backgroundImage=`url('${URL_DARK}')`;
bgDefault.style.backgroundSize=bgDark.style.backgroundSize='cover';
bgDefault.style.backgroundPosition=bgDark.style.backgroundPosition='center';

let gameState='start';
let selectedCharacter=null;
let player=null;
let currentLevel=0;
let score=0;
let kills=0;
let timer=45;
let enemies=[];
let particles=[];
let pickups=[];
let difficultyMode='hard'; // 'hard' | 'easy'
let scoreMultiplier=1;     // easy => 0.5

function setDifficulty(mode){
  difficultyMode = (mode==='easy') ? 'easy' : 'hard';
  scoreMultiplier = (difficultyMode==='easy') ? 0.5 : 1;
}

function applyScore(delta){
  // In easy mode all score changes are halved (including penalties), and score never goes below 0.
  const scaled = delta * scoreMultiplier;
  // keep integers (same feeling as before)
  const d = (scaled>=0) ? Math.floor(scaled) : Math.ceil(scaled);
  score = Math.max(0, score + d);
}

function addKill(n=1){
  kills = Math.max(0, (kills||0) + (n||1));
  try{ addAccountKill(selectedCharacter, n||1); }catch(e){}
}


// --- Pickup hitbox tuning ---
// Bigger pickup hitbox (bonuses easier to collect), malus stays tighter.
const BONUS_HIT_RADIUS = 26; // was ~18
const MALUS_HIT_RADIUS = 18;

// Lower malus probability (weighted pick)
function pickRandomPickupType(){
  const weighted = [
    ['heal', 1],
    ['atk', 1],
    ['super', 1],
    ['speed', 1],
    ['shieldPickup', 1],
    ['furia', 1],
    ['ice', 1],
    ['malus', 0.25], // nerfed
  ];
  let sum = 0;
  for (const [,w] of weighted) sum += w;
  let r = Math.random() * sum;
  for (const [t,w] of weighted){
    r -= w;
    if (r <= 0) return t;
  }
  return 'heal';
}
let projectiles=[];

// --- MARZ SUPER: expanding magic zone ---
// Active only when Marz uses his Super.
let magicZone=null;
function updateMagicZone(now){
  if(!magicZone) return;
  if(now >= magicZone.endsAt){ magicZone = null; return; }

  // Expand slowly over the full duration
  const t = Math.max(0, Math.min(1, (now - magicZone.startsAt) / magicZone.durationMs));
  magicZone.radius = magicZone.startRadius + (magicZone.maxRadius - magicZone.startRadius) * t;

  // Periodic damage to enemies inside
  if(!magicZone.lastTick) magicZone.lastTick = now;
  if(now - magicZone.lastTick >= magicZone.tickMs){
    magicZone.lastTick = now;
    for(let i=enemies.length-1;i>=0;i--){
      const e=enemies[i];
      const ex=e.x+e.width/2, ey=e.y+e.height/2;
      const d=Math.hypot(ex-magicZone.x, ey-magicZone.y);
      if(d <= magicZone.radius){
        const dmg=Math.round(magicZone.damagePerTick);
        const _dmg=dmg; const _final=applyEnemyDamage(e,_dmg);
        showDamageNumber(e.x,e.y,_final);
        // colorful hit FX
        createParticles(ex,ey, magicZone.colors[(magicZone.colorIdx++)%magicZone.colors.length], 10, 4);
        if(e.hp<=0){
          createParticles(e.x,e.y,'#fff176',30,6);
          dropStellarBonusAtIndexIfNeeded(i);
          enemies.splice(i,1);
          applyScore(100*currentLevel);
        addKill(); }
      }
    }

    // ambient zone particles (center swirl)
    createParticles(magicZone.x, magicZone.y, magicZone.colors[(magicZone.colorIdx++)%magicZone.colors.length], 18, 4);
  }
}

function drawMagicZone(now){
  if(!magicZone) return;
  const t = Math.max(0, Math.min(1, (now - magicZone.startsAt) / magicZone.durationMs));
  const pulse = 0.5 + 0.5*Math.sin(now/240);

  ctx.save();
  ctx.globalAlpha = 0.18 + 0.18*(1-t);
  const grad = ctx.createRadialGradient(magicZone.x, magicZone.y, 10, magicZone.x, magicZone.y, magicZone.radius);
  grad.addColorStop(0, 'rgba(255,0,255,0.55)');
  grad.addColorStop(0.5, 'rgba(0,229,255,0.35)');
  grad.addColorStop(1, 'rgba(255,241,118,0.08)');
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.arc(magicZone.x, magicZone.y, magicZone.radius, 0, Math.PI*2);
  ctx.fill();

  // rings
  ctx.globalAlpha = 0.55;
  ctx.lineWidth = 6 + 6*pulse;
  ctx.strokeStyle = 'rgba(255,0,255,0.55)';
  ctx.beginPath(); ctx.arc(magicZone.x, magicZone.y, magicZone.radius*(0.35+0.05*pulse), 0, Math.PI*2); ctx.stroke();
  ctx.strokeStyle = 'rgba(0,229,255,0.55)';
  ctx.beginPath(); ctx.arc(magicZone.x, magicZone.y, magicZone.radius*(0.65+0.06*(1-pulse)), 0, Math.PI*2); ctx.stroke();
  ctx.strokeStyle = 'rgba(255,241,118,0.55)';
  ctx.beginPath(); ctx.arc(magicZone.x, magicZone.y, magicZone.radius, 0, Math.PI*2); ctx.stroke();

  ctx.restore();
}

function isPointInsideMagicZone(x,y){
  if(!magicZone) return false;
  const now=Date.now();
  if(now >= magicZone.endsAt) return false;
  return Math.hypot(x-magicZone.x, y-magicZone.y) <= magicZone.radius;
}


// --- PDOR SUPER: 7 luminous orbiting rings (slow + damage) ---
let pdorOrbs = null;
function startPdorOrbs(owner, now){
  const durationMs = 8000;
  const count = 7;

  pdorOrbs = {
    ownerType: owner && owner.type,
    startsAt: now,
    endsAt: now + durationMs,
    orbs: []
  };

  const margin = 70;
  for(let i=0;i<count;i++){
    const cx = margin + Math.random()*(canvas.width - margin*2);
    const cy = margin + Math.random()*((canvas.height-30) - margin*2);
    const orbitR = 26 + Math.random()*34;
    const ang0 = Math.random()*Math.PI*2;
    const angSpeed = (Math.random()<0.5?-1:1) * (0.036 + Math.random()*0.028); // rad/ms

    pdorOrbs.orbs.push({
      cx, cy,
      orbitR,
      ang: ang0,
      angSpeed,
      x: cx + Math.cos(ang0)*orbitR,
      y: cy + Math.sin(ang0)*orbitR,
      pulses: [],
      lastEmit: now - Math.random()*160,
      hitCd: new Map()
    });
  }

  // visual burst
  if(owner){
    createParticles(owner.x+owner.width/2, owner.y+owner.height/2, '#ffffff', 36, 6);
  }
}

function _applyEnemyTempSlow(enemy, factor, untilMs){
  const now = Date.now();
  const until = now + (untilMs||0);
  // store current speed once (so we restore properly even if the enemy was already slowed by other effects)
  if(enemy._pdorSlowUntil && now < enemy._pdorSlowUntil){
    // extend only
    enemy._pdorSlowUntil = Math.max(enemy._pdorSlowUntil, until);
    return;
  }
  enemy._pdorSpeedBefore = enemy.speed;
  enemy.speed = (enemy.speed||0) * (factor!=null?factor:0.5);
  enemy._pdorSlowUntil = until;
}

function updatePdorOrbs(now){
  if(!pdorOrbs) return;

  if(now >= pdorOrbs.endsAt){
    // restore any remaining pdor slow
    for(const e of enemies){
      if(e && e._pdorSlowUntil){
        if(typeof e._pdorSpeedBefore === 'number') e.speed = e._pdorSpeedBefore;
        e._pdorSpeedBefore = undefined;
        e._pdorSlowUntil = 0;
      }
    }
    pdorOrbs = null;
    return;
  }

  // restore expired slow effects
  for(const e of enemies){
    if(e && e._pdorSlowUntil && now >= e._pdorSlowUntil){
      if(typeof e._pdorSpeedBefore === 'number') e.speed = e._pdorSpeedBefore;
      e._pdorSpeedBefore = undefined;
      e._pdorSlowUntil = 0;
    }
  }

  const ringThickness = 7;      // "molto ristrette"
  const emitEvery = 180;        // ms
  const pulseSpeed = 0.24;      // px/ms
  const pulseMax = 56;          // px
  const pulseMin = 10;          // px
  const perTargetHitCd = 180;   // ms (per orb)

  for(const orb of pdorOrbs.orbs){
    orb.ang += orb.angSpeed;
    orb.x = orb.cx + Math.cos(orb.ang)*orb.orbitR;
    orb.y = orb.cy + Math.sin(orb.ang)*orb.orbitR;

    // emit pulses
    if(now - orb.lastEmit >= emitEvery){
      orb.lastEmit = now;
      orb.pulses.push({ r: pulseMin, born: now });
    }

    // advance pulses
    for(let p=orb.pulses.length-1;p>=0;p--){
      const pulse = orb.pulses[p];
      pulse.r += pulseSpeed * (now - (pulse._lastNow||now));
      pulse._lastNow = now;
      if(pulse.r > pulseMax){
        orb.pulses.splice(p,1);
        continue;
      }

      // collision with enemies on the ring band
      for(let i=enemies.length-1;i>=0;i--){
        const e=enemies[i];
        if(!e) continue;
        const ex=e.x+e.width/2, ey=e.y+e.height/2;
        const d=Math.hypot(ex-orb.x, ey-orb.y);
        if(Math.abs(d - pulse.r) <= ringThickness){
          const last = orb.hitCd.get(e) || 0;
          if(now - last < perTargetHitCd) continue;
          orb.hitCd.set(e, now);

          const dmg = 27;
          const _final = applyEnemyDamage(e, dmg);
          showDamageNumber(e.x, e.y, _final);
          createParticles(ex, ey, '#ffffff', 10, 4);

          _applyEnemyTempSlow(e, 0.5, 1000);

          if(e.hp<=0){
            createParticles(e.x,e.y,'#fff176',30,6);
            dropStellarBonusAtIndexIfNeeded(i);
            enemies.splice(i,1);
            applyScore(100*currentLevel);
          addKill(); }
        }
      }
    }

    // keep hit map small
    if(orb.hitCd.size>90){
      // prune old entries
      for(const [k,t] of orb.hitCd.entries()){
        if(!k || now-t>1500) orb.hitCd.delete(k);
      }
    }
  }
}

function drawPdorOrbs(now){
  if(!pdorOrbs) return;

  ctx.save();
  ctx.globalCompositeOperation='lighter';
  ctx.shadowColor = 'rgba(255,255,255,0.9)';
  ctx.shadowBlur = 25;


  for(const orb of pdorOrbs.orbs){
    // core glow
    const pulse = 0.55 + 0.45*Math.sin((now+orb.cx)/240);
    ctx.globalAlpha = 0.55 + 0.25*pulse;
    const grad = ctx.createRadialGradient(orb.x, orb.y, 0, orb.x, orb.y, 30);
    grad.addColorStop(0, 'rgba(255,255,255,1)');
    grad.addColorStop(0.4, 'rgba(255,255,255,0.8)');
    grad.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = grad;

    ctx.beginPath();
    ctx.arc(orb.x, orb.y, 7 + 2*pulse, 0, Math.PI*2);
    ctx.fill();

    // pulses (thin circles)
    for(const p of orb.pulses){
      const a = 0.40 + 0.25*Math.sin((now - p.born)/90);
      ctx.globalAlpha = a;
      ctx.lineWidth = 3;
      ctx.strokeStyle = 'rgba(255,255,255,0.95)';
      ctx.beginPath();
      ctx.arc(orb.x, orb.y, p.r, 0, Math.PI*2);
      ctx.stroke();
    }
  }

  ctx.restore();
}


let lasers=[];
let tempBeams=[]; // Tempostorm lasers (friendly beams)
let wolves=[]; // H√®cate Super: lupi amichevoli
let keys={};
let lastSecondTick=Date.now();
let levelAdvanceLock=false;
let shakeAmount=0;

const images={rooney:new Image(),jimmy:new Image(),jeff:new Image(),voltryx:new Image(),kouvagia:new Image(),salsy:new Image(),tempostorm:new Image() ,marz:new Image(),hecate:new Image(),pdor:new Image(),bane:new Image(),hendel:new Image(),kaerith:new Image()};
images.rooney.src='https://i.postimg.cc/Vs0G7ZPV/rooneyy.png';
images.jimmy.src='https://i.postimg.cc/13Qzjdn4/jimmyy.png';
images.jeff.src='https://i.postimg.cc/gkQN3v7R/jeff-(1).png';
images.voltryx.src='https://i.postimg.cc/GhjK4WCy/Voltryxx.png';
images.kouvagia.src='https://i.postimg.cc/gj1xjk0G/kouvagiaa-(1).png';
images.salsy.src='https://i.ibb.co/20zSkjsB/salsy.png';
images.tempostorm.src='https://i.postimg.cc/mkzj763m/tempostorm.png';
images.marz.src='https://i.postimg.cc/j5WJZL5X/marz.png';
images.hecate.src='https://i.postimg.cc/9QjRg424/hecate.png';
images.marcus=new Image(); images.marcus.src='https://i.postimg.cc/MpKjhyKD/image.png';
images.lucien=new Image(); images.lucien.src='https://i.postimg.cc/XvqZgdhz/Lucien-(1).png';
images.pdor=new Image(); images.pdor.src='https://i.postimg.cc/y8nHcqnw/pdor24.png';
images.bane=new Image(); images.bane.src='https://i.postimg.cc/Kjc7KMzX/bane.png';
images.hendel.src='https://i.postimg.cc/g2G7LYjr/hendel.png';
images.kaerith.src='https://i.postimg.cc/pLBZRcHy/Kaerith.png';
const wolfImg=new Image(); wolfImg.src='https://i.postimg.cc/4y9yBGFw/lupo.png';
const imagesEvo={jimmy:new Image(),rooney:new Image(),jeff:new Image()};
imagesEvo.jimmy.src='https://i.postimg.cc/g26ZX0n9/jimmyevo.png';
imagesEvo.rooney.src='https://i.postimg.cc/x8Ck0fWs/rooneyevo.png';
imagesEvo.jeff.src='https://i.postimg.cc/FsYf8KbV/jeffevo.png';
// --- Pickup images (keep pickup size small; same dimensions already used) ---
const pickupImgs={
  heal: new Image(),
  shield: new Image(),
  speed: new Image(),
  atk: new Image(),
  super: new Image(),
  gold: new Image(),
  stellar: new Image(),
  malus: new Image(),
};
pickupImgs.heal.src='https://i.postimg.cc/c4jNccLC/heal.png';
pickupImgs.shield.src='https://i.postimg.cc/9XnS3QHh/shield.png';
pickupImgs.speed.src='https://i.postimg.cc/DzCV8QHb/speed.png';
pickupImgs.atk.src='https://i.postimg.cc/cHjVcxsS/ATK.png';
pickupImgs.super.src='https://i.postimg.cc/3rss4xSD/Super.png';
pickupImgs.gold.src='https://i.postimg.cc/wjVZGc6h/gold.png';
pickupImgs.stellar.src='https://i.postimg.cc/7hhNdJpp/bossbonus.png';
pickupImgs.malus.src='https://i.postimg.cc/tT1cJKFm/malus.png';
pickupImgs.furia = new Image(); pickupImgs.furia.src='https://i.postimg.cc/BvCsTjYD/furia.png';
pickupImgs.ice = new Image(); pickupImgs.ice.src='https://i.postimg.cc/GmF1RB1k/ice.png';

function getPickupImage(type){
  // internal type names
  const key = (type==='shieldPickup') ? 'shield' : type;
  return pickupImgs[key] || null;
}
 
const enemyImages={
  slime:new Image(),drone:new Image(),boss1:new Image(),mech:new Image(),
  shadow:new Image(),boss2:new Image(),shooter:new Image(),attacker:new Image(),boss3:new Image(),
  veleno:new Image(),oneyes:new Image(),boss4:new Image(),boss5:new Image(),archer:new Image(),glacial:new Image()
};
enemyImages.slime.src='https://i.postimg.cc/NFVhJNLC/pixelcut-export-(2).png';
enemyImages.drone.src='https://i.postimg.cc/13x9HtxZ/image-(1).png';
enemyImages.boss1.src='https://i.postimg.cc/B6bmxMJt/boss1-(1).png';
enemyImages.mech.src='https://i.postimg.cc/qqkys7cT/mech-(1).png';
enemyImages.shadow.src='https://i.postimg.cc/tgWx86Dv/shadow-(1).png';
enemyImages.boss2.src='https://i.postimg.cc/Bvpq8QnR/boss2-(1).png';
enemyImages.shooter.src='https://i.postimg.cc/yNxVZC3D/shooter-(1).png';
enemyImages.attacker.src='https://i.postimg.cc/sxVHMs1H/attacker.png';
enemyImages.boss3.src='https://i.postimg.cc/xjzKWcTs/boss3-(1).png';


enemyImages.veleno.src='https://i.postimg.cc/3xNWGRWY/veleno.png';
enemyImages.oneyes.src='https://i.postimg.cc/g2xkJTBG/oneyes.png';
enemyImages.boss4.src='https://i.postimg.cc/Px6d8kgr/boss4.png';
enemyImages.boss5.src='https://i.postimg.cc/wvGJm86S/boss5.png';
enemyImages.archer.src='https://i.postimg.cc/VLSg4gpV/archer.png';
enemyImages.glacial.src='https://i.postimg.cc/W1LG8vMN/glacial.png';

// ===== Bestiario (Nemici & Boss) - sblocco globale (tutti i personaggi) =====
const ENEMY_SEEN_KEY='jeffsChronicles_enemySeen_v1';
function loadEnemySeen(){
  try{
    const raw=localStorage.getItem(ENEMY_SEEN_KEY);
    return raw ? JSON.parse(raw) : {};
  }catch(e){ return {}; }
}
function saveEnemySeen(map){
  try{ localStorage.setItem(ENEMY_SEEN_KEY, JSON.stringify(map||{})); }catch(e){}
}
let enemySeen = loadEnemySeen();
function markEnemySeen(type){
  if(!type) return;
  if(!enemySeen[type]){
    enemySeen[type]=true;
    saveEnemySeen(enemySeen);
  }
}

// Dati descrittivi (nome + descrizione + chiave immagine)
const enemyGuideData={
  slime:{ name:'SLIME', imgKey:'slime', desc:'Creatura base gelatinosa. Lenta, prevedibile, pensata per mettere pressione numerica pi√π che tecnica. Insegue costantemente il giocatore e infligge danno da contatto.  HP: 45‚Äì50 ‚≠ê‚≠ê‚òÜ‚òÜ‚òÜ Danno: 9‚Äì10 ‚≠ê‚≠ê‚òÜ‚òÜ‚òÜ Velocit√†:   ‚≠ê‚≠ê‚òÜ‚òÜ‚òÜ'},
  drone:{ name:'DRONE', imgKey:'drone', desc:'Unit√† volante veloce e nervosa, progettata per punire chi resta fermo.  Movimento rapido e irregolare, attacco da contatto. HP: ~40 ‚≠ê‚≠ê‚òÜ‚òÜ‚òÜ Danno: 11‚Äì12 ‚≠ê‚≠ê‚≠ê‚òÜ‚òÜ Velocit√†: ‚≠ê‚≠ê‚≠ê‚≠ê‚òÜ'},
  mech:{ name:'MECH', imgKey:'mech', desc:'Nemico corazzato e resistente, fa da ‚Äútank‚Äù nelle ondate.  Avanza lentamente verso il giocatore e colpisce a contatto. HP: 60‚Äì65 ‚≠ê‚≠ê‚≠ê‚≠ê‚òÜ Danno:  16-17 ‚≠ê‚≠ê‚≠ê‚òÜ‚òÜ Velocit√†: ‚≠ê‚≠ê‚òÜ‚òÜ‚òÜ'},
  shadow:{ name:'SHADOW', imgKey:'shadow', desc:'Entit√† oscura estremamente aggressiva, specializzata nel combattimento ravvicinato. Insegue molto velocemente, attacco immediato a contatto. HP: 50‚Äì52 ‚≠ê‚≠ê‚≠ê‚òÜ‚òÜ Danno: 17‚Äì18 ‚≠ê‚≠ê‚≠ê‚≠ê‚òÜ Velocit√†: ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê'},
  shooter:{ name:'SHOOTER', imgKey:'shooter', desc:'Attaccante a distanza che costringe il giocatore a schivare costantemente. Spara proiettili dalla distanza mantenendo posizione.  HP: 45 ‚≠ê‚≠ê‚òÜ‚òÜ‚òÜ Danno: 20‚Äì21 ‚≠ê‚≠ê‚≠ê‚≠ê‚òÜ Velocit√†: ‚≠ê‚≠ê‚≠ê‚òÜ‚òÜ'},
  attacker:{ name:'ATTACKER', imgKey:'attacker', desc:'Assalitore aggressivo con pattern ‚Äúhit & run‚Äù. Carica, colpisce e si allontana rapidamente. HP: 90‚Äì99 ‚≠ê‚≠ê‚≠ê‚≠ê‚òÜ Danno: 17‚Äì19 ‚≠ê‚≠ê‚≠ê‚òÜ‚òÜ Velocit√†: ‚≠ê‚≠ê‚≠ê‚≠ê‚òÜ'},
  archer:{ name:'ARCHER', imgKey:'archer', desc:'Tiratore preciso che punisce il posizionamento sbagliato. Spara frecce a distanza, ricarica tra un colpo e l‚Äôaltro. HP: 78‚Äì86 ‚≠ê‚≠ê‚≠ê‚òÜ‚òÜ Danno: 14‚Äì15 ‚≠ê‚≠ê‚≠ê‚òÜ‚òÜ Velocit√†: ‚≠ê‚≠ê‚≠ê‚òÜ‚òÜ'},
  glacial:{ name:'GLACIAL', imgKey:'glacial', desc:'Nemico pesante del bioma ghiaccio, domina il controllo dell‚Äôarena. Movimento lento ma pressante, danno da contatto. HP: 150‚Äì165 ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Danno: 22‚Äì24 ‚≠ê‚≠ê‚≠ê‚≠ê‚òÜ Velocit√†: ‚≠ê‚≠ê‚òÜ‚òÜ‚òÜ'},
  veleno:{ name:'VELENO', imgKey:'veleno', desc:'Creatura tossica estremamente pericolosa se ignorata. Attacco a contatto che applica Poison. HP: 60‚Äì70 ‚≠ê‚≠ê‚≠ê‚òÜ‚òÜ Danno: 13‚Äì15 ‚≠ê‚≠ê‚≠ê‚òÜ‚òÜ Velocit√†: ‚≠ê‚≠ê‚≠ê‚òÜ‚òÜ Abilit√† passive: ‚ò†Ô∏è Poison ‚Äì danni nel tempo'},
  oneyes:{ name:'ONE-EYE', imgKey:'oneyes', desc:'Entit√† strategica che mantiene distanza e punisce inseguimenti sbagliati. Avanza a scatti, attacca quando il giocatore si espone con attacchi a laser precisi e letali con danni continui se si rimane dentro il raggio del laser. HP: 55‚Äì60 ‚≠ê‚≠ê‚≠ê‚òÜ‚òÜ Danno: 8‚Äì9 ‚≠ê‚≠ê‚òÜ‚òÜ‚òÜ Velocit√†: ‚≠ê‚≠ê‚òÜ‚òÜ‚òÜ'},
  boss1:{ name:'BOSS I', imgKey:'boss1', desc:'HP: 150 ‚≠ê‚≠ê‚≠ê‚òÜ‚òÜ Danno: 20 ‚≠ê‚≠ê‚≠ê‚òÜ‚òÜ Velocit√†: ‚≠ê‚≠ê‚òÜ‚òÜ‚òÜ Passiva: ‚ùå | Boss introduttivo, pressione costante.'},
  boss2:{ name:'BOSS II', imgKey:'boss2', desc:'HP: 300 ‚≠ê‚≠ê‚≠ê‚≠ê‚òÜ Danno: 27 ‚≠ê‚≠ê‚≠ê‚≠ê‚òÜ Velocit√†: ‚≠ê‚≠ê‚≠ê‚òÜ‚òÜ Passiva: ‚ùå | Molto pi√π aggressivo, richiede gestione super.'},
  boss3:{ name:'BOSS III', imgKey:'boss3', desc:'HP: 666 ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Danno:  33 ‚≠ê‚≠ê‚≠ê‚≠ê‚òÜ Velocit√†: ‚≠ê‚≠ê‚òÜ‚òÜ‚òÜ Passiva: ‚ùå | Spartiacque del gioco, alta difficolt√† tecnica.'},
  boss4:{ name:'BOSS IV', imgKey:'boss4', desc:'HP: 999 ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Danno: 35 ‚≠ê‚≠ê‚≠ê‚≠ê‚òÜ Velocit√†: ‚≠ê‚≠ê‚òÜ‚òÜ‚òÜ Passiva: üß† Attacchi telegraphed Premia lettura e tempismo.'},
  boss5:{ name:'BOSS V', imgKey:'boss5', desc:'HP: 800 ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Danno: 32 ‚≠ê‚≠ê‚≠ê‚≠ê‚òÜ Velocit√†: ‚≠ê‚≠ê‚òÜ‚òÜ‚òÜ Abilit√† passive: ‚ôªÔ∏è Rigenerazione HP ogni 28s üåä Onda di respinta üßä Rallentamento 50% per 2s se nel raggio'}
};

// Ordine consigliato nella lista
const enemyGuideOrder=['slime','drone','mech','shadow','shooter','attacker','veleno','oneyes','archer','glacial','boss1','boss2','boss3','boss4','boss5'];

function buildEnemyGuideUI(){
  const listEl=document.getElementById('enemyGuideList');
  const detailEl=document.getElementById('enemyGuideDetail');
  if(!listEl || !detailEl) return;

  listEl.innerHTML='';
  const unlocked = enemyGuideOrder.filter(k=>enemySeen && enemySeen[k] && enemyGuideData[k]);

  // empty state
  if(unlocked.length===0){
    // keep existing empty panel text
    detailEl.innerHTML = `<div class="enemy-guide-empty">
      <h3 style="margin:0 0 8px 0;color:#f39c12;">Nessun nemico sbloccato</h3>
      <p style="margin:0;color:#ddd;">Affronta un nemico o un boss almeno una volta per sbloccarlo qui.</p>
    </div>`;
    return;
  }

  function selectKey(key){
    const data=enemyGuideData[key];
    if(!data) return;

    // active state
    listEl.querySelectorAll('button').forEach(b=>b.classList.toggle('active', b.dataset.key===key));

    const img = enemyImages[data.imgKey];
    const src = (img && img.src) ? img.src : '';
    detailEl.innerHTML = `
      <div class="enemy-guide-detail-inner">
        <img src="${src}" alt="${data.name}">
        <div>
          <h3>${data.name}</h3>
          <p>${data.desc}</p>
        </div>
      </div>
    `;
  }

  for(const key of unlocked){
    const data=enemyGuideData[key];
    const btn=document.createElement('button');
    btn.type='button';
    btn.dataset.key=key;

    const img = enemyImages[data.imgKey];
    const src = (img && img.src) ? img.src : '';

    btn.innerHTML = `<img class="enemy-mini" src="${src}" alt="${data.name}"><span>${data.name}</span>`;
    btn.addEventListener('click', ()=>selectKey(key));
    listEl.appendChild(btn);
  }

  // default selection: first unlocked
  selectKey(unlocked[0]);
}

const characterStats={
  jimmy:{
    hp:350,
    speed:8*0.75,
    damage:47,
    range:600,
    cooldown:800,
    name:'Jimmy',
    attackType:'grapple',
    superCooldown:7000,
    superDuration:3000
  },
  rooney:{
    hp:450,
    speed:6*0.75,
    damage:Math.round(80*DAMAGE_MULT),
    range:150,
    cooldown:520,
    name:'Rooney',
    attackType:'punch',
    superCooldown:13000,
    superDuration:750
  },
  jeff:{
    hp:400, 
    speed:7.5*0.75,
    damage:Math.round(57*DAMAGE_MULT), // 38
    range:Math.round(320*JEFF_ATTACK_RANGE_MULT),
    cooldown:700,
    name:'Jeff',
    attackType:'sword',
    superCooldown:11000,
    superDuration:2800
  },
  voltryx:{
    hp:425, 
    speed:9*0.75,               
    damage:Math.round(55*DAMAGE_MULT),
    range:Math.round(600), 
    cooldown:650,
    name:'Voltryx',
    attackType:'hybrid',
    superCooldown:9000,
    superDuration:1500 
  },
  kouvagia:{
    hp:430,
    speed:7*0.75,
    damage:55,
    range:220,
    cooldown:760,
    name:'Kouvagia',
    attackType:'kouvagia',
    superCooldown:25000,
    superDuration:600
  },
  salsy:{
    hp:410,
    speed:8*0.75,  // leggermente pi√π veloce di prima
    damage:33,       // per colpo (x2)
    range:330,       // medio ravvicinata
    cooldown:750,
    name:'Salsy',
    attackType:'salsySword',
    superCooldown:6000,
    superDuration:400
  },
  tempostorm:{
  hp:440,
  speed:6.1*0.75, // leggermente piu di Rooney
  damage:40,      // hit iniziale (extra +30 se il nemico resta nel fascio)
  range:400,
  cooldown:850,
  name:'Tempostorm',
  attackType:'tempostormLaser',
  superCooldown:50000,
  superDuration:500
},
  marz:{
    hp:360,
    speed:6.5*0.75,
    damage:40,
    tripleDamage:[40,50,60],
    range:480,
    cooldown:820,
    name:'Marz',
    attackType:'magic',
    superCooldown:20000,
    superDuration:2200
  }

  ,
  marcus:{
    hp:400,
    speed:7,
    damage:20,
    range:650,
    cooldown:900,
    name:'Marcus',
    attackType:'marcusStream',
    superCooldown:27000,
    superDuration:10000
  },
  lucien:{
    hp:380,
    speed:8.2*0.75, // leggermente sopra la media
    damage:15,      // per colpo (x4)
    range:220,      // molto ravvicinato
    cooldown:700,
    name:'Lucien',
    attackType:'lucienBlade',
    superCooldown:21000,
    superDuration:450
  },

  pdor:{
    hp:420,
    speed:7.4*0.75,
    damage:50,
    range:820,
    cooldown:180,
    name:'Pdor',
    attackType:'pdorDart',
    superCooldown:16000,
    superDuration:1000
  },


  bane:{
    hp:440,
    speed:6.3*0.75, // leggermente pi√π veloce di Tempostorm, ma sempre media-bassa
    damage:75,
    range:230,      // raggio medio-basso
    cooldown:650,   // swing ascia
    name:'Bane',
    attackType:'axeattack',
    superCooldown:60000,
    superDuration:10000
  },

  hendel:{
    hp:430,
    speed:6.0*0.75, // la pi√π bassa (o tra le pi√π basse) del gioco
    damage:120,
    range:160,
    cooldown:1100, // attacco base molto lento
    name:'Hendel',
    attackType:'hammerattack',
    superCooldown:30000,
    superDuration:3000
  },

  kaerith:{
    hp:410,
    speed:8.3*0.75,
    damage:0,
    range:300,
    cooldown:1000, // fiammata continua
    name:'Kaerith üêâ',
    attackType:'kaerithFlame',
    superCooldown:21000,
    superDuration:6000
  },

  hecate:{
    hp:375,
    speed:9*0.75,
    damage:52,
    range:990,
    cooldown:900,
    name:'H√®cate',
    attackType:'hecateBow',
    superCooldown:22000,
    superDuration:700
  }
};

const levelConfigs=[
  {enemyType:'slime',enemyHP:45,enemyDamage:9,enemySpeed:2*0.75,time:45,enemyCount:4},
  {enemyType:'slime',enemyHP:50,enemyDamage:10,enemySpeed:2*0.75,time:45,enemyCount:9 },
  {enemyType:'drone',enemyHP:40,enemyDamage:11,enemySpeed:3*0.75,time:40,enemyCount:6},
  {enemyType:'drone',enemyHP:40,enemyDamage:12,enemySpeed:3*0.75,time:40,enemyCount:7},
  {enemyType:'boss1',enemyHP:150,enemyDamage:20,enemySpeed:2.8*0.75,time:60,enemyCount:1},
  {enemyType:'mech',enemyHP:60,enemyDamage:16,enemySpeed:2.5*0.75,time:35,enemyCount:7},
  {enemyType:'shadow',enemyHP:50,enemyDamage:17,enemySpeed:4*0.75,time:30,enemyCount:6},
  {enemyType:'shadow',enemyHP:52,enemyDamage:18,enemySpeed:4 *0.75,time:30,enemyCount:6},
  {enemyType:'mech',enemyHP:65,enemyDamage:16,enemySpeed:2.5*0.75,time:35,enemyCount:8},
  {enemyType:'boss2',enemyHP:300,enemyDamage:27,enemySpeed:3*0.75,time:60,enemyCount:1},
  {enemyType:'shooter',enemyHP:45,enemyDamage:20,enemySpeed:2.5*0.75,time:45,enemyCount:5},
  {enemyType:'shooter',enemyHP:45,enemyDamage:21,enemySpeed:2.7*0.75,time:45,enemyCount:7},
  {enemyType:'attacker',enemyHP:90,enemyDamage:17,enemySpeed:3.2*0.75,time:50,enemyCount:5},
  {enemyType:'attacker',enemyHP:99,enemyDamage:19,enemySpeed:3.4*0.75,time:60,enemyCount:6},
  {enemyType:'boss3',enemyHP:666,enemyDamage:33,enemySpeed:2.4*0.75,time:100,enemyCount:1}
  ,{enemyType:'veleno',enemyHP:60,enemyDamage:13,enemySpeed:3.1*0.75,time:50,enemyCount:7} // Level 16
  ,{enemyType:'veleno',enemyHP:70,enemyDamage:15,enemySpeed:3.3*0.75,time:50,enemyCount:9} // Level 17
  ,{enemyType:'oneyes',enemyHP:55,enemyDamage:8,enemySpeed:2.1*0.75,time:55,enemyCount:4} // Level 18
  ,{enemyType:'oneyes',enemyHP:60,enemyDamage:9,enemySpeed:2.3*0.75,time:55,enemyCount:5} // Level 19
  ,{enemyType:'boss4',enemyHP:999,enemyDamage:35,enemySpeed:2.2*0.75,time:180,enemyCount:1} // Level 20
  ,{enemyType:'archer',enemyHP:78,enemyDamage:14,enemySpeed:2.6*0.75,time:65,enemyCount:4} // Level 21 (Ice)
  ,{enemyType:'archer',enemyHP:86,enemyDamage:15,enemySpeed:2.8*0.75,time:65,enemyCount:5} // Level 22 (Ice)
  ,{enemyType:'glacial',enemyHP:150,enemyDamage:22,enemySpeed:2.3*0.75,time:70,enemyCount:2} // Level 23 (Ice)
  ,{enemyType:'glacial',enemyHP:165,enemyDamage:24,enemySpeed:2.4*0.75,time:80,enemyCount:3} // Level 24 (Ice)

  ,{enemyType:'boss5',enemyHP:800,enemyDamage:32,enemySpeed:2.2*0.75,time:200,enemyCount:1} // Level 25 (Boss V)
];

const RECORDS_KEY='pf_records_v19';

/* === Account Level System (v1) === */
const ACCOUNT_KEY = "pf_account_v1";

function defaultAccount(){
  return {
    level: 1,
    xp: 0,
    kills: { jimmy:0, rooney:0, jeff:0 },
    claimed: { m_jimmy:false, m_rooney:false, m_jeff:false }
  };
}

let account = null;

function loadAccount(){
  try{
    const raw = localStorage.getItem(ACCOUNT_KEY);
    if(!raw){ account = defaultAccount(); return; }
    const obj = JSON.parse(raw);
    account = Object.assign(defaultAccount(), obj||{});
    account.kills = Object.assign(defaultAccount().kills, account.kills||{});
    account.claimed = Object.assign(defaultAccount().claimed, account.claimed||{});
  }catch(e){
    account = defaultAccount();
  }
}

function saveAccount(){
  try{ localStorage.setItem(ACCOUNT_KEY, JSON.stringify(account||defaultAccount())); }catch(e){}
}

function xpNeededForLevel(lv){
  return 1000 + (Math.max(1,lv)-1)*250;
}

function addAccountXp(amount){
  if(!account) loadAccount();
  account.xp = Math.max(0, (account.xp||0) + Math.max(0, amount||0));
  while(account.xp >= xpNeededForLevel(account.level)){
    account.xp -= xpNeededForLevel(account.level);
    account.level += 1;
  }
  saveAccount();
  updateAccountUI();
}

function addAccountKill(charKey, n=1){
  if(!account) loadAccount();
  if(!charKey) return;
  if(!account.kills) account.kills = {};
  if(typeof account.kills[charKey] !== 'number') account.kills[charKey] = 0;
  account.kills[charKey] += Math.max(0, n||1);
  saveAccount();
  try{ const modal=document.getElementById('accountModal'); if(modal && modal.style.display==='flex'){ updateAccountUI(); } }catch(e){}
}

function getMissions(){
  return [
    { id:'m_jimmy', label:"Fai 1000 kill con Jimmy", char:'jimmy', goal:1000, xp:350 },
    { id:'m_rooney', label:"Fai 1000 kill con Rooney", char:'rooney', goal:1000, xp:350 },
    { id:'m_jeff', label:"Fai 1000 kill con Jeff", char:'jeff', goal:1000, xp:350 },
  ];
}

function updateAccountUI(){
  if(!account) loadAccount();
  const btn = document.getElementById('accountLevelBtn');
  const lvEl = document.getElementById('accountLevelValue');
  const xpText = document.getElementById('accountXpText');

  const level = account.level||1;
  const need = xpNeededForLevel(level);
  const xp = account.xp||0;

  if(lvEl) lvEl.textContent = String(level);
  if(xpText) xpText.textContent = `${xp}/${need} XP`;

  const shouldShow = (startScreen && startScreen.style.display!=='none') || (mainMenuScreen && mainMenuScreen.style.display!=='none');
  if(btn) btn.style.display = shouldShow ? 'block' : 'none';

  const lh=document.getElementById('accLevelHeader');
  const xh=document.getElementById('accXpHeader');
  const bar=document.getElementById('accXpBar');
  if(lh) lh.textContent=String(level);
  if(xh) xh.textContent = `${xp}/${need} XP`;
  if(bar){
    const pct = Math.max(0, Math.min(1, need? (xp/need) : 0));
    bar.style.width = `${Math.round(pct*100)}%`;
  }

  const list=document.getElementById('missionsList');
  if(list){
    const missions=getMissions();
    list.innerHTML='';
    for(const m of missions){
      const k = (account.kills && typeof account.kills[m.char]==='number') ? account.kills[m.char] : 0;
      const done = k >= m.goal;
      const claimed = !!(account.claimed && account.claimed[m.id]);
      const wrap=document.createElement('div');
      wrap.className='mission';

      const left=document.createElement('div');
      left.className='meta';
      left.innerHTML = `<div><strong>${m.label}</strong> <span style="opacity:0.75;">(+${m.xp} XP)</span></div>
                        <div class="prog">${Math.min(k,m.goal)}/${m.goal} kill</div>`;

      const btn=document.createElement('button');
      btn.className='claimBtn';
      btn.textContent = claimed ? 'Riscattato' : 'Riscatta';
      if(done && !claimed){
        btn.classList.add('ready');
        btn.disabled=false;
      }else{
        btn.disabled=true;
      }
      if(claimed){
        btn.style.opacity='0.65';
        btn.style.cursor='default';
        btn.style.background='rgba(46,204,113,0.18)';
        btn.style.borderColor='rgba(46,204,113,0.35)';
      }

      btn.addEventListener('click', ()=>{
        if(!account) loadAccount();
        const kk = (account.kills && typeof account.kills[m.char]==='number') ? account.kills[m.char] : 0;
        if(kk < m.goal) return;
        if(account.claimed && account.claimed[m.id]) return;
        account.claimed[m.id]=true;
        saveAccount();
        addAccountXp(m.xp);
        updateAccountUI();
      });

      wrap.appendChild(left);
      wrap.appendChild(btn);
      list.appendChild(wrap);
    }
  }
}

function openAccountModal(){
  const modal=document.getElementById('accountModal');
  if(modal){
    modal.style.display='flex';
    updateAccountUI();
  }
}
function closeAccountModal(){
  const modal=document.getElementById('accountModal');
  if(modal) modal.style.display='none';
}

document.addEventListener('DOMContentLoaded', ()=>{
  loadAccount();
  const btn=document.getElementById('accountLevelBtn');
  const close=document.getElementById('closeAccountModal');
  const modal=document.getElementById('accountModal');

  if(btn) btn.addEventListener('click', openAccountModal);
  if(close) close.addEventListener('click', closeAccountModal);
  if(modal) modal.addEventListener('click', (e)=>{ if(e.target===modal) closeAccountModal(); });

  updateAccountUI();
});
 
// Backward compatibility: try older keys used by previous versions
const LEGACY_RECORDS_KEYS = ['pf_records_v18','pf_records_v17','pf_records_v16','pf_records_v15','pf_records'];
// bumped key to include tempostormnclude salsy + new unlock rules // bumped key to include voltryx
let records=loadRecords();
// === SANITIZZAZIONE RECORD (fix bug Marz -> H√®cate) ===
(function sanitizeRecords(){
  if(!records) return;
  // Se H√®cate ha un record ma non √® ancora realmente sbloccata,
  // e Marz ha 0, spostiamo il record su Marz.
  const hecateUnlocked = allPrevAboveHecate85k();
  if(!hecateUnlocked && records.hecate > 0 && records.marz === 0){
    records.marz = records.hecate;
    records.hecate = 0;
    try{
      localStorage.setItem(RECORDS_KEY, JSON.stringify(records));
      console.warn('[SANITIZE] Record spostato da H√®cate a Marz');
    }catch(e){}
  }
})();


function loadRecords(){
  const base={jimmy:0,rooney:0,jeff:0,voltryx:0,kouvagia:0,salsy:0,tempostorm:0,marz:0,hecate:0,marcus:0,lucien:0,pdor:0,bane:0,hendel:0,kaerith:0};
  try{
    // Primary key (current version)
    const r=localStorage.getItem(RECORDS_KEY);
    if(r){
      const obj=JSON.parse(r);
      return Object.assign({}, base, obj);
    }
    // Migration: older versions may have used a different key
    for(const k of (typeof LEGACY_RECORDS_KEYS!=='undefined'?LEGACY_RECORDS_KEYS:[])){
      const old=localStorage.getItem(k);
      if(old){
        const obj=JSON.parse(old);
        const merged=Object.assign({}, base, obj);
        // persist into the current key so future loads are stable
        try{localStorage.setItem(RECORDS_KEY, JSON.stringify(merged));}catch(e){}
        return merged;
      }
    }
  }catch(e){}
  return base;
}
function saveRecords(){
  try{localStorage.setItem(RECORDS_KEY,JSON.stringify(records))}catch(e){}
}
function updateMenuRecordsDisplay(){
  document.getElementById('record-jimmy').textContent=`Record: ${records.jimmy||0}`;
  document.getElementById('record-rooney').textContent=`Record: ${records.rooney||0}`;
  document.getElementById('record-jeff').textContent=`Record: ${records.jeff||0}`;
  document.getElementById('record-voltryx').textContent=`Record: ${records.voltryx||0}`;
  document.getElementById('record-kouvagia').textContent=`Record: ${records.kouvagia||0}`;
  document.getElementById('record-salsy').textContent=`Record: ${records.salsy||0}`;
  document.getElementById('record-tempostorm').textContent=`Record: ${records.tempostorm||0}`;
  document.getElementById('record-marz').textContent=`Record: ${records.marz||0}`;
  document.getElementById('record-hecate').textContent=`Record: ${records.hecate||0}`;
  document.getElementById('record-marcus').textContent=`Record: ${records.marcus||0}`;
  document.getElementById('record-lucien').textContent=`Record: ${records.lucien||0}`;
  document.getElementById('record-pdor').textContent=`Record: ${records.pdor||0}`;
  document.getElementById('record-bane').textContent=`Record: ${records.bane||0}`;
  const rh=document.getElementById('record-hendel'); if(rh) rh.textContent=`Record: ${records.hendel||0}`;
  const rk=document.getElementById('record-kaerith'); if(rk) rk.textContent=`Record: ${records.kaerith||0}`;
  const brk=document.getElementById('btnrec-kaerith'); if(brk) brk.textContent=`R: ${records.kaerith||0}`;
  updateVoltryxUnlockUI();
  updateKouvagiaUnlockUI();
  updateSalsyUnlockUI();
  updateTempostormUnlockUI();
  updateMarzUnlockUI();
  updateHecateUnlockUI();
  updateLucienUnlockUI();
  updatePdorUnlockUI();
  updateBaneUnlockUI();
  updateHendelUnlockUI();
  updateKaerithUnlockUI();
  updateGuideUnlockUI();
}
function allThreeAbove50k(){
  return (records.jimmy||0)>45000 && (records.rooney||0)>45000 && (records.jeff||0)>45000;
}

function setLockBadgeState(badge, isLocked){
  if(!badge) return;
  if(isLocked){
    badge.style.display = 'block';
    badge.textContent = 'LOCKED';
    badge.style.color = '#f39c12';
    badge.style.borderColor = '#f39c12';
  } else {
    // When unlocked we want the card to look "normal": no extra UNLOCKED label.
    badge.style.display = 'none';
  }
}

function updateVoltryxUnlockUI(){
  const card=document.getElementById('card-voltryx');
  const badge=document.getElementById('voltryxLockBadge');
  if(!card||!badge) return;

  const unlocked = allThreeAbove50k();
  if(unlocked){
    card.classList.remove('disabled');
    setLockBadgeState(badge, false);
    card.title='Voltryx sbloccata!';
  }else{
    card.classList.add('disabled');
    setLockBadgeState(badge, true);
    card.title='Sblocca completando 50.000 punti con Jimmy, Rooney e Jeff';
  }
}



function voltryxAbove51k(){
  return (records.voltryx||0) >= 50000;
}

function updateKouvagiaUnlockUI(){
  const card=document.getElementById('card-kouvagia');
  const badge=document.getElementById('kouvagiaLockBadge');
  if(!card||!badge) return;

  const unlocked = voltryxAbove51k();
  if(unlocked){
    card.classList.remove('disabled');
    setLockBadgeState(badge, false);
    card.title='Kouvagia sbloccato!';
  }else{
    card.classList.add('disabled');
    setLockBadgeState(badge, true);
    card.title='Sblocca facendo 50.000 punti con Voltryx';
  }
}


function allPrevAbove70k(){
  return (records.jimmy||0)>=60000 && (records.rooney||0)>=60000 && (records.jeff||0)>=60000 && (records.voltryx||0)>=60000 && (records.kouvagia||0)>=60000;
}
function updateSalsyUnlockUI(){
  const card=document.getElementById('card-salsy');
  const badge=document.getElementById('salsyLockBadge');
  if(!card||!badge) return;

  const unlocked = allPrevAbove70k();
  if(unlocked){
    card.classList.remove('disabled');
    setLockBadgeState(badge, false);
    card.title='Salsy sbloccata!';
  }else{
    card.classList.add('disabled');
    setLockBadgeState(badge, true);
    card.title='Sblocca facendo 60.000 punti con Jimmy, Rooney, Jeff, Voltryx e Kouvagia';
  }
}



function allPrevAbove85k(){
  return (records.jimmy||0) >= 65000 &&
         (records.rooney||0) >= 65000 &&
         (records.jeff||0) >= 65000 &&
         (records.voltryx||0) >= 65000 &&
         (records.kouvagia||0) >= 65000 &&
         (records.salsy||0) >= 65000;
}
function updateTempostormUnlockUI(){
  const card=document.getElementById('card-tempostorm');
  const badge=document.getElementById('tempostormLockBadge');
  if(!card||!badge) return;

  const unlocked = allPrevAbove85k();
  if(unlocked){
    card.classList.remove('disabled');
    card.classList.remove('coming-soon');
    setLockBadgeState(badge, false);
    card.title='Tempostorm sbloccato!';
  }else{
    card.classList.add('disabled');
    setLockBadgeState(badge, true);
    card.title='Sblocca facendo 65.000 punti con tutti i personaggi precedenti (Jimmy, Rooney, Jeff, Voltryx, Kouvagia e Salsy)';
  }
}



function allPrevAboveMarz80k(){
  return (records.jimmy||0) >= 70000 &&
         (records.rooney||0) >= 70000 &&
         (records.jeff||0) >= 70000 &&
         (records.voltryx||0) >= 70000 &&
         (records.kouvagia||0) >= 70000 &&
         (records.salsy||0) >= 70000 &&
         (records.tempostorm||0) >= 70000 ;
}
function updateMarzUnlockUI(){
  const card=document.getElementById('card-marz');
  const badge=document.getElementById('marzLockBadge');
  if(!card||!badge) return;

  const unlocked = allPrevAboveMarz80k();
  if(unlocked){
    card.classList.remove('disabled');
    setLockBadgeState(badge, false);
    card.title='Marz sbloccato!';
  }else{
    card.classList.add('disabled');
    setLockBadgeState(badge, true);
    card.title='Sblocca facendo 70.000 punti con tutti i personaggi precedenti';
  }
}


function allPrevAboveHecate85k(){
  return (records.jimmy||0) >= 75000 &&
         (records.rooney||0) >= 75000 &&
         (records.jeff||0) >= 75000 &&
         (records.voltryx||0) >= 75000 &&
         (records.kouvagia||0) >= 75000 &&
         (records.salsy||0) >= 75000 &&
         (records.tempostorm||0) >= 75000 &&
         (records.marz||0) >= 75000;
}
function updateHecateUnlockUI(){
  const card=document.getElementById('card-hecate');
  const badge=document.getElementById('hecateLockBadge');
  if(!card||!badge) return;

  const unlocked = allPrevAboveHecate85k();
  if(unlocked){
    card.classList.remove('disabled');
    card.classList.remove('coming-soon');
    setLockBadgeState(badge, false);
    card.title='H√®cate sbloccata!';
  }else{
    card.classList.add('disabled');
    setLockBadgeState(badge, true);
    card.title='Sblocca facendo 75.000 punti con tutti i personaggi precedenti';
  }
}
function marcusUnlockedAny(){
  try{
    const vals = Object.values(records||{}).map(v=>parseInt(v)||0);
    return (vals.length? Math.max(...vals) : 0) >= 70000;
  }catch(e){
    return false;
  }
}
function lucienUnlocked(){
  return (records.marcus||0) > 25000;
}
function updateLucienUnlockUI(){
  const card=document.getElementById('card-lucien');
  const badge=document.getElementById('lucienLockBadge');
  if(!card||!badge) return;

  const unlocked = lucienUnlocked();
  if(unlocked){
    card.classList.remove('disabled');
    setLockBadgeState(badge, false);
    card.title='Lucien sbloccato!';
  }else{
    card.classList.add('disabled');
    setLockBadgeState(badge, true);
    card.title='Sblocca facendo un record con Marcus superiore a 25.000 punti';
  }
}

function pdorUnlocked(){
  return (records.marcus||0) >= 50000 && (records.lucien||0) >= 50000;
}
function updatePdorUnlockUI(){
  const card=document.getElementById('card-pdor');
  const badge=document.getElementById('pdorLockBadge');
  if(!card||!badge) return;

  const unlocked = pdorUnlocked();
  if(unlocked){
    card.classList.remove('disabled');
    setLockBadgeState(badge, false);
    card.title='Pdor sbloccato!';
  }else{
    card.classList.add('disabled');
    setLockBadgeState(badge, true);
    card.title='Sblocca facendo almeno 50.000 punti di record con Marcus e Lucien';
  }
}

function baneUnlocked(){
  return (records.pdor||0) >= 50000;
}

function hendelUnlocked(){
  return (records.bane||0) >= 50000;
}

function updateHendelUnlockUI(){
  const card=document.getElementById('card-hendel');
  const badge=document.getElementById('hendelLockBadge');
  if(!card||!badge) return;

  const unlocked = hendelUnlocked();
  if(unlocked){
    card.classList.remove('disabled');
    setLockBadgeState(badge, false);
    card.title='Hendel sbloccato!';
  }else{
    card.classList.add('disabled');
    setLockBadgeState(badge, true);
    card.title='Sblocca facendo 50.000 punti con Bane';
  }
}


function kaerithUnlocked(){
  return (records.hendel||0) >= 40000;
}

function updateKaerithUnlockUI(){
  const card=document.getElementById('card-kaerith');
  const badge=document.getElementById('kaerithLockBadge');
  if(!card||!badge) return;

  const unlocked = kaerithUnlocked();
  if(unlocked){
    card.classList.remove('disabled');
    setLockBadgeState(badge, false);
    card.title='Kaerith sbloccato!';
  }else{
    card.classList.add('disabled');
    setLockBadgeState(badge, true);
    card.title='Sblocca facendo 40.000 punti con Hendel';
  }
}

function updateBaneUnlockUI(){
  const card=document.getElementById('card-bane');
  const badge=document.getElementById('baneLockBadge');
  if(!card||!badge) return;

  const unlocked = baneUnlocked();
  if(unlocked){
    card.classList.remove('disabled');
    setLockBadgeState(badge, false);
    card.title='Bane sbloccato!';
  }else{
    card.classList.add('disabled');
    setLockBadgeState(badge, true);
    card.title='Sblocca facendo almeno 50.000 punti di record con PDOR';
  }
}

function updateGuideUnlockUI(){
  const vUnlocked = allThreeAbove50k();
  const kUnlocked = voltryxAbove51k();
  const sUnlocked = allPrevAbove70k();
  const tUnlocked = allPrevAbove85k();
  const mUnlocked = allPrevAboveMarz80k();
  const hUnlocked = allPrevAboveHecate85k();
  const marcUnlocked = marcusUnlockedAny();
  const lucUnlocked = lucienUnlocked();
  const pUnlocked = pdorUnlocked();
  const bUnlocked = baneUnlocked();
  const kaeUnlocked = kaerithUnlocked();

  const vBox=document.getElementById('guide-voltryx');
  const vLock=document.getElementById('guide-voltryx-locked');
  if(vBox&&vLock){ vBox.style.display = vUnlocked ? 'block' : 'none'; vLock.style.display = vUnlocked ? 'none' : 'block'; }

  const kBox=document.getElementById('guide-kouvagia');
  const kLock=document.getElementById('guide-kouvagia-locked');
  if(kBox&&kLock){ kBox.style.display = kUnlocked ? 'block' : 'none'; kLock.style.display = kUnlocked ? 'none' : 'block'; }

  const sBox=document.getElementById('guide-salsy');
  const sLock=document.getElementById('guide-salsy-locked');
  if(sBox&&sLock){ sBox.style.display = sUnlocked ? 'block' : 'none'; sLock.style.display = sUnlocked ? 'none' : 'block'; }

  const tBox=document.getElementById('guide-tempostorm');
  const tLock=document.getElementById('guide-tempostorm-locked');
  if(tBox&&tLock){ tBox.style.display = tUnlocked ? 'block' : 'none'; tLock.style.display = tUnlocked ? 'none' : 'block'; }

  const mBox=document.getElementById('guide-marz');
  const mLock=document.getElementById('guide-marz-locked');
  if(mBox&&mLock){ mBox.style.display = mUnlocked ? 'block' : 'none'; mLock.style.display = mUnlocked ? 'none' : 'block'; }

  const hBox=document.getElementById('guide-hecate');
  const hLock=document.getElementById('guide-hecate-locked');
  if(hBox&&hLock){ hBox.style.display = hUnlocked ? 'block' : 'none'; hLock.style.display = hUnlocked ? 'none' : 'block'; }

  const pBox=document.getElementById('guide-pdor');
  const pLock=document.getElementById('guide-pdor-locked');
  if(pBox&&pLock){ pBox.style.display = pUnlocked ? 'block' : 'none'; pLock.style.display = pUnlocked ? 'none' : 'block'; }

  const bBox=document.getElementById('guide-bane');
  const hendBox=document.getElementById('guide-hendel');
  const hendLock=document.getElementById('guide-hendel-locked');
  const bLock=document.getElementById('guide-bane-locked');
  if(bBox&&bLock){ bBox.style.display = bUnlocked ? 'block' : 'none'; bLock.style.display = bUnlocked ? 'none' : 'block'; }

  const hendUnlocked = hendelUnlocked();
  if(hendBox&&hendLock){ hendBox.style.display = hendUnlocked ? 'block' : 'none'; hendLock.style.display = hendUnlocked ? 'none' : 'block'; }

  const kaeBox=document.getElementById('guide-kaerith');
  const kaeLock=document.getElementById('guide-kaerith-locked');
  if(kaeBox&&kaeLock){ kaeBox.style.display = kaeUnlocked ? 'block' : 'none'; kaeLock.style.display = kaeUnlocked ? 'none' : 'block'; }


  const marcBox=document.getElementById('guide-marcus');
  const marcLock=document.getElementById('guide-marcus-locked');
  if(marcBox&&marcLock){ marcBox.style.display = marcUnlocked ? 'block' : 'none'; marcLock.style.display = marcUnlocked ? 'none' : 'block'; }

  const lucBox=document.getElementById('guide-lucien');
  const lucLock=document.getElementById('guide-lucien-locked');
  if(lucBox&&lucLock){ lucBox.style.display = lucUnlocked ? 'block' : 'none'; lucLock.style.display = lucUnlocked ? 'none' : 'block'; }

}


function createParticles(x,y,color,count=10,size=4){
  for(let i=0;i<count;i++){
    particles.push({
      x:x+Math.random()*20-10,
      y:y+Math.random()*20-10,
      vx:(Math.random()-0.5)*6,
      vy:(Math.random()-0.5)*6,
      life:30,
      color,size
    });
  }
}
function updateParticles(){
  particles=particles.filter(p=>{
    p.x+=p.vx;p.y+=p.vy;p.vy+=0.2;p.life--;
    return p.life>0
  });
}
function drawParticles(){
  particles.forEach(p=>{
    ctx.fillStyle=p.color;
    ctx.globalAlpha=p.life/30;
    ctx.fillRect(p.x,p.y,p.size,p.size)
  });
  ctx.globalAlpha=1
}

// --- IRA kill FX (Bane SUPER) ---
let iraFxBursts = []; // radial glows on kill
let iraScreenFlash = 0; // frames

function createIraKillFX(x,y){
  // Big red burst + sparks
  createParticles(x,y,'#ff1b3a',70,5);
  createParticles(x,y,'#7a0019',45,6);
  createParticles(x,y,'#ff6b6b',35,4);
  // Expanding glow rings
  for(let k=0;k<3;k++){
    iraFxBursts.push({
      x, y,
      r: 18 + k*10,
      vr: 6 + k*1.5,
      life: 18 + k*6,
      maxLife: 18 + k*6
    });
  }
  // Small screen flash
  iraScreenFlash = Math.max(iraScreenFlash, 14);
}

function updateIraFX(){
  iraFxBursts = iraFxBursts.filter(b=>{
    b.r += b.vr;
    b.life--;
    return b.life>0;
  });
  if(iraScreenFlash>0) iraScreenFlash--;
}

function drawIraFX(){
  // Draw glow rings behind particles
  iraFxBursts.forEach(b=>{
    const t = b.life / b.maxLife; // 1 -> 0
    ctx.save();
    ctx.globalAlpha = 0.55 * t;
    ctx.strokeStyle = '#7a0019';
    ctx.lineWidth = 6 * t + 1;
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
    ctx.stroke();
    ctx.globalAlpha = 0.25 * t;
    ctx.strokeStyle = '#ff1b3a';
    ctx.lineWidth = 10 * t + 2;
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.r*1.12, 0, Math.PI*2);
    ctx.stroke();
    ctx.restore();
  });
}


function showDamageNumber(x,y,dmg){
  const div=document.createElement('div');
  div.className='damage-number';
  div.textContent=`-${dmg}`;
  const rect=canvas.getBoundingClientRect();
  div.style.left=(rect.left+x)+'px';
  div.style.top=(rect.top+y-10)+'px';
  document.body.appendChild(div);
  setTimeout(()=>div.remove(),1000)
}

// ===== Lupi amichevoli (H√àCATE SUPER) =====
const WOLF_MAX = 3;
class Wolf{
  constructor(x,y){
    this.x=x; this.y=y;
    this.width=72; this.height=72;
    this.maxHP=51; this.hp=51;
    this.speed=3.5; // movimento rapido ma non OP
    this.damage=16;
    this.range=70; // morso ravvicinato
    this.cooldown=700;
    this.lastAttack=0;

    // per compatibilit√† con l'AI dei nemici (che si aspetta un "player-like")
    this.invulnerable=false;
    this.shieldActive=false;
  }
  takeDamage(d, attacker){
    if(this.hp<=0) return;

    // Kaerith SUPER: 25% damage reduction while active

    this.hp -= d;
    createParticles(this.x+this.width/2, this.y+this.height/2, '#90caf9', 14, 4);

    // Hendel passive: every enemy that hits him is knocked back and takes 40 damage
    if(this.type==='hendel' && attacker && typeof attacker.hp==='number'){
      const pcx=this.x+this.width/2, pcy=this.y+this.height/2;
      const ecx=attacker.x+attacker.width/2, ecy=attacker.y+attacker.height/2;
      let dx=ecx-pcx, dy=ecy-pcy;
      const len=Math.hypot(dx,dy)||1;
      dx/=len; dy/=len;

      // knockback away from Hendel
      const kb=140;
      attacker.x += dx*kb;
      attacker.y += dy*kb;
      attacker.x = Math.max(0, Math.min(canvas.width - attacker.width, attacker.x));
      attacker.y = Math.max(0, Math.min(canvas.height - attacker.height, attacker.y));

      // damage
      const ret=40;
      attacker.hp -= ret;
      showDamageNumber(attacker.x, attacker.y, ret);
      createParticles(attacker.x+attacker.width/2, attacker.y+attacker.height/2, '#8b5a2b', 10, 4);
      createParticles(attacker.x+attacker.width/2, attacker.y+attacker.height/2, '#9e9e9e', 6, 4);

      // kill handling
      if(attacker.hp<=0 && enemies){
        const idx=enemies.indexOf(attacker);
        if(idx!==-1){
          createParticles(attacker.x,attacker.y,'#fff176',28,6);
          dropStellarBonusAtIndexIfNeeded(idx);
          enemies.splice(idx,1);
          applyScore(100*currentLevel);
          addKill();
          if(this._baneSuperOnKill) this._baneSuperOnKill();
        }
      }
    }
  }
  _nearestEnemy(){
    if(!enemies || enemies.length===0) return null;
    const cx=this.x+this.width/2, cy=this.y+this.height/2;
    let best=null, bestD=1e9;
    for(const e of enemies){
      const ex=e.x+e.width/2, ey=e.y+e.height/2;
      const d=Math.hypot(ex-cx, ey-cy);
      if(d<bestD){ bestD=d; best=e; }
    }
    return best;
  }
  update(){
    const now=Date.now();
const target=this._nearestEnemy();
    if(!target) return;

    const cx=this.x+this.width/2, cy=this.y+this.height/2;
    const tx=target.x+target.width/2, ty=target.y+target.height/2;
    const dx=tx-cx, dy=ty-cy;
    const dist=Math.hypot(dx,dy) || 1;

    // Move towards target
    const nx=dx/dist, ny=dy/dist;
    this.x += nx*this.speed;
    this.y += ny*this.speed;

    // Clamp arena
    this.x=Math.max(0, Math.min(canvas.width-this.width, this.x));
    this.y=Math.max(0, Math.min(canvas.height-this.height, this.y));

    // Bite
    if(dist <= this.range && (now-this.lastAttack) >= this.cooldown){
      this.lastAttack=now;
      const finalDmg = Math.max(0, Math.round(this.damage * markMult(target)));
      target.hp -= finalDmg;
      showDamageNumber(target.x, target.y, finalDmg);
      createParticles(tx, ty, '#b0bec5', 10, 3);

      if(target.hp<=0){
        // kill credit: same as normal kill
        createParticles(target.x, target.y, '#fff176', 30, 6);
        const idx=enemies.indexOf(target);
        if(idx>=0){dropStellarBonusAtIndexIfNeeded(idx);enemies.splice(idx,1);}
        applyScore(100*currentLevel);
      addKill(); }
    }
  }
  draw(){
    // sprite
    if(wolfImg && wolfImg.complete){
      ctx.drawImage(wolfImg, this.x, this.y, this.width, this.height);
    }else{
      ctx.fillStyle='#90caf9';
      ctx.fillRect(this.x,this.y,this.width,this.height);
    }

    // mini HP bar
    const barW=this.width, barH=6;
    const pct=Math.max(0, Math.min(1, this.hp/this.maxHP));
    ctx.fillStyle='rgba(0,0,0,0.55)';
    ctx.fillRect(this.x, this.y-10, barW, barH);
    ctx.fillStyle='#66bb6a';
    ctx.fillRect(this.x, this.y-10, barW*pct, barH);
  }
}

function spawnWolvesNearPlayer(playerObj, wanted){
  if(!playerObj) return;
  const free = Math.max(0, WOLF_MAX - (wolves?.length||0));
  const n = Math.max(0, Math.min(wanted||0, free));
  if(n<=0) return;

  const px=playerObj.x+playerObj.width/2;
  const py=playerObj.y+playerObj.height/2;

  for(let i=0;i<n;i++){
    const a=Math.random()*Math.PI*2;
    const r=55 + Math.random()*25;
    const x=Math.max(0, Math.min(canvas.width-64, px + Math.cos(a)*r - 32));
    const y=Math.max(0, Math.min(canvas.height-64, py + Math.sin(a)*r - 32));
    wolves.push(new Wolf(x,y));
    createParticles(x+32,y+32,'#90caf9',18,4);
  }
}

function updateWolves(){
  if(!wolves || wolves.length===0) return;
  // remove dead
  wolves = wolves.filter(w => w && w.hp>0);
  for(const w of wolves) w.update();
}

function drawWolves(){
  if(!wolves || wolves.length===0) return;
  for(const w of wolves) w.draw();
}

// I nemici attaccano i lupi se pi√π vicini del player
function getPreferredTarget(enemy, playerObj){
  try{
    // Boss sempre focalizzati sul player (evita "zone sicure" quando i lupi attirano l'aggro)
    if(enemy && typeof enemy.type==='string' && enemy.type.startsWith('boss')) return playerObj;
    if(!wolves || wolves.length===0) return playerObj;
    if(!enemy || !playerObj) return playerObj;

    const ex=enemy.x+enemy.width/2, ey=enemy.y+enemy.height/2;
    const px=playerObj.x+playerObj.width/2, py=playerObj.y+playerObj.height/2;
    const dp=Math.hypot(px-ex, py-ey);

    let best=null, bestD=1e9;
    for(const w of wolves){
      if(!w || w.hp<=0) continue;
      const wx=w.x+w.width/2, wy=w.y+w.height/2;
      const d=Math.hypot(wx-ex, wy-ey);
      if(d<bestD){ bestD=d; best=w; }
    }
    return (best && bestD < dp) ? best : playerObj;
  }catch(e){
    return playerObj;
  }
}

function markMult(enemy){
  return (enemy && enemy.salsyMarkUntil && Date.now() < enemy.salsyMarkUntil) ? 2 : 1;
}
function applyEnemyDamage(enemy, baseDmg){
  // Rooney EVO passive: first hit on a given enemy deals +15% damage (doesn't change stats)
  let mult=1;
  if(typeof player!=='undefined' && player && player.type==='rooney' && player.evolved && enemy && !enemy._rooneyFirstHit){
    mult=1.5; // EVO: Rooney first hit +50% damage
    enemy._rooneyFirstHit=true;
  }
  const finalDmg = Math.max(0, Math.round(baseDmg * mult * markMult(enemy)));
  enemy._lastHitAt = Date.now();
  enemy.hp -= finalDmg;
  return finalDmg;
}

function shakeScreen(){shakeAmount=8}

// Extended projectile to support friendly, AoE, homing, pulse damage


function aabbDist2(ax,ay,aw,ah,bx,by,bw,bh){
  // distanza minima tra due rettangoli (0 se overlap)
  const dx = (ax+aw < bx) ? (bx - (ax+aw)) : (bx+bw < ax) ? (ax - (bx+bw)) : 0;
  const dy = (ay+ah < by) ? (by - (ay+ah)) : (by+bh < ay) ? (ay - (by+bh)) : 0;
  return dx*dx + dy*dy;
}
function spawnProjectile(opts){
  // opts: {x,y,vx,vy,damage,ttl,color,radius,friendly,aoeRadius,aoeFullDamage,homing,speed,isVoltryxSuper,pulseInterval,lastPulse,targetRef,explodeOnExpire}
  const p={
    x:opts.x,y:opts.y,vx:opts.vx||0,vy:opts.vy||0,
    damage:opts.damage||10,created:Date.now(),
    ttl:opts.ttl||3000,color:opts.color||'#fff',
    radius:opts.radius||6,friendly:!!opts.friendly,
    aoeRadius:opts.aoeRadius||0,aoeFullDamage:!!opts.aoeFullDamage,homing:!!opts.homing,
    speed:opts.speed||Math.hypot(opts.vx||0,opts.vy||0)||6,
    isVoltryxSuper:!!opts.isVoltryxSuper,
    pulseInterval:opts.pulseInterval||0,
    lastPulse:opts.lastPulse||0,
  targetRef:opts.targetRef||null,
    explodeOnExpire:!!opts.explodeOnExpire,
    shape:opts.shape||'circle',
    w:opts.w||0,
    h:opts.h||0,
    angle:typeof opts.angle==='number'?opts.angle:null,
    onHitPlayer:opts.onHitPlayer||null,
    source:opts.source||opts.owner||null,
    meta:opts.meta||null,
    excludeRef:opts.excludeRef||null
  };
  projectiles.push(p);
}

function updateProjectiles(){
  const now=Date.now();

  // NOTE: Player/enemy freeze logic used to live here (Marz old super).
  // updateProjectiles runs in global scope; player state is handled in Player.update().


    // Grapple safety: prevent rare stuck state (e.g., Jimmy vs shooter)
    if(this.isGrappling){
      if(!this.grappleTarget || !enemies.includes(this.grappleTarget) || (this.grappleStartTime && now-this.grappleStartTime>1400)){
        this.isGrappling=false;this.grappleTarget=null;this.vx=0;this.vy=0;
          this.grappleStartTime=0;
        this.grappleStartTime=0;
        if(this.type==='jimmy' && this.shieldActive && !this.isDoingSuper) this.shieldActive=false;
      }
    }

  projectiles=projectiles.filter(p=>{
    // homing behavior (friendly):
    // - if targetRef exists and is still alive, home on it
    // - otherwise fall back to nearest enemy
    if(p.homing && p.friendly && enemies.length>0){
      let target = (p.targetRef && enemies.includes(p.targetRef)) ? p.targetRef : null;

      if(!target){
        let closest=null, best=Infinity;
        for(const e of enemies){
          const dx=(e.x+e.width/2)-p.x;
          const dy=(e.y+e.height/2)-p.y;
          const d=Math.hypot(dx,dy);
          if(d<best){best=d;closest=e}
        }
        target = closest;
      }

      if(target){
        const dx=(target.x+target.width/2)-p.x;
        const dy=(target.y+target.height/2)-p.y;
        const len=Math.hypot(dx,dy)||1;
        const steerX=(dx/len)*p.speed;
        const steerY=(dy/len)*p.speed;
        // soft steer
        p.vx = p.vx*0.6 + steerX*0.4;
        p.vy = p.vy*0.6 + steerY*0.4;
      }
    }

    p.x+=p.vx;
    p.y+=p.vy;

    // Bounds
    const aliveInBounds = p.x>=-60 && p.x<=canvas.width+60 && p.y>=-60 && p.y<=canvas.height+60;

    // Voltryx super orb pulse AoE damage
    if(p.isVoltryxSuper){
      if(!p.lastPulse || now - p.lastPulse >= p.pulseInterval){
        p.lastPulse = now;
        // damage all enemies within aoeRadius
        for(let i=enemies.length-1;i>=0;i--){
          const e=enemies[i];
        if(p.excludeRef && e===p.excludeRef) continue;
          const dist=Math.hypot((e.x+e.width/2)-p.x,(e.y+e.height/2)-p.y);
          if(dist <= p.aoeRadius){
            const dmg = p.aoeFullDamage ? Math.round(p.damage) : Math.round(p.damage*SUPER_DAMAGE_MULT);
            const _dmg=dmg; const _final=applyEnemyDamage(e,_dmg);
            createParticles(e.x,e.y,'#f39c12',12,5);
            showDamageNumber(e.x,e.y, _final);
            if(e.hp<=0){
              createParticles(e.x,e.y,'#fff176',30,6);
              dropStellarBonusAtIndexIfNeeded(i);
              enemies.splice(i,1);
              applyScore(100*currentLevel);
                addKill(); if(this.type==='kouvagia'){this.hp=Math.min(this.maxHP,this.hp+3);createParticles(this.x,this.y,'#2ecc71',6,3);}
            }
          }
        }
      }
    }

    // Collision: friendly hits enemies
    if(p.friendly){
      for(let i=enemies.length-1;i>=0;i--){
        const e=enemies[i];
        const dx=(e.x+e.width/2)-p.x;
        const dy=(e.y+e.height/2)-p.y;
        const dist=Math.hypot(dx,dy);
        if(dist <= (p.radius + Math.max(e.width,e.height)/2)*0.8){
          // impact
          if(p.aoeRadius>0){
            // area explosion
            for(let j=enemies.length-1;j>=0;j--){
              const ee=enemies[j];
              const d2=Math.hypot((ee.x+ee.width/2)-p.x,(ee.y+ee.height/2)-p.y);
              if(d2<=p.aoeRadius){
                const dmg = p.aoeFullDamage ? Math.round(p.damage) : Math.round(p.damage*SUPER_DAMAGE_MULT);
                const _dmg=dmg; const _final=applyEnemyDamage(ee,_dmg);
                createParticles(ee.x,ee.y,'#ffb74d',8,4);
                showDamageNumber(ee.x,ee.y, _final);
                if(ee.hp<=0){
                  createParticles(ee.x,ee.y,'#fff176',30,6);
                  dropStellarBonusAtIndexIfNeeded(j);
                  enemies.splice(j,1);
                  applyScore(100*currentLevel);
                addKill(); }
              }
            }
          }else{
            // single target
            const dmg=Math.round(p.damage);
            const _dmg=dmg; const _final=applyEnemyDamage(e,_dmg);
            createParticles(e.x,e.y,'#ffd54f',8,4);
            showDamageNumber(e.x,e.y, _final);
            // H√®cate: main arrow splits into 3 arrows to OTHER enemies
            if(p.meta && p.meta.type==='hecateMain'){
              const impactX=p.x, impactY=p.y;
              createParticles(impactX, impactY, '#c5cae9', 18, 4);
              const others = enemies.filter(ee=>ee!==e).sort((a,b)=>{
                const da=Math.hypot((a.x+a.width/2)-impactX,(a.y+a.height/2)-impactY);
                const db=Math.hypot((b.x+b.width/2)-impactX,(b.y+b.height/2)-impactY);
                return da-db;
              }).slice(0,3);
              const splitDmg = Math.round((p.meta.splitDamage || Math.round(p.damage * 0.5)));
              for(const t of others){
                const dx=(t.x+t.width/2)-impactX;
                const dy=(t.y+t.height/2)-impactY;
                const len=Math.hypot(dx,dy)||1;
                const speed=12;
                const vx=(dx/len)*speed;
                const vy=(dy/len)*speed;
                spawnProjectile({
                  x:impactX,y:impactY,vx,vy,speed,
                  damage:splitDmg,ttl:520,color:'#c5cae9',
                  radius:6,friendly:true,
                  shape:'rect',w:18,h:4,angle:Math.atan2(vy,vx),
                  excludeRef:e
                });
                createParticles(impactX,impactY,'#c5cae9',6,3);
              }
            }
            if(e.hp<=0){
              createParticles(e.x,e.y,'#fff176',30,6);
              dropStellarBonusAtIndexIfNeeded(i);
              enemies.splice(i,1);
              applyScore(100*currentLevel);
                addKill(); if(this.type==='kouvagia'){this.hp=Math.min(this.maxHP,this.hp+3);createParticles(this.x,this.y,'#2ecc71',6,3);}
            }
          }
          if(p.meta && p.meta.pdorChain){
            // Chain: jump to nearest enemy up to 5 hits, halving damage each jump.
            if(!p.meta.hitRefs) p.meta.hitRefs = [];
            p.meta.hitRefs.push(e);
            p.meta.hitsLeft = (typeof p.meta.hitsLeft==='number'? p.meta.hitsLeft : 1) - 1;

            if(p.meta.hitsLeft > 0){
              let bestT=null, bestD=Infinity;
              for(const t of enemies){
                if(t===e) continue;
                if(p.meta.hitRefs.includes(t)) continue;
                const dx=(t.x+t.width/2)-p.x;
                const dy=(t.y+t.height/2)-p.y;
                const d=Math.hypot(dx,dy);
                if(d<bestD){bestD=d;bestT=t;}
              }
              if(bestT){
                const dx=(bestT.x+bestT.width/2)-p.x;
                const dy=(bestT.y+bestT.height/2)-p.y;
                const len=Math.hypot(dx,dy)||1;
                const speed=9;
                // halve damage on every jump (including the next hit)
                p.damage = Math.max(1, Math.round(p.damage * 0.5));
                p.vx=(dx/len)*speed;
                p.vy=(dy/len)*speed;
                p.speed=speed;
                p.shape='rect';
                p.w=35; p.h=10;
                p.angle=Math.atan2(p.vy,p.vx);
                // nudge forward to avoid re-hitting instantly
                p.x += p.vx*0.35;
                p.y += p.vy*0.35;
                createParticles(p.x,p.y,'#ffffff',6,3);
                return true; // keep projectile alive
              }
            }
            return false; // no more targets
          }
          return false; // projectile consumed
        }
      }
    }else{
      // enemy projectiles hit player
      if(player && p.x>player.x && p.x<player.x+player.width && p.y>player.y && p.y<player.y+player.height){
        if(typeof p.onHitPlayer==='function'){ try{ p.onHitPlayer(player); }catch(e){} }
        player.takeDamage(p.damage, p.source || null);
        return false;
      }

      // enemy projectiles can hit wolves (H√®cate summon)
      if(wolves && wolves.length){
        for(const w of wolves){
          if(!w || w.hp<=0) continue;
          if(p.x>w.x && p.x<w.x+w.width && p.y>w.y && p.y<w.y+w.height){
            // apply damage to wolf
            w.hp -= Math.max(1, Math.round(p.damage));
            createParticles(w.x+w.width/2, w.y+w.height/2, '#90caf9', 10, 4);
            return false;
          }
        }
      }
    }

    const aliveTime = (now-p.created)<p.ttl;
    const alive = aliveTime && aliveInBounds;

    // Optional AoE explosion when the projectile stops (ttl end / out of bounds)
    if(!alive && p.explodeOnExpire && p.friendly && p.aoeRadius>0){
      // apply AoE at last position
      for(let j=enemies.length-1;j>=0;j--){
        const ee=enemies[j];
        const dx=(ee.x+ee.width/2)-p.x;
        const dy=(ee.y+ee.height/2)-p.y;
        const d=Math.hypot(dx,dy);
        if(d<=p.aoeRadius){
          const dmg=Math.round(p.damage);
          const _dmg=dmg; const _final=applyEnemyDamage(ee,_dmg);
          createParticles(ee.x,ee.y,'#ffb74d',8,4);
          showDamageNumber(ee.x,ee.y, _final);
          if(ee.hp<=0){
            createParticles(ee.x,ee.y,'#fff176',30,6);
            dropStellarBonusAtIndexIfNeeded(j);
            enemies.splice(j,1);
            applyScore(100*currentLevel);
          addKill(); }
        }
      }
      createParticles(p.x,p.y,'#ffa726',18,5);
    }

    return alive;
  });
}

function drawProjectiles(){
  projectiles.forEach(p=>{
    ctx.globalAlpha = p.isVoltryxSuper ? 0.8 : 1;

    // Archer arrows (small elongated hits)
    if(p.shape==='rect'){
      const ang = (p.angle!==null && !Number.isNaN(p.angle)) ? p.angle : Math.atan2(p.vy||0, p.vx||0);
      const w = p.w || 16;
      const h = p.h || 4;
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(ang);
      ctx.fillStyle=p.color;

      // PDOR dart: tapered "crystal/teardrop" instead of a plain rectangle
      if(p.meta && p.meta.pdorChain){
        const L = w;               // length
        const W = Math.max(6, h*1.6); // width (a bit thicker so the shape reads better)
        ctx.beginPath();
        // tip (front)
        ctx.moveTo(L/2, 0);
        // upper edge to rounded base
        ctx.quadraticCurveTo(L*0.15,  W*0.75, -L/2,  W*0.35);
        // round the base
        ctx.quadraticCurveTo(-L/2 - W*0.25, 0, -L/2, -W*0.35);
        // lower edge back to tip
        ctx.quadraticCurveTo(L*0.15, -W*0.75, L/2, 0);
        ctx.closePath();
        ctx.fill();

        // subtle inner highlight
        ctx.globalAlpha = 0.25;
        ctx.strokeStyle = 'rgba(255,255,255,0.8)';
        ctx.lineWidth = Math.max(1.5, W*0.12);
        ctx.stroke();
        ctx.globalAlpha = 1;
      }else{
        // Rooney punch-style homogeneous flared end
        const L = w;
        const W = h*1.2;

        ctx.beginPath();
        // main shaft
        ctx.moveTo(-L/2, -W/2);
        ctx.lineTo(L*0.15, -W/2);
        ctx.lineTo(L*0.15, W/2);
        ctx.lineTo(-L/2, W/2);
        ctx.closePath();
        ctx.fill();

        // flared fist tip
        ctx.beginPath();
        ctx.moveTo(L*0.15, -W*0.9);
        ctx.lineTo(L/2, -W*0.5);
        ctx.lineTo(L/2, W*0.5);
        ctx.lineTo(L*0.15, W*0.9);
        ctx.closePath();
        ctx.fill();
      }
      ctx.restore();
      
    // Marcus wavy projectile visual (thick undulating line)
    if(p.meta && p.meta.marcus){
      const ang = Math.atan2(p.vy||0, p.vx||1);
      const segs = 20;
      const length = 120; // total length of the visible wave
      const step = length / segs;
      const amp = (p.meta && p.meta.amp) ? p.meta.amp : 14;
      const freq = (p.meta && p.meta.freq) ? p.meta.freq : 0.9;
      const phase = (p.meta && p.meta.phase) ? p.meta.phase : 0;
      const nowT = Date.now();
      const t2 = (nowT - (p.created||0)) / 1000;

      const cx = p.x, cy = p.y;
      const dxUnit = Math.cos(ang), dyUnit = Math.sin(ang);
      const pxUnit = Math.cos(ang + Math.PI/2), pyUnit = Math.sin(ang + Math.PI/2);

      ctx.save();
      ctx.lineWidth = Math.max(6, (p.radius||8) * 2.2);
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';
      ctx.strokeStyle = p.color || '#b19cff';
      ctx.beginPath();
      for(let i = -Math.floor(segs/2); i <= Math.floor(segs/2); i++){
        const u = i * step;
        const wobble = Math.sin((u * 0.06 * freq) + (t2 * freq) + phase);
        const ox = pxUnit * wobble * amp;
        const oy = pyUnit * wobble * amp;
        const x = cx + dxUnit * u + ox;
        const y = cy + dyUnit * u + oy;
        if(i === -Math.floor(segs/2)) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();

      ctx.globalAlpha = 0.14;
      ctx.lineWidth = Math.max(10, (p.radius||8) * 3.0);
      ctx.stroke();
      ctx.globalAlpha = 1;
      ctx.restore();
      return;
    }

    ctx.globalAlpha = 1;
      return;
    }

    // Default circular bullets
    ctx.fillStyle=p.color;
    ctx.beginPath();
    ctx.arc(p.x,p.y,p.isVoltryxSuper ? 18 : p.radius,0,Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    if(p.isVoltryxSuper){
      // draw a soft aura
      ctx.strokeStyle='rgba(243,156,18,0.5)';
      ctx.lineWidth=4;
      ctx.beginPath();
      ctx.arc(p.x,p.y,p.aoeRadius,0,Math.PI*2);
      ctx.stroke();
    }
  });
}


// Laser hazards (OneEyes + Boss4)
function spawnLaser(opts){
  // opts: {x,y,angle,length,width,ttl,damage,kind,chargeMs,chargedAt}
  lasers.push({
    x:opts.x,y:opts.y,angle:opts.angle||0,length:opts.length||520,width:opts.width||14,
    created:Date.now(),ttl:opts.ttl||1000,damage:opts.damage||15,
    kind:opts.kind||'laser', chargeMs:opts.chargeMs||0, chargedAt:Date.now()+ (opts.chargeMs||0),
    hitCooldown:220, lastHit:0,
    owner:opts.owner||opts.source||null,
    trackPlayer: !!opts.trackPlayer,
    hitOnce:false
  });
}

function updateLasers(){
  const now=Date.now();
  lasers = lasers.filter(L=>{
    // Aimbot 360¬∞ per boss: laser che segue il player durante la durata
    if(L.trackPlayer && player){
      const ocx = (L.owner? (L.owner.x + L.owner.width/2) : L.x);
      const ocy = (L.owner? (L.owner.y + L.owner.height/2) : L.y);
      const pcx = player.x + player.width/2;
      const pcy = player.y + player.height/2;
      L.x = ocx; L.y = ocy;
      L.angle = Math.atan2(pcy-ocy, pcx-ocx);
    }
    const alive = (now - L.created) < (L.ttl + (L.chargeMs||0));
    if(!alive) return false;

    // During charge: no damage
    const active = now >= L.chargedAt;

    if(active && player){
      // Collision: distance from player center to laser segment
      const px = player.x + player.width/2;
      const py = player.y + player.height/2;

      const x2 = L.x + Math.cos(L.angle)*L.length;
      const y2 = L.y + Math.sin(L.angle)*L.length;

      // projection
      const vx = x2 - L.x, vy = y2 - L.y;
      const wx = px - L.x, wy = py - L.y;
      const c1 = wx*vx + wy*vy;
      const c2 = vx*vx + vy*vy;
      let t = c2 ? (c1 / c2) : 0;
      t = Math.max(0, Math.min(1, t));
      const cx = L.x + t*vx;
      const cy = L.y + t*vy;
      const dist = Math.hypot(px - cx, py - cy);

      if(dist <= (L.width/2 + Math.max(player.width, player.height)*0.20)){
        // OneEyes: il danno pu√≤ essere preso una sola volta per raggio
        if(L.kind==='oneyes'){
          if(!L.hitOnce){
            L.hitOnce=true;
            player.takeDamage(L.damage, L.owner || null);
          }
        } else {
          if(now - L.lastHit >= L.hitCooldown){
            L.lastHit = now;
            player.takeDamage(L.damage, L.owner || null);
          }
        }
      }
    }

    return true;
  });
}

function drawLasers(){
  const now=Date.now();
  lasers.forEach(L=>{
    const active = now >= L.chargedAt;
    const x2 = L.x + Math.cos(L.angle)*L.length;
    const y2 = L.y + Math.sin(L.angle)*L.length;

    ctx.save();
    ctx.lineCap='round';

    if(!active){
      // charge preview
      ctx.globalAlpha = 0.55;
      ctx.strokeStyle = 'rgba(255,255,255,0.7)';
      ctx.lineWidth = Math.max(6, L.width*0.5);
      ctx.beginPath(); ctx.moveTo(L.x,L.y); ctx.lineTo(x2,y2); ctx.stroke();
      ctx.globalAlpha = 1;
    } else {
      // active beam
      ctx.globalAlpha = (L.kind==='photon') ? 0.92 : 0.75;
      ctx.strokeStyle = (L.kind==='photon') ? 'rgba(243,156,18,0.9)' : 'rgba(52,152,219,0.9)';
      ctx.lineWidth = L.width;
      ctx.beginPath(); ctx.moveTo(L.x,L.y); ctx.lineTo(x2,y2); ctx.stroke();

      // glow
      ctx.globalAlpha = 0.28;
      ctx.lineWidth = L.width*1.9;
      ctx.beginPath(); ctx.moveTo(L.x,L.y); ctx.lineTo(x2,y2); ctx.stroke();
      ctx.globalAlpha = 1;
    }

    ctx.restore();
  });
}


function spawnTempBeam(opts){
  // opts: {x1,y1,x2,y2,width,ttl,damage1,damageStay,friendly}
  tempBeams.push({
    x1:opts.x1,y1:opts.y1,x2:opts.x2,y2:opts.y2,
    width:opts.width||18,
    created:Date.now(),
    ttl:opts.ttl||260,
    damage1:opts.damage1||40,
    damageStay:opts.damageStay||30,
    hitMap:new Map() // enemy -> {firstHit, left, extraDone}
  });
}

// distance from point to segment
function _distPointToSeg(px,py,x1,y1,x2,y2){
  const vx=x2-x1, vy=y2-y1;
  const wx=px-x1, wy=py-y1;
  const c1=wx*vx+wy*vy;
  if(c1<=0) return Math.hypot(px-x1,py-y1);
  const c2=vx*vx+vy*vy;
  if(c2<=c1) return Math.hypot(px-x2,py-y2);
  const b=c1/c2;
  const bx=x1+b*vx, by=y1+b*vy;
  return Math.hypot(px-bx,py-by);
}

function updateTempBeams(){
  const now=Date.now();
  for(let i=tempBeams.length-1;i>=0;i--){
    const B=tempBeams[i];
    const age=now-B.created;
    if(age>B.ttl){ tempBeams.splice(i,1); continue; }

    // collisions with enemies
    enemies.forEach(e=>{
      const ex=e.x+e.width/2, ey=e.y+e.height/2;
      const dist=_distPointToSeg(ex,ey,B.x1,B.y1,B.x2,B.y2);
      const inside = dist <= (B.width*0.55 + Math.max(e.width,e.height)*0.18);

      const state = B.hitMap.get(e);
      if(inside){
        if(!state){
          // first hit
          const dmg = B.damage1;
          const final = applyEnemyDamage(e, dmg);
          showDamageNumber(e.x,e.y, final);
          createParticles(e.x+e.width/2,e.y+e.height/2,'#4fc3f7',10,4);
          B.hitMap.set(e,{firstHit:now,left:false,extraDone:false});
        } else {
          // check linger bonus only if stayed inside continuously
          if(!state.extraDone && !state.left && (now - state.firstHit) >= 180){
            const dmg2=B.damageStay;
            const final2 = applyEnemyDamage(e, dmg2);
            showDamageNumber(e.x,e.y, final2);
            createParticles(e.x+e.width/2,e.y+e.height/2,'#81d4fa',12,4);
            state.extraDone=true;
          }
        }
      } else {
        if(state && !state.extraDone){
          state.left=true;
        }
      }
    });
  }
}

function drawTempBeams(){
  tempBeams.forEach(B=>{
    const x1=B.x1, y1=B.y1, x2=B.x2, y2=B.y2;
    ctx.save();
    ctx.lineCap='round';

    // glow
    ctx.globalAlpha=0.22;
    ctx.strokeStyle='#00b0ff';
    ctx.lineWidth=B.width*2.4;
    ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();

    // core
    ctx.globalAlpha=0.85;
    ctx.strokeStyle='#4fc3f7';
    ctx.lineWidth=B.width;
    ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();

    // white highlight
    ctx.globalAlpha=0.65;
    ctx.strokeStyle='rgba(255,255,255,0.9)';
    ctx.lineWidth=Math.max(2, B.width*0.22);
    ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();

    ctx.restore();
  });
}

function spawnPickup(x,y,type,value=0){
  // Small collectible pickup (compatible with updatePickups / drawPickups)
  const hitR = (type==='malus') ? MALUS_HIT_RADIUS : BONUS_HIT_RADIUS;
  pickups.push({x,y,type,value,created:Date.now(),ttl:20000,radius:18,hitRadius:hitR,w:28,h:28});
}

// Guaranteed StellarBonus drop: on levels 5/10/15/20/25, the LAST enemy alive always drops a StellarBonus exactly where it dies.
const GUARANTEED_STELLAR_LEVELS = new Set([5,10,15,20,25]);
function dropStellarBonusAtIndexIfNeeded(enemyIndex){
  if(!GUARANTEED_STELLAR_LEVELS.has(currentLevel)) return;
  // if we're about to remove an enemy and it's the last one on the field, enemies.length is 1 at this exact moment
  if(enemies.length !== 1) return;
  const e = enemies[enemyIndex];
  if(!e) return;
  const cx = e.x + (e.width||0)/2;
  const cy = e.y + (e.height||0)/2;
  spawnPickup(cx, cy, 'stellar');
}
function spawnPickupsForLevel(level){
  // IMPORTANT: do NOT clear existing pickups here.
  // Bonus pickups remain on the field when the level ends.
  if(level<4) return;

  const count=1+Math.floor(Math.random()*2);
  for(let i=0;i<count;i++){
    const isGold=Math.random()<GOLD_PROB;
    const type=isGold ? 'gold' : pickRandomPickupType();

    const x=60+Math.random()*(canvas.width-240);
    const y=60+Math.random()*(canvas.height-180);

    const hitR = (type==='malus') ? MALUS_HIT_RADIUS : BONUS_HIT_RADIUS;
    // keep visual size small (radius:18) but increase hitbox via hitRadius
    pickups.push({type,x,y,radius:18,hitRadius:hitR,created:Date.now(),ttl:20000});
  }
}
function drawPickups(){
  pickups.forEach(p=>{
    const img = getPickupImage(p.type);
    // Keep the existing small pickup size:
    // - if pickup defines w/h use those
    // - else if pickup defines radius use diameter
    // - fallback to 28px
    const w = (p.w!=null)?p.w: (p.radius!=null)?(p.radius*2):28;
    const h = (p.h!=null)?p.h: (p.radius!=null)?(p.radius*2):28;
    const dw = w*2;
    const dh = h*2;

    if(img && img.complete && img.naturalWidth>0){
      ctx.drawImage(img, p.x - dw/2, p.y - dh/2, dw, dh);
    } else {
      // Fallback if image not yet loaded
      if(p.type==='heal')ctx.fillStyle='#2ecc71';
      else if(p.type==='atk')ctx.fillStyle='#e74c3c';
      else if(p.type==='super')ctx.fillStyle='#f1c40f';
      else if(p.type==='gold')ctx.fillStyle='gold';
      else if(p.type==='stellar')ctx.fillStyle='rgba(255,255,255,0.9)';
      else if(p.type==='speed')ctx.fillStyle='#3498db';
      else if(p.type==='shieldPickup')ctx.fillStyle='#7fdbff';
      else if(p.type==='malus')ctx.fillStyle='#8b0000';
      ctx.beginPath();
      ctx.arc(p.x,p.y,(p.radius!=null)?p.radius:Math.min(w,h)/2,0,Math.PI*2);
      ctx.fill();
    }
  });
}

function updatePickups(playerRef){
  // Use player CENTER for pickup collection checks.
  // This fixes edge cases where (using top-left) some pickups became uncollectable near arena borders.
  const pcx = playerRef.x + (playerRef.width||0)/2;
  const pcy = playerRef.y + (playerRef.height||0)/2;

  pickups = pickups.filter(p=>{
    if(Date.now()-p.created>p.ttl) return false;

    const dist = Math.hypot((p.x-pcx),(p.y-pcy));
    const pr = (p.hitRadius!=null) ? p.hitRadius : (p.radius!=null ? p.radius : 18);

    if(dist < pr + Math.max(playerRef.width,playerRef.height)/2){
      applyPickupEffect(playerRef,p.type);
      return false;
    }
    return true;
  });
}
function applyPickupEffect(playerRef,type){
  if(type==='heal'){
    const healAmount=Math.round(playerRef.maxHP*0.25);
    playerRef.hp=Math.min(playerRef.maxHP,playerRef.hp+healAmount);
    createParticles(playerRef.x,playerRef.y,'#2ecc71',20);
  } else if(type==='atk'){
    playerRef.attackBuffMultiplier=1.6;
    playerRef.attackBuffUntil=Date.now()+10000;
    createParticles(playerRef.x,playerRef.y,'#e74c3c',20);
  } else if(type==='super'){
    playerRef.lastSuper=Date.now()-playerRef.superCooldown-100;
    createParticles(playerRef.x,playerRef.y,'#f1c40f',20);
    } else if(type==='stellar'){
    // StellarBonus: +100 HP, +25% speed for 3s, white opaque glow for 3s
    playerRef.hp = Math.min(playerRef.maxHP, playerRef.hp + 100);
    playerRef.speed = playerRef._baseSpeed * 1.25;
    playerRef.speedBuffUntil = Date.now() + 3000;
    playerRef.stellarGlowUntil = Date.now() + 1000;
    createParticles(playerRef.x, playerRef.y, '#ffffff', 36, 5);
  } else if(type==='gold'){
    playerRef.hp=playerRef.maxHP;
    playerRef.attackBuffMultiplier=2.0;
    playerRef.attackBuffUntil=Date.now()+15000;
    playerRef.lastSuper=Date.now()-playerRef.superCooldown-100;
    createParticles(playerRef.x,playerRef.y,'gold',40);
    for(let i=0;i<8;i++) createParticles(playerRef.x+(Math.random()-0.5)*40,playerRef.y+(Math.random()-0.5)*40,'#fff176',6);
  } else if(type==='speed'){
    playerRef.speed=playerRef._baseSpeed*1.5;
    playerRef.speedBuffUntil=Date.now()+7000;
    createParticles(playerRef.x,playerRef.y,'#3498db',20);
  } else if(type==='shieldPickup'){
    playerRef.pickupShieldUntil=Date.now()+6000;
    playerRef.invulnerable=true;
    createParticles(playerRef.x,playerRef.y,'#7fdbff',30);

    } else if(type==='furia'){
    // Cura nel tempo: +10 HP/s per 10s
    playerRef.furiaHealUntil = Date.now()+10000;
    playerRef.furiaLastHeal = Date.now();

    // Onde di danno (3 aree visibili che si allargano)
    const cx = playerRef.x + playerRef.width/2;
    const cy = playerRef.y + playerRef.height/2;
    spawnFuriaWaves(cx, cy);

    // Extra feedback visivo
    createParticles(cx,cy,'#ff00ff',70,6);
  } else if(type==='ice'){
    enemies.forEach(e=>{
      e.speed *= 0.4;
      e.iceUntil = Date.now()+17000;
      e.iceDps = 2;
      e.iceLastTick = Date.now();
    });
    createParticles(playerRef.x,playerRef.y,'#ffffff',40);
  } else if(type==='malus'){
    playerRef.poisonUntil=Date.now()+10000;
    playerRef.poisonTickLast=Date.now();
    playerRef.poisonTickDamage=1;
    createParticles(playerRef.x,playerRef.y,'#8b0000',30);
  }
}

class Player{
  constructor(type){
    const s=characterStats[type];
    this.type=type;
    this.x=canvas.width/2;this.y=canvas.height/2;
    this.width=130;this.height=135;
    this.vx=0;this.vy=0;
    this.maxHP=s.hp;this.hp=s.hp;
    this.speed=s.speed;this._baseSpeed=s.speed;
    // Archer slow (temporary): stacks up to -15% total
    this._slowPct=0;
    this._slowUntil=0;
    this.damage=s.damage;this.range=s.range;
    this.cooldown=s.cooldown;this.attackType=s.attackType;
    this._baseCooldown=s.cooldown;
    // Bane SUPER state
    this.baneSuperUntil=0;
    this.baneSuperAttackMult=1;
    this._baneSuperAppliedCooldown=false;
    this.lastAttack=0;this.facingRight=true;
    this.aimX=1;this.aimY=0; // ultima direzione di mira/movimento
    this.dashCooldown=0;this.attacking=false;this.attackTime=0;
    this.combo=0;this.damageTaken=0;this.isDashing=false;this.dashTime=0;
    this.superCooldown=s.superCooldown;this.superDuration=s.superDuration;
    this.lastSuper=-s.superCooldown;this.isDoingSuper=false;this.superStartTime=0;
    this.superTargets=[];this.grappleTarget=null;this.isGrappling=false;
    this.grappleStartTime=0; // safety timeout for grapple

    // Jimmy SUPER grapple pass-through helpers (no "grab" interaction)
    this._superGrapplePassUntil=0;
    this._superGrappleDirX=1;
    this._superGrappleDirY=0;
    this.aimAssistRadius=400;this.aimAssistStrength=0.35;
    this._superHitDone=false;this._superPhase=0;
    this.shieldActive=false;this.shieldDurability=4;this.shieldMaxDurability=4;this.shieldBroken=false;this.shieldBrokenTime=0;this.shieldRegenMs=6000;
    this.attackBuffMultiplier=1;this.attackBuffUntil=0;this.speedBuffUntil=0;this.pickupShieldUntil=0;this.invulnerable=false;
    this._dashSpeedMult=3;
    this._dashDuration=200;

    // Kouvagia dash-attack helpers
    this._kouvagiaDashActive=false;
    this._kouvagiaDashHitCd=0;
    this._kouvagiaExplosionPending=false;
    this._kouvagiaSuperFxStart=0;
    this._kouvagiaSuperFxUntil=0;

    // Jimmy jetpack
    this.jetpackCooldown=15000;
    this.lastJetpack=Date.now()-this.jetpackCooldown;
    this.isJetpacking=false;
    this.jetpackDuration=3000;
    this._jetpackSpeedMultiplier=2;

    this.lastSuper=-99999;
    this.poisonUntil=0;
    this.poisonTickLast=0;
    this.poisonTickDamage=1;

    // --- Evolution (after Boss level 15) ---
    this.evolved=false;
    this._evoFxUntil=0;
    // StellarBonus visual
    this.stellarGlowUntil=0;
    this._jimmyNextGrappleCdMult=1;
  }

  evolve(){
    if(this.evolved) return;
    this.evolved=true;
    this._evoFxUntil=Date.now()+650;
    // passive is enabled by this.evolved flag, no stat changes
  }


  // Rallentamento temporaneo (usato da alcuni nemici/boss)
  // pct: 0.20 = -10% velocit√†. durationMs in millisecondi.
  applySlow(pct, durationMs){
    const now=Date.now();
    const p=Math.max(0, Math.min(0.60, pct||0)); // cap 60% (Boss5 usa 50%)
    this._slowPct = Math.min(0.60, Math.max(this._slowPct||0, p));
    this._slowUntil = Math.max(this._slowUntil||0, now + (durationMs||0));
  }

  findClosestEnemy(radius=this.aimAssistRadius){
    let closest=null;let best=radius;
    enemies.forEach(e=>{
      const dx=(e.x+e.width/2)-(this.x+this.width/2);
      const dy=(e.y+e.height/2)-(this.y+this.height/2);
      const dist=Math.hypot(dx,dy);
      if(dist<best){best=dist;closest=e}
    });
    return closest;
  }

  update(){
    const now=Date.now();

    if(this.shieldBroken&&now-this.shieldBrokenTime>this.shieldRegenMs){
      this.shieldBroken=false;this.shieldDurability=this.shieldMaxDurability
    }
    if(this.attackBuffUntil && now>this.attackBuffUntil){this.attackBuffMultiplier=1;this.attackBuffUntil=0}
    if(this._slowUntil && now>this._slowUntil){ this._slowUntil=0; this._slowPct=0; }
    if(this.speedBuffUntil && now>this.speedBuffUntil){
      this.speed=this._baseSpeed;this.speedBuffUntil=0;this.isJetpacking=false;this.invulnerable=false
    }
    // Bane SUPER speed boost handling (independent from pickups)
    if(this.type==='bane'){
      if(this.baneSuperSpeedUntil && now < this.baneSuperSpeedUntil){
        this.speed = Math.max(this.speed, this._baseSpeed * 1.25);
      } else if(this.baneSuperSpeedUntil && now >= this.baneSuperSpeedUntil){
        this.baneSuperSpeedUntil = 0;
        // if no other speed buff is active, restore base speed
        if(!(this.speedBuffUntil && now < this.speedBuffUntil)){
          this.speed = this._baseSpeed;
        }
      }
    }

    if(this.pickupShieldUntil && now>this.pickupShieldUntil){this.pickupShieldUntil=0;this.invulnerable=false}

    // Furia heal-over-time (+10 HP/s for 10s)
    if(this.furiaHealUntil && now < this.furiaHealUntil){
      if(!this.furiaLastHeal) this.furiaLastHeal = now;
      if(now - this.furiaLastHeal >= 1000){
        this.furiaLastHeal = now;
        this.hp = Math.min(this.maxHP, this.hp + 10);
        createParticles(this.x+this.width/2, this.y+this.height/2, '#ff00ff', 8, 3);
      }
    } else {
      this.furiaLastHeal = 0;
      this.furiaHealUntil = 0;
    }

    // Jimmy jetpack passive
    if(this.type==='jimmy'){
      if(!this.isJetpacking && now-this.lastJetpack>=this.jetpackCooldown && !this.isDoingSuper){
        this.isJetpacking=true;
        this.lastJetpack=now;
        this.invulnerable=true;
        this.speed=this._baseSpeed * this._jetpackSpeedMultiplier;
        this.speedBuffUntil=now+this.jetpackDuration;
      }
      if(this.isJetpacking && now>=this.speedBuffUntil){
        this.isJetpacking=false;
        this.invulnerable=false;
        this.speed=this._baseSpeed;
      }
    }


    // Salsy passive: speed boost every 12s for 2s (DOUBLES BASE SPEED ONLY)
    if(this.type==='salsy'){
      if(!this._salsyBoostCooldown){
        this._salsyBoostCooldown = 12000;
        this._salsyBoostDuration = 2000;
        this.lastSalsyBoost = now - this._salsyBoostCooldown;
        this.salsyBoostUntil = 0;
      }

      if(!this.isDoingSuper && now - this.lastSalsyBoost >= this._salsyBoostCooldown){
        this.lastSalsyBoost = now;
        this.salsyBoostUntil = now + this._salsyBoostDuration;
      }

      if(this.salsyBoostUntil && now < this.salsyBoostUntil){
        // SOLO velocit√† base raddoppiata
        this.speed = this._baseSpeed * 2;
      }
      else if(this.salsyBoostUntil && now >= this.salsyBoostUntil){
        this.salsyBoostUntil = 0;

        // Ripristino corretto
        if(this.speedBuffUntil && now < this.speedBuffUntil){
          this.speed = this._baseSpeed * 1.5;
        } else {
          this.speed = this._baseSpeed;
        }
      }
    }

    // Poison

    if(this.poisonUntil && now < this.poisonUntil){
      if(!this.poisonTickLast) this.poisonTickLast = now;
      if(now - this.poisonTickLast >= 1000){
        this.poisonTickLast = now;
        this.hp = Math.max(0, this.hp - (this.poisonTickDamage||1));
        createParticles(this.x,this.y,'#8b0000',6,3);
        if(this.hp<=0 && gameState==='playing') endGame(false);
      }
    } else this.poisonTickLast = 0;

    // Movement
    let moveX=0,moveY=0;
    if(!this.isGrappling){
      if(keys['a']){moveX=-1;this.facingRight=false}
      if(keys['d']){moveX=1;this.facingRight=true}
      if(keys['w'])moveY=-1;
      if(keys['s'])moveY=1
    }
    if(moveX!==0&&moveY!==0){moveX*=0.707;moveY*=0.707}

    // aggiorna direzione di mira (per attacchi in tutte le direzioni)
    if(moveX!==0 || moveY!==0){
      const len=Math.hypot(moveX,moveY)||1;
      this.aimX=moveX/len;
      this.aimY=moveY/len;
    }

    // Kaerith (J) - Attacco continuo a ventaglio stretto (30¬∞) con danno progressivo per bersaglio
    if(this.type==='kaerith'){
      if(keys['j'] && !this.isDoingSuper){
        if(!this._kaerithFlame){
          this._kaerithFlame={
            start: now,
            lastPulse: 0,
            pulseMs: 90,
            range: 294,                 // molto lungo
            angle: Math.PI/6,           // 30¬∞
            dir:(()=>{  if(typeof enemies!=='undefined' && enemies && enemies.length){    const pcx=this.x+this.width/2, pcy=this.y+this.height/2;    let best=null, bestD=1e18;    for(const e of enemies){      const ex=e.x+e.width/2, ey=e.y+e.height/2;      const d=(ex-pcx)*(ex-pcx)+(ey-pcy)*(ey-pcy);      if(d<bestD){bestD=d; best={x:ex,y:ey};}    }    if(best) return Math.atan2(best.y-pcy, best.x-pcx);  }  return Math.atan2(this.aimY||0, this.aimX||1);})()
          };
        } else {
          this._kaerithFlame.dir = (()=>{  if(typeof enemies!=='undefined' && enemies && enemies.length){    const pcx=this.x+this.width/2, pcy=this.y+this.height/2;    let best=null, bestD=1e18;    for(const e of enemies){      const ex=e.x+e.width/2, ey=e.y+e.height/2;      const d=(ex-pcx)*(ex-pcx)+(ey-pcy)*(ey-pcy);      if(d<bestD){bestD=d; best={x:ex,y:ey};}    }    if(best) return Math.atan2(best.y-pcy, best.x-pcx);  }  return Math.atan2(this.aimY||0, this.aimX||1);})();
        }
      } else {
        this._kaerithFlame=null;
      }
    }


    // Marz super bonus: +50% speed while inside the magic zone
    const marzZoneMult = (this.type==='marz' && isPointInsideMagicZone(this.x+this.width/2, this.y+this.height/2)) ? 1.5 : 1;

    if(this.isDashing){
      const speedNow=this.speed*marzZoneMult*(1-(this._slowPct||0));
      const dashSpeed=speedNow*(this._dashSpeedMult||3);
      this.vx=(this.facingRight?1:-1)*dashSpeed;
      if(this.type==='kouvagia' && this._kouvagiaDashActive){this.vy=0;}

      // Kouvagia: deal damage during dash (tick-based)
      if(this.type==='kouvagia' && this._kouvagiaDashActive){
        if(this._kouvagiaDashHitCd<=0){
          this._kouvagiaDashHitCd=4; // roughly every few frames
          for(let i=enemies.length-1;i>=0;i--){
            const e=enemies[i];
            const dist=Math.hypot((e.x+e.width/2)-(this.x+this.width/2),(e.y+e.height/2)-(this.y+this.height/2));
            if(dist<110){
              const dmg=Math.round(40*this.attackBuffMultiplier*(this.baneSuperAttackMult||1));
              const _dmg=dmg; const _final=applyEnemyDamage(e,_dmg);
              createParticles(e.x,e.y,'#e84393',10,5);
              showDamageNumber(e.x,e.y, _final);
              if(e.hp<=0){
                createParticles(e.x,e.y,'#fff176',30,6);
                dropStellarBonusAtIndexIfNeeded(i);
                enemies.splice(i,1);
                applyScore(100*currentLevel);
                addKill(); this._baneSuperOnKill();
                if(this.type==='kouvagia'){this.hp=Math.min(this.maxHP,this.hp+3);createParticles(this.x,this.y,'#2ecc71',6,3);}
              }
            }
          }
        }else this._kouvagiaDashHitCd--;
      }
      if(now-this.dashTime>(this._dashDuration||200)){
        this.isDashing=false; this.vx=0; this.vy=0; this._dashSpeedMult=3; this._dashDuration=200; if(this.type==='kouvagia'){this._kouvagiaDashActive=false;}
        // Kouvagia: explosion at end of dash
        if(this.type==='kouvagia' && this._kouvagiaExplosionPending){
          this._kouvagiaExplosionPending=false;
    this._kouvagiaSuperFxStart=0;
    this._kouvagiaSuperFxUntil=0;
          this._kouvagiaDashActive=false;
          for(let i=enemies.length-1;i>=0;i--){
            const e=enemies[i];
            const dist=Math.hypot((e.x+e.width/2)-(this.x+this.width/2),(e.y+e.height/2)-(this.y+this.height/2));
            if(dist<165){
              const dmg=Math.round(65*this.attackBuffMultiplier*(this.baneSuperAttackMult||1));
              const _dmg=dmg; const _final=applyEnemyDamage(e,_dmg);
              createParticles(e.x,e.y,'#fd79a8',16,5);
              showDamageNumber(e.x,e.y, _final);
              if(e.hp<=0){
                createParticles(e.x,e.y,'#fff176',30,6);
                dropStellarBonusAtIndexIfNeeded(i);
                enemies.splice(i,1);
                applyScore(100*currentLevel);
                addKill(); this._baneSuperOnKill();
                if(this.type==='kouvagia'){this.hp=Math.min(this.maxHP,this.hp+3);createParticles(this.x,this.y,'#2ecc71',6,3);}
              }
            }
          }
          shakeScreen();
        }

      }
    } else if(!this.isGrappling){
      const speedNow=this.speed*marzZoneMult*(1-(this._slowPct||0));
      this.vx=moveX*speedNow+this.vx*0.1;
            this.vy=moveY*speedNow+this.vy*0.1;
    }

    // Grapple chase
    // Jimmy grapple rework:
    // - L'attacco base NON "si attacca" al bersaglio: Jimmy si avvicina e si ferma a pochi pixel.
    // - Quando √® abbastanza vicino, esegue un colpo a ventaglio (120¬∞) con raggio 90.
    if(this.isGrappling&&this.grappleTarget){
      if(!enemies.includes(this.grappleTarget)){
        this.isGrappling=false;this.grappleTarget=null;this.grappleStartTime=0;
      } else {
        const pcx=this.x+this.width/2, pcy=this.y+this.height/2;
        const tcx=this.grappleTarget.x+this.grappleTarget.width/2, tcy=this.grappleTarget.y+this.grappleTarget.height/2;
        const dx=tcx-pcx;const dy=tcy-pcy;
        const dist=Math.hypot(dx,dy);const speedMult=5;

        const stopDist=62; // "un po' di pixel" dal nemico
        if(dist>stopDist){
          this.vx=(dx/(dist||1))*this.speed*marzZoneMult*speedMult;
          this.vy=(dy/(dist||1))*this.speed*marzZoneMult*speedMult;
        } else {
          // Fan hit: 120¬∞ cone, radius 90 (small hit)
          const dirAngle=Math.atan2(dy,dx);
          const arcWidth=Math.PI*(120/180);
          const radius=90;

          const baseDmg=Math.round(this.damage*0.65*this.attackBuffMultiplier*(this.baneSuperAttackMult||1));

          let killedGrappleTarget=false;

          for(let i=enemies.length-1;i>=0;i--){
            const e=enemies[i];
            const ex=e.x+e.width/2, ey=e.y+e.height/2;
            const edx=ex-pcx, edy=ey-pcy;
            const edist=Math.hypot(edx,edy);
            if(edist<=radius){
              const ang=Math.atan2(edy,edx);
              let diff=ang-dirAngle;
              while(diff>Math.PI) diff-=Math.PI*2;
              while(diff<-Math.PI) diff+=Math.PI*2;
              if(Math.abs(diff)<=arcWidth/2){
                const _final=applyEnemyDamage(e, baseDmg);
                createParticles(e.x,e.y,'#e74c3c',14,5);
                showDamageNumber(e.x,e.y,_final);
                if(e.hp<=0){
                  if(e===this.grappleTarget) killedGrappleTarget=true;
                  createParticles(e.x,e.y,'#fff176',30,6);
                  dropStellarBonusAtIndexIfNeeded(i);
                  enemies.splice(i,1);
                  applyScore(100*currentLevel);
                addKill(); this._baneSuperOnKill();
                }
              }
            }
          }

          // Jimmy EVO passive: next grapple has -20% cooldown after a grappled target dies
          if(this.type==='jimmy' && this.evolved && killedGrappleTarget){ this._jimmyNextGrappleCdMult=0.8; }

          this.isGrappling=false;this.grappleTarget=null;this.vx=0;this.vy=0;this.grappleStartTime=0;
        }
      }
    }

    // Super handling
    if(this.isDoingSuper){
      const elapsed=now-this.superStartTime;
      if(this.type==='jimmy'){this.invulnerable=true;this.shieldActive=true}

      if(this.attackType==='punch'){
        if(!this._superHitDone&&elapsed>=300){
          this._superHitDone=true;
          if(this.type==='rooney'){
            // Rooney SUPER (rework):
            // - Area QUADRATA centrata su Rooney.
            // - Danno totale massimo: 300 (senza buff) distribuito tra TUTTI i nemici nell'area.
            // - Falloff: pi√π un nemico √® lontano dal centro, meno danno subisce.
            const half=200; // mezzo lato del quadrato (lato=400)
            const px=this.x+this.width/2, py=this.y+this.height/2;
            const hits=[];
            const maxDist=Math.hypot(half,half) || 1;

            for(const enemy of enemies){
              const ex=enemy.x+enemy.width/2, ey=enemy.y+enemy.height/2;
              const dx=ex-px, dy=ey-py;
              if(Math.abs(dx)<=half && Math.abs(dy)<=half){
                const dist=Math.hypot(dx,dy);
                const w=Math.max(0.20, 1 - (dist/maxDist)); // minimo 10% al bordo
                hits.push({enemy,w, dist});
              }
            }

            if(hits.length>0){
              // Compensiamo SUPER_DAMAGE_MULT cos√¨ che la SOMMA dei danni (senza buff) sia 300.
              const totalBase=Math.round(350 / SUPER_DAMAGE_MULT);
              const sumW=hits.reduce((a,h)=>a+h.w,0) || 1;

              for(const h of hits){
                const share=h.w/sumW;
                const raw=totalBase*share;
                const dmg=Math.max(6, Math.round(raw * SUPER_DAMAGE_MULT * this.attackBuffMultiplier));
                const _final=applyEnemyDamage(h.enemy, dmg);

                // Hit FX
                createParticles(h.enemy.x,h.enemy.y,'#f39c12',22,6);
                showDamageNumber(h.enemy.x,h.enemy.y, _final);
              }

              // Ground-break FX (debris + dust) nell'area quadrata
              createParticles(px,py,'#795548',55,8);
              for(let k=0;k<12;k++){
                const rx=px + (Math.random()*2-1)*half;
                const ry=py + (Math.random()*2-1)*half;
                createParticles(rx,ry,'#6d4c41',14,6);
                createParticles(rx,ry,'#b0bec5',8,4);
              }

              // rimuovi i morti (e assegna score) subito, come per le altre super
              for(let i=enemies.length-1;i>=0;i--){
                if(enemies[i].hp<=0){
                  createParticles(enemies[i].x,enemies[i].y,'#fff176',30,6);
                  dropStellarBonusAtIndexIfNeeded(i);
                  enemies.splice(i,1);
                  applyScore(100*currentLevel);
                addKill(); this._baneSuperOnKill();
                }
              }
            }
          } else {
            enemies.forEach((enemy,idx)=>{
              const dist=Math.hypot(enemy.x-this.x,enemy.y-this.y);
              if(dist<350){
                const base=(this.type==='jimmy')?300:140;
                const mult=(this.type==='jimmy')?(SUPER_DAMAGE_MULT*JIMMY_SUPER_ADDITIONAL_MULT):SUPER_DAMAGE_MULT;
                let extra=1;if(this.type==='rooney'&&dist<150)extra=1.5;
                const dmg=Math.round(base*mult*extra*this.attackBuffMultiplier*(this.baneSuperAttackMult||1));
                const _dmg=dmg; const _final=applyEnemyDamage(enemy,_dmg);
                createParticles(enemy.x,enemy.y,'#f39c12',30,6);
                showDamageNumber(enemy.x,enemy.y, _final);
                if(enemy.hp<=0){
  if(player && player.type==='jeff' && player.evolved){
    player.hp = Math.min(player.maxHp, player.hp + 5);
  }
                  createParticles(enemy.x,enemy.y,'#fff176',30,6);
                  // IRA kill special FX (Bane SUPER)
                  if(player && player.type==='bane' && Date.now() < player.baneSuperUntil){
                    createIraKillFX(enemy.x, enemy.y);
                  }
                  dropStellarBonusAtIndexIfNeeded(idx);
                  enemies.splice(idx,1);
                  applyScore(100*currentLevel);addKill(); this._baneSuperOnKill();
                }
              }
            });
          }
          shakeScreen();
        }
        if(elapsed>=this.superDuration)this.endSuper();

            } else if(this.attackType==='grapple'){
        // Jimmy SUPER rework:
        // - NON si aggrappa ai nemici (niente "stop" sul bersaglio).
        // - Jimmy li attraversa (pass-through) e applica lo stesso colpo/danni quando li raggiunge.
        const chaseSpeed=this.speed*6;

        // Se siamo nel "pass-through window", continua dritto nella direzione salvata
        if(this._superGrapplePassUntil && now < this._superGrapplePassUntil){
          this.vx=this._superGrappleDirX*chaseSpeed;
          this.vy=this._superGrappleDirY*chaseSpeed;
        } else {
          this._superGrapplePassUntil=0;

          if(this.superTargets.length>0){
            const target=this.superTargets[0];
            if(!enemies.includes(target)){
              this.superTargets.shift();
            } else {
              const px=this.x+this.width/2, py=this.y+this.height/2;
              const tx=target.x+target.width/2, ty=target.y+target.height/2;
              const dx=tx-px;const dy=ty-py;
              const dist=Math.hypot(dx,dy);

              if(dist>50){
                this.vx=(dx/(dist||1))*chaseSpeed;
                this.vy=(dy/(dist||1))*chaseSpeed;
              } else {
                // hit once, then keep moving forward briefly (pass-through)
                const base=120;
                const mult=(this.type==='jimmy')?(SUPER_DAMAGE_MULT*JIMMY_SUPER_ADDITIONAL_MULT):SUPER_DAMAGE_MULT;
                const dmg=Math.round(base*mult*this.attackBuffMultiplier*(this.baneSuperAttackMult||1)*(this.type==='jimmy'?2.0:1));
                const _final=applyEnemyDamage(target, dmg);
                createParticles(target.x,target.y,'#e74c3c',15,6);
                showDamageNumber(target.x,target.y, _final);
                if(target.hp<=0){
                  createParticles(target.x,target.y,'#fff176',30,6);
                  const idx=enemies.indexOf(target);
                  if(idx>-1){dropStellarBonusAtIndexIfNeeded(idx);enemies.splice(idx,1);applyScore(100*currentLevel);addKill(); this._baneSuperOnKill();
                }
                }

                // store direction and move through (no interaction/stop)
                let nx=dx/(dist||1), ny=dy/(dist||1);
                if(!isFinite(nx) || !isFinite(ny)){ nx=this.facingRight?1:-1; ny=0; }
                this._superGrappleDirX=nx; this._superGrappleDirY=ny;
                this._superGrapplePassUntil=now+160;

                // next target
                this.superTargets.shift();
                this._superPhase=Date.now();
              }
            }
          } else {
            if(now-this.superStartTime>=Math.min(this.superDuration,1200))this.endSuper();
          }
        }
      } else if(this.attackType==='sword'){
        if(elapsed>=0&&elapsed<this.superDuration){
          if(!this._lastSwordTick||now-this._lastSwordTick>=180){
            this._lastSwordTick=now;
            enemies.forEach((enemy,idx)=>{
              const dist=Math.hypot(enemy.x-this.x,enemy.y-this.y);
              if(dist<JEFF_SUPER_RADIUS){
                const tickDmg=Math.round(28*SUPER_DAMAGE_MULT);
                const _dmg=tickDmg; const _final=applyEnemyDamage(enemy,_dmg);
                createParticles(enemy.x,enemy.y,'#9b59b6',8,4);
                showDamageNumber(enemy.x,enemy.y, _final);
                if(enemy.hp<=0){
  if(player && player.type==='jeff' && player.evolved){
    player.hp = Math.min(player.maxHp, player.hp + 5);
  }
                  createParticles(enemy.x,enemy.y,'#fff176',30,6);
                  dropStellarBonusAtIndexIfNeeded(idx);
                  enemies.splice(idx,1);
                  applyScore(100*currentLevel);addKill(); this._baneSuperOnKill();
                }
              }
            });
          }
        } else this.endSuper();

      
      } else if(this.attackType==='salsySword'){
        if(elapsed>=this.superDuration) this.endSuper();

      
    } else if(this.attackType==='axeattack'){
      // BANE axe wide swing: 270¬∞ fan, hits max 2 enemies
      const attackAngle = this.facingRight ? 0 : Math.PI;
      const arcWidth = Math.PI * 1.5; // 270 degrees
      let hits = 0;
      // sort enemies by distance (closer hit first)
      const sorted = enemies.slice().sort((a,b)=>{
        const da=Math.hypot(a.x-this.x,a.y-this.y);
        const db=Math.hypot(b.x-this.x,b.y-this.y);
        return da-db;
      });
      sorted.forEach(enemy=>{
        if(hits>=2) return;
        const dx=enemy.x-this.x;
        const dy=enemy.y-this.y;
        const dist=Math.hypot(dx,dy);
        const angle=Math.atan2(dy,dx);
        let angleDiff=angle-attackAngle;
        while(angleDiff>Math.PI) angleDiff-=Math.PI*2;
        while(angleDiff<-Math.PI) angleDiff+=Math.PI*2;
        if(dist < this.range && Math.abs(angleDiff) < arcWidth/2){
          const superMult = (this.type==='bane' && this.baneSuperUntil && now < this.baneSuperUntil) ? (this.baneSuperAttackMult||1) : 1;
          const base = this.damage * this.attackBuffMultiplier * superMult;
          const dmg = applyEnemyDamage(enemy, base);
          createParticles(enemy.x,enemy.y,'#c0392b',14,6);
          showDamageNumber(enemy.x,enemy.y,dmg);
          hits++;
          if(enemy.hp<=0){
            createParticles(enemy.x,enemy.y,'#fff176',30,6);
            dropStellarBonusAtIndexIfNeeded(enemies.indexOf(enemy));
            enemies.splice(enemies.indexOf(enemy),1);
            applyScore(100*currentLevel);
          addKill(); this._baneSuperOnKill();
                }
        }
      });


    } else if(this.attackType==='lucienBlade'){
        if(elapsed>=this.superDuration) this.endSuper();

      } else if(this.attackType==='kouvagia'){
        if(elapsed>=this.superDuration) this.endSuper();
} else if(this.attackType==='hybrid'){

        if(now - this.superStartTime >= this.superDuration){
          this.endSuper();
        }
      } else if(this.attackType==='tempostormLaser'){
        // Tempostorm SUPER is applied instantly in superAttack(); keep VFX only for superDuration.
        if(elapsed>=this.superDuration){
          this.endSuper();
        }
      } else if(this.attackType==='hecateBow'){
        // H√®cate SUPER: heal happens instantly; keep short FX then end.
        if(elapsed>=this.superDuration){
          this.endSuper();
        }
      } else if(this.attackType==='magic'){
        // Freeze is applied instantly in superAttack(); keep VFX only for superDuration.
        if(elapsed>=this.superDuration){
          this.endSuper();
        }
      }
    }
    

    // handle Kaerith continuous fan attack (per-target progressive damage, max 90)
    if(this.type==='kaerith' && this._kaerithFlame){
      const F=this._kaerithFlame;
      const now2=Date.now();

      if(!F.lastPulse) F.lastPulse = now2;
      if(now2 - F.lastPulse >= F.pulseMs){
        F.lastPulse = now2;

        const pcx=this.x+this.width/2, pcy=this.y+this.height/2;
        // Aim-assist: orienta il ventaglio verso il nemico pi√π vicino (se presente)
        if(enemies && enemies.length){
          let best=null, bestD=1e18;
          for(const e of enemies){
            const ex=e.x+e.width/2, ey=e.y+e.height/2;
            const d=(ex-pcx)*(ex-pcx)+(ey-pcy)*(ey-pcy);
            if(d<bestD){bestD=d; best={x:ex,y:ey};}
          }
          if(best){ F.dir=Math.atan2(best.y-pcy, best.x-pcx); }
        }
        const dir=F.dir;
        const arc=F.angle;
        const r=F.range;

        // Track per-enemy "time inside cone" (reset quickly if leaves)
        for(let i=enemies.length-1;i>=0;i--){
          const e=enemies[i];
          const ex=e.x+e.width/2, ey=e.y+e.height/2;
          const dx=ex-pcx, dy=ey-pcy;
          const dist=Math.hypot(dx,dy);

          let inside=false;
          if(dist<=r){
            const ang=Math.atan2(dy,dx);
            let diff=ang-dir;
            while(diff>Math.PI) diff-=Math.PI*2;
            while(diff<-Math.PI) diff+=Math.PI*2;
            if(Math.abs(diff)<=arc/2) inside=true;
          }

          if(inside){
            // start/continue inside timer
            if(!e._kaerithInsideSince || (e._kaerithLastInside && (now2 - e._kaerithLastInside)>220)){
              e._kaerithInsideSince = now2;
            }
            e._kaerithLastInside = now2;

            const insideSec = Math.max(0, (now2 - e._kaerithInsideSince)/1000);

            // Progressive damage: starts low, ramps up while the SAME enemy stays inside, caps at 90
            const base = 12;
            const slope = 20; // reaches cap ~4s
            const dmg = Math.min(90, Math.round(base + insideSec * slope));

            const final = applyEnemyDamage(e, dmg * (this.attackBuffMultiplier||1) * (this.baneSuperAttackMult||1));
            showDamageNumber(e.x, e.y, final);
            createParticles(ex, ey, '#ff3d00', 6, 3);

            if(e.hp<=0){
              createParticles(e.x,e.y,'#fff176',30,6);
              dropStellarBonusAtIndexIfNeeded(i);
              enemies.splice(i,1);
              applyScore(100*currentLevel);
              addKill(); if(this._baneSuperOnKill) this._baneSuperOnKill();
            }
          } else {
            // reset if outside for a short moment
            if(e._kaerithLastInside && (now2 - e._kaerithLastInside)>260){
              e._kaerithLastInside=0;
              e._kaerithInsideSince=0;
            }
          }
        }
      }
    }
// === Kaerith SUPER DoT: Infuocato (progressivo 5 -> 25) ===
if(this.type==='kaerith' && this._kaerithFireUntil && Date.now() < this._kaerithFireUntil){
  const nowF = Date.now();
  if(!this._kaerithFireLastTick) this._kaerithFireLastTick = nowF;
  if(nowF - this._kaerithFireLastTick >= 1000){
    this._kaerithFireLastTick = nowF;

    const elapsedSec = Math.floor((nowF - (this._kaerithFireStart||nowF))/1000);
    // progressione: 5 al secondo 0, fino a 25 entro 8s (cap 25)
    const prog = Math.min(19, Math.round(4 + (elapsedSec * (15/8))));
    const dmg = Math.max(0, prog);

    if(typeof enemies!=='undefined' && enemies && enemies.length){
      for(const e of enemies){
        if(e && typeof e.hp==='number' && e.hp>0){
          e.hp -= dmg;
          // piccolo feedback visivo (brace/ember)
          createParticles(e.x+e.width/2, e.y+e.height/2, '#ff6d00', 6, 3);
        }
      }
    }
  }
}



// handle Hendel hammer sweep (clockwise 75¬∞)
    if(this.type==='hendel' && this._hammerSwing){
      const H=this._hammerSwing;
      const now2=Date.now();
      const t=Math.max(0, Math.min(1, (now2 - H.start)/H.duration));

      // end
      if(t>=1){ this._hammerSwing=null; }
      else if(enemies && enemies.length){
        // clockwise: from baseAng + arc/2 down to baseAng - arc/2
        const angStart = H.baseAng + H.arc/2;
        const angEnd   = H.baseAng - H.arc/2;
        const ang = angStart + (angEnd - angStart) * t;

        const cx=this.x+this.width/2;
        const cy=this.y+this.height/2;

        const cos=Math.cos(ang), sin=Math.sin(ang);
        // rotate world->local by -ang: x' = dx*cos + dy*sin, y' = -dx*sin + dy*cos
        // NOTE: this swing can hit ONLY ONE opponent total
        for(let i=enemies.length-1;i>=0;i--){
          if(H.hitDone) break;
          const e=enemies[i];
          if(H.hitSet && H.hitSet.has(e)) continue;

          const ex=e.x+e.width/2;
          const ey=e.y+e.height/2;
          const dx=ex-cx, dy=ey-cy;

          const lx = dx*cos + dy*sin;
          const ly = -dx*sin + dy*cos;

          const inHandle =
            (lx >= H.handleStart && lx <= (H.handleStart + H.handleLen) &&
             Math.abs(ly) <= (H.handleW/2));

          const hs = H.headSize;
          const hx0 = H.headOffset - hs/2;
          const hx1 = H.headOffset + hs/2;
          const inHead =
            (lx >= hx0 && lx <= hx1 &&
             Math.abs(ly) <= (hs/2));

          if(inHandle || inHead){
            if(H.hitSet) H.hitSet.add(e);

            // Only one enemy per swing
            H.hitDone = true;

            // Stun for 0.5s
            e.stunnedUntil = Date.now() + 500;

            const dmgBase = 120 * (this.attackBuffMultiplier||1) * (this.baneSuperAttackMult||1);
            const final = applyEnemyDamage(e, dmgBase);

            showDamageNumber(e.x, e.y, final);
            createParticles(ex, ey, '#ff8c1a', 18, 5);

            if(e.hp<=0){
              createParticles(e.x,e.y,'#fff176',30,6);
              dropStellarBonusAtIndexIfNeeded(i);
              enemies.splice(i,1);
              applyScore(100*currentLevel);
              addKill(); if(this._baneSuperOnKill) this._baneSuperOnKill();
            }
          }
        }
      }
    }

    // integrate velocity

    this.x+=this.vx;this.y+=this.vy;
    if(!keys['a']&&!keys['d']&&!this.isDashing&&!this.isGrappling)this.vx*=0.86;
    if(!keys['w']&&!keys['s']&&!this.isGrappling)this.vy*=0.86;

    const margin=10;
    const push=10;
    let hitWall=false;
    const B=getPlayBounds();

    const left=B.left+margin, right=B.right-margin;
    const top=B.top+margin, bottom=B.bottom-margin;

    if(this.x<left){ this.x=left+push; hitWall=true; }
    if(this.x+this.width>right){ this.x=right-this.width-push; hitWall=true; }
    if(this.y<top){ this.y=top+push; hitWall=true; }
    if(this.y+this.height>bottom){ this.y=bottom-this.height-push; hitWall=true; }

    if(hitWall){ createParticles(this.x+this.width/2,this.y+this.height/2,'#90caf9',6,3); }

    if(this.dashCooldown>0)this.dashCooldown--;

    if(this.attacking&&Date.now()-this.attackTime>300){
      this.attacking=false;
      if(this.type==='jimmy'&&this.shieldActive&&!this.isDoingSuper){
        this.shieldActive=false;
      }
    }
  }

  dodge(){
    if(this.dashCooldown<=0&&!this.isDoingSuper){
      this.isDashing=true;this.dashTime=Date.now();

      // Kouvagia passive: dodge deals 10 damage to nearby enemies
      if(this.type==='kouvagia'){
        for(let i=enemies.length-1;i>=0;i--){
          const e=enemies[i];
          const dist=Math.hypot((e.x+e.width/2)-(this.x+this.width/2),(e.y+e.height/2)-(this.y+this.height/2));
          if(dist<95){
            const _dmg=10; const _final=applyEnemyDamage(e,_dmg);
            createParticles(e.x,e.y,'#ff7675',8,4);
            showDamageNumber(e.x,e.y, _final);
            if(e.hp<=0){
              createParticles(e.x,e.y,'#fff176',30,6);
              dropStellarBonusAtIndexIfNeeded(i);
              enemies.splice(i,1);
              applyScore(100*currentLevel);
                addKill(); this._baneSuperOnKill();
                if(this.type==='kouvagia'){this.hp=Math.min(this.maxHP,this.hp+3);createParticles(this.x,this.y,'#2ecc71',6,3);}
            }
          }
        }
      }
      if(this.type==='jimmy' || this.type==='voltryx' || this.type==='kouvagia' || this.type==='hecate' || this.type==='lucien'){
        this._dashSpeedMult=4;
        this._dashDuration=300;
        this.dashCooldown=90;
      } else {
        this._dashSpeedMult=3;
        this._dashDuration=200;
        this.dashCooldown=90;
      }
    }
  }

  attack(){
    const now=Date.now();
    if(now-this.lastAttack<this.cooldown||this.isDoingSuper)return false;
    // Jimmy EVO passive: if unlocked, the next grapple gets -20% cooldown (only for that next grapple)
    if(this.type==='jimmy' && this.evolved && this.attackType==='grapple' && this._jimmyNextGrappleCdMult && this._jimmyNextGrappleCdMult<1){
      const mult=this._jimmyNextGrappleCdMult;
      this.lastAttack = now - Math.round(this.cooldown*(1-mult));
      this._jimmyNextGrappleCdMult=1;
    } else {
      this.lastAttack=now;
    }
    this.attacking=true;this.attackTime=now;

    if(this.type==='jimmy'&&!this.shieldBroken){this.shieldActive=true;}

    const assistTarget=this.findClosestEnemy();
    if(assistTarget){
      const dx=(assistTarget.x+assistTarget.width/2)-(this.x+this.width/2);
      this.facingRight=dx>=0;
      const dist=Math.hypot(dx,(assistTarget.y+assistTarget.height/2)-(this.y+this.height/2));
      if(dist>10){
        const nx=dx/dist;
        const ny=((assistTarget.y+assistTarget.height/2)-(this.y+this.height/2))/dist;
        this.vx+=nx*this.speed*this.aimAssistStrength;
        this.vy+=ny*this.speed*this.aimAssistStrength;
      }
    }

    if(this.attackType==='punch'){
      if(this.type==='rooney'){
        const multipliers=[1,1.15,1.25];
        for(let i=0;i<3;i++){
          setTimeout(((idx)=>{
            return ()=>{
              let closestEnemy=null;let closestDist=this.range+40;
              enemies.forEach(enemy=>{
                const dx=enemy.x-this.x;const dy=enemy.y-this.y;
                const dist=Math.hypot(dx,dy);
                if(dist<closestDist&&Math.abs(dy)<220){closestDist=dist;closestEnemy=enemy}
              });
              if(closestEnemy){
                const baseDmg=this.damage;
                const dmg=Math.round(baseDmg * multipliers[idx] * this.attackBuffMultiplier);
                const _dmg=dmg; const _final=applyEnemyDamage(closestEnemy,_dmg);
                createParticles(closestEnemy.x,closestEnemy.y,'#e67e22',12,5);
                showDamageNumber(closestEnemy.x,closestEnemy.y, _final);
                if(closestEnemy.hp<=0){
                  createParticles(closestEnemy.x,closestEnemy.y,'#fff176',30,6);
                  const idxEnemy=enemies.indexOf(closestEnemy);
                  if(idxEnemy>-1){dropStellarBonusAtIndexIfNeeded(idxEnemy);enemies.splice(idxEnemy,1);applyScore(100*currentLevel);addKill(); this._baneSuperOnKill();
                }
                }
              }
            };
          })(i), i*240);
        }
      } else {
        let closestEnemy=null;let closestDist=this.range;
        enemies.forEach(enemy=>{
          const dx=enemy.x-this.x;const dy=enemy.y-this.y;
          const dist=Math.hypot(dx,dy);
          if(dist<closestDist&&Math.abs(dy)<220){closestDist=dist;closestEnemy=enemy}
        });
        if(closestEnemy){
          const dmg=Math.round(this.damage*this.attackBuffMultiplier*(this.baneSuperAttackMult||1));
          const _dmg=dmg; const _final=applyEnemyDamage(closestEnemy,_dmg);
          createParticles(closestEnemy.x,closestEnemy.y,'#e67e22',12,5);
          showDamageNumber(closestEnemy.x,closestEnemy.y, _final);
          if(closestEnemy.hp<=0){
            createParticles(closestEnemy.x,closestEnemy.y,'#fff176',30,6);
            dropStellarBonusAtIndexIfNeeded(enemies.indexOf(closestEnemy));
            enemies.splice(enemies.indexOf(closestEnemy),1);
            applyScore(100*currentLevel);
          addKill(); this._baneSuperOnKill();
                }
        } else if(assistTarget){
          const distA=Math.hypot((assistTarget.x-this.x),(assistTarget.y-this.y));
          if(distA<this.range+240){
            const dmg=Math.round(this.damage*0.9*this.attackBuffMultiplier*(this.baneSuperAttackMult||1));
            const _dmg=dmg; const _final=applyEnemyDamage(assistTarget,_dmg);
            createParticles(assistTarget.x,assistTarget.y,'#e67e22',12,5);
            showDamageNumber(assistTarget.x,assistTarget.y, _final);
            if(assistTarget.hp<=0){
              createParticles(assistTarget.x,assistTarget.y,'#fff176',30,6);
              dropStellarBonusAtIndexIfNeeded(enemies.indexOf(assistTarget));
              enemies.splice(enemies.indexOf(assistTarget),1);
              applyScore(100*currentLevel);
            addKill(); this._baneSuperOnKill();
                }
          }
        }
      }

    } else if(this.attackType==='grapple'){
      let closestEnemy=assistTarget;
      if(!closestEnemy){
        let closestDist=this.range;
        enemies.forEach(enemy=>{
          const dist=Math.hypot(enemy.x-this.x,enemy.y-this.y);
          if(dist<closestDist){closestDist=dist;closestEnemy=enemy}
        })
      }
      if(closestEnemy){
        this.grappleTarget=closestEnemy;this.isGrappling=true;this.grappleStartX=this.x;this.grappleStartY=this.y;this.grappleStartTime=Date.now()
      }

    } else if(this.attackType==='salsySword'){
      // Two consecutive fan slashes (25x2) at medium-close range
      const attackAngle=this.facingRight?0:Math.PI;
      const arcWidth=Math.PI*1.35;
      const doSwing = ()=>{
        enemies.forEach(enemy=>{
          const dx=enemy.x-this.x;const dy=enemy.y-this.y;const dist=Math.hypot(dx,dy);
          const angle=Math.atan2(dy,dx);
          let angleDiff=angle-attackAngle;
          while(angleDiff>Math.PI)angleDiff-=Math.PI*2;
          while(angleDiff<-Math.PI)angleDiff+=Math.PI*2;
          if(dist<this.range && Math.abs(angleDiff)<arcWidth/2+0.15){
            const base=37*this.attackBuffMultiplier*(this.baneSuperAttackMult||1);
            const dmg=applyEnemyDamage(enemy, base);
            createParticles(enemy.x,enemy.y,'#f1c40f',10,4);
            showDamageNumber(enemy.x,enemy.y,dmg);
            if(enemy.hp<=0){
  if(player && player.type==='jeff' && player.evolved){
    player.hp = Math.min(player.maxHp, player.hp + 5);
  }
              createParticles(enemy.x,enemy.y,'#fff176',30,6);
              dropStellarBonusAtIndexIfNeeded(enemies.indexOf(enemy));
              enemies.splice(enemies.indexOf(enemy),1);
              applyScore(100*currentLevel);
            addKill(); this._baneSuperOnKill();
                }
          }
        });
      };
      doSwing();
      setTimeout(doSwing, 240);


    
    } else if(this.attackType==='axeattack'){
      // BANE axe wide swing: 270¬∞ fan, hits max 2 enemies
      const attackAngle = this.facingRight ? 0 : Math.PI;
      const arcWidth = Math.PI * 1.5; // 270 degrees
      let hits = 0;
      // sort enemies by distance (closer hit first)
      const sorted = enemies.slice().sort((a,b)=>{
        const da=Math.hypot(a.x-this.x,a.y-this.y);
        const db=Math.hypot(b.x-this.x,b.y-this.y);
        return da-db;
      });
      sorted.forEach(enemy=>{
        if(hits>=2) return;
        const dx=enemy.x-this.x;
        const dy=enemy.y-this.y;
        const dist=Math.hypot(dx,dy);
        const angle=Math.atan2(dy,dx);
        let angleDiff=angle-attackAngle;
        while(angleDiff>Math.PI) angleDiff-=Math.PI*2;
        while(angleDiff<-Math.PI) angleDiff+=Math.PI*2;
        if(dist < this.range && Math.abs(angleDiff) < arcWidth/2){
          const superMult = (this.type==='bane' && this.baneSuperUntil && now < this.baneSuperUntil) ? (this.baneSuperAttackMult||1) : 1;
          const base = this.damage * this.attackBuffMultiplier * superMult;
          const dmg = applyEnemyDamage(enemy, base);
          createParticles(enemy.x,enemy.y,'#c0392b',14,6);
          showDamageNumber(enemy.x,enemy.y,dmg);
          hits++;
          if(enemy.hp<=0){
            createParticles(enemy.x,enemy.y,'#fff176',30,6);
            dropStellarBonusAtIndexIfNeeded(enemies.indexOf(enemy));
            enemies.splice(enemies.indexOf(enemy),1);
            applyScore(100*currentLevel);
          addKill(); this._baneSuperOnKill();
                }
        }
      });


    } else if(this.attackType==='lucienBlade'){
      // 4 colpi ravvicinati (15x4), stile simile a Salsy ma pi√π vicino
      const attackAngle=this.facingRight?0:Math.PI;
      const arcWidth=Math.PI*1.05;
      const doSwing = ()=>{
        enemies.forEach(enemy=>{
          const dx=enemy.x-this.x;const dy=enemy.y-this.y;const dist=Math.hypot(dx,dy);
          const angle=Math.atan2(dy,dx);
          let angleDiff=angle-attackAngle;
          while(angleDiff>Math.PI)angleDiff-=Math.PI*2;
          while(angleDiff<-Math.PI)angleDiff+=Math.PI*2;

          if(dist<this.range && Math.abs(angleDiff)<arcWidth/2+0.20){
            const base=15*this.attackBuffMultiplier*(this.baneSuperAttackMult||1);
            const dmg=applyEnemyDamage(enemy, base);
            createParticles(enemy.x,enemy.y,'#c8e6ff',8,4);
            showDamageNumber(enemy.x,enemy.y,dmg);
            if(enemy.hp<=0){
              createParticles(enemy.x,enemy.y,'#fff176',30,6);
              dropStellarBonusAtIndexIfNeeded(enemies.indexOf(enemy));
              enemies.splice(enemies.indexOf(enemy),1);
              applyScore(100*currentLevel);
            addKill(); this._baneSuperOnKill();
                }
          }
        });
      };
      doSwing();
      setTimeout(doSwing, 85);
      setTimeout(doSwing, 170);
      setTimeout(doSwing, 255);

    } else if(this.attackType==='sword'){
      const attackAngle=this.facingRight?0:Math.PI;const arcWidth=Math.PI*1.6;
      let __jeffHitCount=0;
      enemies.forEach(enemy=>{
        const dx=enemy.x-this.x;const dy=enemy.y-this.y;const dist=Math.hypot(dx,dy);
        const angle=Math.atan2(dy,dx);
        let angleDiff=angle-attackAngle;
        while(angleDiff>Math.PI)angleDiff-=Math.PI*2;
        while(angleDiff<-Math.PI)angleDiff+=Math.PI*2;
        if(dist<this.range&&Math.abs(angleDiff)<arcWidth/2+0.2){
          const dmg=Math.round(this.damage*this.attackBuffMultiplier*(this.baneSuperAttackMult||1));
          const _dmg=dmg; const _final=applyEnemyDamage(enemy,_dmg);
          createParticles(enemy.x,enemy.y,'#9b59b6',10,4);
          showDamageNumber(enemy.x,enemy.y, _final);
          if(enemy.hp<=0){
  if(player && player.type==='jeff' && player.evolved){
    player.hp = Math.min(player.maxHp, player.hp + 5);
  }
            createParticles(enemy.x,enemy.y,'#fff176',30,6);
            dropStellarBonusAtIndexIfNeeded(enemies.indexOf(enemy));
            enemies.splice(enemies.indexOf(enemy),1);
            applyScore(100*currentLevel);addKill(); this._baneSuperOnKill();
                }
        }
      });
      // Jeff EVO passive: if a single attack hits 2+ enemies, heal 1% max HP
      if(this.type==='jeff' && this.evolved && __jeffHitCount>=2){
        const heal = Math.max(1, Math.round(this.maxHP*0.01));
        this.hp = Math.min(this.maxHP, this.hp + heal);
        createParticles(this.x+this.width/2,this.y+this.height/2,'#2ecc71',10,4);
      }
      if(assistTarget){
        const distAssist=Math.hypot((assistTarget.x-this.x),(assistTarget.y-this.y));
        if(distAssist<this.range+60){
          const dmg=Math.round(this.damage*0.7*this.attackBuffMultiplier*(this.baneSuperAttackMult||1));
          const _dmg=dmg; const _final=applyEnemyDamage(assistTarget,_dmg);
          createParticles(assistTarget.x,assistTarget.y,'#9b59b6',10,4);
          showDamageNumber(assistTarget.x,assistTarget.y, _final);
          if(assistTarget.hp<=0){
            createParticles(assistTarget.x,assistTarget.y,'#fff176',30,6);
            dropStellarBonusAtIndexIfNeeded(enemies.indexOf(assistTarget));
            enemies.splice(enemies.indexOf(assistTarget),1);
            applyScore(100*currentLevel);addKill(); this._baneSuperOnKill();
                }
        }
      }

    
    } else if(this.attackType==='kouvagia'){

      // Kouvagia: mini dash forward dealing damage during dash + small/medium AoE on stop
      this.isDashing=true;
      this.dashTime=Date.now();
      this._dashSpeedMult=5.2;
      this._dashDuration=260;
      this.dashCooldown=95;

      this._kouvagiaDashActive=true;
      this._kouvagiaDashHitCd=0;
      this._kouvagiaExplosionPending=true;

    } else if(this.attackType==='hybrid'){
      
      const target=assistTarget || this.findClosestEnemy(800);
      const dist = target ? Math.hypot((target.x+target.width/2)-(this.x+this.width/2),(target.y+target.height/2)-(this.y+this.height/2)) : Infinity;

      if(dist>150 && target){
        // Ranged: small energy sphere with small AoE
        const dx=(target.x+target.width/2)-(this.x+this.width/2);
        const dy=(target.y+target.height/2)-(this.y+this.height/2);
        const len=Math.hypot(dx,dy)||1;
        const speed=9;
        const vx=(dx/len)*speed;
        const vy=(dy/len)*speed;
        const baseAoeDmg = Math.round(45* this.attackBuffMultiplier);
        spawnProjectile({
          x:this.x+this.width/2, y:this.y+this.height/2,
          vx, vy, speed,
          damage:baseAoeDmg, ttl:2000, color:'#ffb74d',
          radius:9, friendly:true, aoeRadius:110, aoeFullDamage:true, homing:false,
          explodeOnExpire:true
        });
        createParticles(this.x+this.width/2,this.y+this.height/2,'#ffa726',8,3);
      } else {
        // Close: two quick punches, slightly less strong than Rooney
        const perPunchBase=50; // Rooney base ~60; Voltryx slightly less
        const punch = ()=>{
          let closest=null;let best=160;
          enemies.forEach(e=>{
            const d=Math.hypot(e.x-this.x,e.y-this.y);
            if(d<best && Math.abs(e.y-this.y)<220){best=d;closest=e}
          });
          if(closest){
            const dmg=Math.round(perPunchBase*this.attackBuffMultiplier*(this.baneSuperAttackMult||1));
            const _dmg=dmg; const _final=applyEnemyDamage(closest,_dmg);
            createParticles(closest.x,closest.y,'#e67e22',12,5);
            showDamageNumber(closest.x,closest.y, _final);
            if(closest.hp<=0){
              createParticles(closest.x,closest.y,'#fff176',30,6);
              dropStellarBonusAtIndexIfNeeded(enemies.indexOf(closest));
              enemies.splice(enemies.indexOf(closest),1);
              applyScore(100*currentLevel);
            addKill(); this._baneSuperOnKill();
                }
          }
        };
        punch();
        setTimeout(punch, 240);
      }
    }

else if(this.attackType==='hecateBow'){
  // H√®cate: long range arrow that splits into 3 arrows hitting other enemies
  const target = assistTarget || this.findClosestEnemy(this.range);
  const sx=this.x+this.width/2;
  const sy=this.y+this.height/2;

  let dx,dy;
  if(target){
    dx=(target.x+target.width/2)-sx;
    dy=(target.y+target.height/2)-sy;
  } else {
    dx=this.facingRight?1:-1;
    dy=0;
  }
  const len=Math.hypot(dx,dy)||1;
  const speed=13;
  const vx=(dx/len)*speed;
  const vy=(dy/len)*speed;

  const mainDmg = Math.round(this.damage*1.25*this.attackBuffMultiplier*(this.baneSuperAttackMult||1));
  const splitDmg = Math.round(mainDmg * 0.5); // frecce minori: met√† del danno della freccia principale

  spawnProjectile({
    x:sx,y:sy,
    vx,vy,speed,
    damage:mainDmg,
    ttl:720,
    color:'#e0e0e0',
    radius:6,
    friendly:true,
    shape:'rect',
    w:22,
    h:5,
    angle:Math.atan2(vy,vx),
    meta:{type:'hecateMain', splitDamage: splitDmg}
  });
  createParticles(sx,sy,'#c5cae9',14,4);
}
else if(this.attackType==='tempostormLaser'){
  const assistTarget=this.findClosestEnemy(900);
  const sx=this.x+this.width/2;
  const sy=this.y+this.height/2;

  let dx,dy,len;
  if(assistTarget){
    dx=(assistTarget.x+assistTarget.width/2)-sx;
    dy=(assistTarget.y+assistTarget.height/2)-sy;
  }else{
    dx=this.facingRight?1:-1; dy=0;
  }
  len=Math.hypot(dx,dy)||1;
  const ex=sx+(dx/len)*this.range;
  const ey=sy+(dy/len)*this.range;

  spawnTempBeam({
    x1:sx,y1:sy,x2:ex,y2:ey,
    width:18,ttl:260,
    damage1:Math.round(40*this.attackBuffMultiplier*(this.baneSuperAttackMult||1)),
    damageStay:Math.round(30*this.attackBuffMultiplier*(this.baneSuperAttackMult||1))
  });
  createParticles(sx,sy,'#4fc3f7',14,4);
}

else if(this.attackType==='magic'){
  const damages = (characterStats.marz && characterStats.marz.tripleDamage) ? characterStats.marz.tripleDamage : [40,50,60];
  const colors = ['#ff00ff','#00e5ff','#fff176'];

  // Choose up to 3 distinct targets; if fewer, stack on available targets
  const sorted=enemies.slice().sort((a,b)=>{
    const da=Math.hypot((a.x+a.width/2)-(this.x+this.width/2),(a.y+a.height/2)-(this.y+this.height/2));
    const db=Math.hypot((b.x+b.width/2)-(this.x+this.width/2),(b.y+b.height/2)-(this.y+this.height/2));
    return da-db;
  });
  const targets = sorted.slice(0,3);
  const fallback = targets[0] || this.findClosestEnemy(this.range);

  for(let i=0;i<3;i++){
    const t = targets[i] || fallback;
    if(!t) continue;

    const sx=this.x+this.width/2;
    const sy=this.y+this.height/2;
    const tx=t.x+t.width/2;
    const ty=t.y+t.height/2;
    const dx=tx-sx, dy=ty-sy;
    const len=Math.hypot(dx,dy)||1;

    const speed=11;
    const vx=(dx/len)*speed;
    const vy=(dy/len)*speed;

    spawnProjectile({
      x:sx,y:sy,
      vx,vy,speed,
      damage:Math.round(damages[i]*this.attackBuffMultiplier*(this.baneSuperAttackMult||1)),
      ttl:520,
      color:colors[i%colors.length],
      radius:7,
      friendly:true,
      aoeRadius:0,
      homing:true,
      // IMPORTANT: lock each beam to its chosen target (3 different enemies if available)
      targetRef:t
    });
    createParticles(sx,sy,colors[i%colors.length],10,4);
  }
}



    return true;
  }

  superAttack(){
    const now=Date.now();

    // Bane SUPER:
// - +25% movement speed for 10s
// - base attack cooldown reduced by 75% (cooldown * 0.25) for the whole SUPER
// - during SUPER, base attack gets an extra buff based on current Kill count at activation:
//   0‚Äì25  => +25% (x1.25)
//   26‚Äì50 => +50% (x1.50)
//   51‚Äì75 => +75% (x1.75)
//   76+   => +100% (x2.00)
//   (this multiplier is independent from pickup/bonus buffs)
// - cooldown 60s
    if(this.type==='hendel'){
      const sc = (this.superCooldown!=null)?this.superCooldown:24000;
      if(now - this.lastSuper < sc) return false;
      this.lastSuper = now;
      
      this.invulnerable = true;
      this.pickupShieldUntil = now + 3000;
      startHendelCrush(3000);
      createParticles(this.x+this.width/2,this.y+this.height/2,'#9e9e9e',28,6);
      shakeScreen();
      return true;
    }


    if(this.type==='kaerith'){
      const sc = (this.superCooldown!=null)?this.superCooldown:21000;
      if(now - this.lastSuper < sc) return false;
      this.lastSuper = now;

      // === NEW SUPER: Inferno Totale (9s) ===
      this._kaerithFireStart = now;
      this._kaerithFireUntil = now + 9000;
      this._kaerithFireLastTick = 0;

      // burst FX iniziale
      createParticles(this.x+this.width/2,this.y+this.height/2,'#ff3d00',34,6);
      shakeScreen(7);
      return true;
    }

    if(this.type==='bane'){
      const sc = (this.superCooldown!=null)?this.superCooldown:60000;
      if(now - this.lastSuper < sc) return false;

      this.lastSuper = now;

      const dur = (this.superDuration!=null)?this.superDuration:10000;
      this.baneSuperUntil = now + dur;

      // speed boost (do not downgrade other speed buffs)
      this.speed = Math.max(this.speed, this._baseSpeed * 1.25);

      // cooldown reduction for base attack (only during SUPER)
      if(typeof this.cooldown === 'number'){
        // remember current cooldown (may include other effects)
        this._preBaneSuperCooldown = this.cooldown;

        // SUPER: faster base attack
        this.cooldown = this._baseCooldown * 0.25;
        this._baneSuperAppliedCooldown = true;

        // When SUPER ends (after `dur`), apply fatigue: +75% time between hits
        // Use a timeout so it triggers even if a frame/update is skipped.
        const expectedEnd = this.baneSuperUntil;
        setTimeout(()=>{
          // still the same player instance and the same SUPER window ended
          if(this.type!=='bane') return;
          if(this.baneSuperUntil && this.baneSuperUntil===expectedEnd && Date.now()>=expectedEnd){
            this.baneSuperUntil = 0;
            if(this._baseCooldown!=null){
              this.cooldown = this._baseCooldown * 0.95;
            }
            this._preBaneSuperCooldown = undefined;
            this._baneSuperAppliedCooldown = false;

            // restore speed only if SUPER was the active boost (avoid downgrading other buffs)
            const superSpeed = this._baseSpeed * 1.25;
            if(this.speed <= superSpeed + 0.0001){
              this.speed = this._baseSpeed;
            }
          }
        }, dur + 20);
      }

      // attack multiplier for SUPER (independent from pickup/bonus buffs)
      const k = (typeof kills==='number') ? kills : 0;
      if(k<=25) this.baneSuperAttackMult = 1.25;
      else if(k<=50) this.baneSuperAttackMult = 1.50;
      else if(k<=75) this.baneSuperAttackMult = 1.75;
      else this.baneSuperAttackMult = 2.00;

      return true;
    }

    
// --- FIX: H√àCATE SUPER (ensure it always triggers correctly) ---
// In some later refactors the generic cooldown / isDoingSuper flow can block H√®cate.
// We handle her super explicitly here, mirroring the old working behavior.
if(this.type==='hecate'){
  const sc = (this.superCooldown!=null)?this.superCooldown:22000;
  if(now - this.lastSuper < sc || this.isDoingSuper) return false;

  this.lastSuper = now;
  this.isDoingSuper = true;
  this.superStartTime = now;
  this._superHitDone = false;

  // Heal: 5 HP per enemy on field
  const heal = Math.max(0, (typeof enemies!=='undefined' && enemies)? enemies.length : 0) * 5;
  if(heal>0){
    this.hp = Math.min(this.maxHP, this.hp + heal);
    createParticles(this.x+this.width/2,this.y+this.height/2,'#c5cae9',28,6);
  } else {
    createParticles(this.x+this.width/2,this.y+this.height/2,'#c5cae9',16,5);
  }

  // Spawn 3 wolves (max 3)
  spawnWolvesNearPlayer(this, 3);

  shakeScreen();
  return true;
}

if(now-this.lastSuper<this.superCooldown||this.isDoingSuper)return false;
    this.lastSuper=now;this.isDoingSuper=true;this.superStartTime=now;this._HitDone=false;

    if(this.type==='jimmy'){this.invulnerable=true;this.shieldActive=true}

    if(this.attackType==='grapple'){
      const sorted=enemies.slice().sort((a,b)=>{
        const da=Math.hypot(a.x-this.x,a.y-this.y);
        const db=Math.hypot(b.x-this.x,b.y-this.y);
        return da-db
      });
      this.superTargets=sorted.slice(0,6);

      // reset pass-through state
      this._superGrapplePassUntil=0;
      this._superGrappleDirX=this.facingRight?1:-1;
      this._superGrappleDirY=0;
    }
    else if(this.attackType==='punch'){
      createParticles(this.x+this.width/2,this.y+this.height/2,'#f39c12',20,6);
    }
    else if(this.attackType==='sword'){
      createParticles(this.x+this.width/2,this.y+this.height/2,'#9b59b6',20,6);
    }

    else if(this.attackType==='salsySword'){
      // Mark up to 3 enemies; marked enemies take double damage for a while
      const sorted=enemies.slice().sort((a,b)=>{
        const da=Math.hypot((a.x+a.width/2)-(this.x+this.width/2),(a.y+a.height/2)-(this.y+this.height/2));
        const db=Math.hypot((b.x+b.width/2)-(this.x+this.width/2),(b.y+b.height/2)-(this.y+this.height/2));
        return da-db;
      });
      const targets=sorted.slice(0,3);
      const until=now+7000;
      targets.forEach(t=>{
        t.salsyMarkUntil=until;
        createParticles(t.x,t.y,'#f1c40f',22,5);
      });
      createParticles(this.x+this.width/2,this.y+this.height/2,'#f1c40f',26,6);
    }

    else if(this.attackType==='lucienBlade'){
      // Lucien SUPER: spawn 5 collectible bonuses around him (NO gold, NO super-recharge).
      // Bonuses are real pickups collectable by the player.
      const allowedTypes = ['heal','atk','speed','shieldPickup','furia','ice'];
      const px = this.x + this.width/2;
      const py = this.y + this.height/2;

      for(let i=0;i<5;i++){
        const a = Math.random()*Math.PI*2;
        const r = 60 + Math.random()*25;
        const t = allowedTypes[Math.floor(Math.random()*allowedTypes.length)];
        const x = Math.max(40, Math.min(canvas.width-40, px + Math.cos(a)*r));
        const y = Math.max(40, Math.min(canvas.height-90, py + Math.sin(a)*r));
        spawnPickup(x, y, t);
        createParticles(x, y, '#80cbc4', 18, 4);
      }
      createParticles(px, py, '#80cbc4', 30, 6);
    }


    else if(this.attackType==='kouvagia'){

      // Kouvagia super: full heal + large knockback + tiny damage + visual FX
      this.hp=this.maxHP;
      this._kouvagiaSuperFxStart=now;
      this._kouvagiaSuperFxUntil=now+900;
      createParticles(this.x+this.width/2,this.y+this.height/2,'#55efc4',60,6);

      const R=360;
      for(let i=0;i<enemies.length;i++){
        const e=enemies[i];
        const dx=(e.x+e.width/2)-(this.x+this.width/2);
        const dy=(e.y+e.height/2)-(this.y+this.height/2);
        const dist=Math.hypot(dx,dy)||1;
        if(dist<=R){
          // tiny damage
          const dmg=3;
          const _final=applyEnemyDamage(e,dmg);
          showDamageNumber(e.x,e.y,_final);
          createParticles(e.x,e.y,'#81ecec',8,4);
          // knockback
          const push=120;
          e.x += (dx/dist)*push;
          e.y += (dy/dist)*push;
        }
      }
      shakeScreen();
    }
else if(this.attackType==='hybrid'){
     
      const dmgPerPulse = Math.round(120 * this.attackBuffMultiplier);
      spawnProjectile({
        x:this.x+this.width/2,y:this.y+this.height/2,
        vx:(this.facingRight?1:-1)*4,vy:0,speed:6,
        damage:dmgPerPulse,ttl:this.superDuration,color:'#f39c12',
        radius:14,friendly:true,aoeRadius:120,homing:true,
        isVoltryxSuper:true,pulseInterval:260,lastPulse:0
      });
      createParticles(this.x+this.width/2,this.y+this.height/2,'#f39c12',26,6);
      shakeScreen();
    }

else if(this.attackType==='tempostormLaser'){
  const cx=canvas.width/2;
  const cy=(canvas.height-30)/2;
  let stolen=0;

  enemies.forEach(e=>{
    // group to exact center
    e.x = cx - e.width/2;
    e.y = cy - e.height/2;

    const removed = Math.max(0, Math.floor(e.hp/2));
    e.hp = Math.max(0, e.hp - removed);
    stolen += removed;

    if(removed>0){
      showDamageNumber(e.x,e.y, removed);
      createParticles(e.x+e.width/2,e.y+e.height/2,'#00b0ff',18,5);
    }
  });

  if(stolen>0){
    this.hp = Math.min(this.maxHP, this.hp + stolen);
    createParticles(this.x+this.width/2,this.y+this.height/2,'#00b0ff',30,6);
  }
  createParticles(cx,cy,'#4fc3f7',60,7);
  shakeScreen();
}



    else if(this.attackType==='hecateBow'){
      // Super: heal 5 HP for each enemy currently present
      const heal = Math.max(0, enemies.length) * 5;
      if(heal>0){
        this.hp = Math.min(this.maxHP, this.hp + heal);
        createParticles(this.x+this.width/2,this.y+this.height/2,'#c5cae9',28,6);
      } else {
        createParticles(this.x+this.width/2,this.y+this.height/2,'#c5cae9',16,5);
      }

      // NEW: spawn 3 friendly wolves near H√®cate (max 6 on field)
      spawnWolvesNearPlayer(this, 3);

      shakeScreen();
    }
    else if(this.attackType==='magic'){
      // Super: create a huge colorful magic zone at map center.
      // - Expands slowly for 10s
      // - Deals heavy periodic damage to enemies inside
      // - If Marz stays inside, he gains +50% movement speed
      const cx=canvas.width/2;
      const cy=(canvas.height-30)/2;

      magicZone = {
        x:cx,
        y:cy,
        startsAt:now,
        endsAt:now+6500,
        durationMs:10000,
        startRadius:90,
        maxRadius:560,
        radius:90,
        tickMs:180,
        damagePerTick:Math.round(16*this.attackBuffMultiplier*(this.baneSuperAttackMult||1)),
        lastTick:0,
        colors:['#ff00ff','#00e5ff','#fff176','#7c4dff','#18ffff'],
        colorIdx:0
      };

      // burst FX
      createParticles(cx,cy,'#ff00ff',50,7);
      createParticles(cx,cy,'#00e5ff',50,7);
      createParticles(cx,cy,'#fff176',50,7);
      shakeScreen();
    }


    return true;
  }

  endSuper(){
    this.isDoingSuper=false;this._superHitDone=false;this._lastSwordTick=null;
    this.superTargets=[];this.grappleTarget=null;this.isGrappling=false;
    this.vx*=0.5;this.vy*=0.5;this.invulnerable=false;
    if(this.type==='jimmy')this.shieldActive=false
  }


  takeDamage(damage, attacker){
    if(this.invulnerable||(this.pickupShieldUntil&&Date.now()<this.pickupShieldUntil))return;
    if(this.shieldActive&&!this.shieldBroken){
      this.shieldDurability-=1;
      createParticles(this.x,this.y,'#3498db',12,5);
      if(this.shieldDurability<=0){this.shieldBroken=true;this.shieldBrokenTime=Date.now();this.shieldActive=false}
      return;
    }

    // apply damage to Hendel (or any player)
    this.hp-=damage;
    if(!isFinite(this.hp)) this.hp = 0;
    this.hp = Math.max(0, this.hp);
    this.damageTaken++;
    this.combo=0;
    applyScore(-50);
    this._baneSuperOnKill();
    createParticles(this.x,this.y,'#c0392b',12,5);
    shakeScreen();

    // Hendel retaliation: any enemy that hits Hendel is knocked back and takes 30 damage
    if(this.type==='hendel' && attacker && typeof attacker.hp==='number' && attacker.hp>0){
      const pcx=this.x+this.width/2, pcy=this.y+this.height/2;
      const ecx=attacker.x+attacker.width/2, ecy=attacker.y+attacker.height/2;
      let dx=ecx-pcx, dy=ecy-pcy;
      const len=Math.hypot(dx,dy)||1;
      dx/=len; dy/=len;

      // knockback away from Hendel (a bit of distance)
      const kb=140;
      attacker.x += dx*kb;
      attacker.y += dy*kb;
      attacker.x = Math.max(0, Math.min(canvas.width - attacker.width, attacker.x));
      attacker.y = Math.max(0, Math.min(canvas.height - attacker.height, attacker.y));

      // retaliation damage
      const ret=30;
      attacker.hp -= ret;
      showDamageNumber(attacker.x, attacker.y, ret);
      createParticles(attacker.x+attacker.width/2, attacker.y+attacker.height/2, '#8b5a2b', 10, 4);
      createParticles(attacker.x+attacker.width/2, attacker.y+attacker.height/2, '#9e9e9e', 6, 4);

      // kill handling (if retaliation finishes the enemy)
      if(attacker.hp<=0 && enemies){
        const idx=enemies.indexOf(attacker);
        if(idx!==-1){
          createParticles(attacker.x,attacker.y,'#fff176',28,6);
          dropStellarBonusAtIndexIfNeeded(idx);
          enemies.splice(idx,1);
          applyScore(100*currentLevel);
          addKill();
          if(this._baneSuperOnKill) this._baneSuperOnKill();
        }
      }
    }

    if(this.hp<=0 && gameState==='playing') endGame(false);
  }


  _baneSuperOnKill(){
    // Kept for compatibility: Bane SUPER attack buff is now decided at activation
    // based on current Kill count (see superAttack()).
    return;
  }

  _updateBaneSuperState(now){
    if(this.type!=='bane') return;
    if(this.baneSuperUntil && now >= this.baneSuperUntil){
      this.baneSuperUntil = 0;
      // quando la SUPER finisce (dopo la sua durata), l'attacco base diventa pi√π lento: +75% tempo tra i colpi
      if(this._baseCooldown!=null){
        this.cooldown = this._baseCooldown * 0.95;
      }
      this._preBaneSuperCooldown = undefined;
      this._baneSuperAppliedCooldown = false;
      // restore speed only if SUPER was the active boost (avoid downgrading other buffs)
      const superSpeed = this._baseSpeed * 1.25;
      if(this.speed <= superSpeed + 0.0001){
        this.speed = this._baseSpeed;
      }
      this.baneSuperAttackMult = 1;
    }
  }

  draw(){
    const baseImg = images[this.type];
    const evoImg = (this.evolved && imagesEvo && imagesEvo[this.type]) ? imagesEvo[this.type] : null;
    const activeImg = (evoImg && evoImg.complete) ? evoImg : baseImg;

    if(activeImg && activeImg.complete){
      ctx.save();
      // evolution visual (brief glow + scale)
      const evoT = (this._evoFxUntil && Date.now() < this._evoFxUntil) ? (1 - ((this._evoFxUntil - Date.now())/650)) : 1;
      const evoScale = (this._evoFxUntil && Date.now() < this._evoFxUntil) ? (1 + 0.18*(1-evoT)) : 1;
      const evoAlpha = (this._evoFxUntil && Date.now() < this._evoFxUntil) ? (0.75 + 0.25*Math.sin(Date.now()/45)) : 1;
      ctx.globalAlpha = evoAlpha;
      const cx=this.x+this.width/2, cy=this.y+this.height/2;
      ctx.translate(cx,cy);
      ctx.scale(evoScale,evoScale);
      ctx.translate(-cx,-cy);
      if(!this.facingRight){
        ctx.scale(-1,1);
        ctx.drawImage(activeImg,-this.x-this.width,this.y,this.width,this.height)
      }else ctx.drawImage(activeImg,this.x,this.y,this.width,this.height);
      ctx.restore()
    // Hendel hammer VFX (brown handle near Hendel, orange head far)
    if(this.type==='hendel' && this._hammerSwing){
      const H=this._hammerSwing;
      const now=Date.now();
      const t=Math.max(0, Math.min(1, (now - H.start)/H.duration));

      const angStart = H.baseAng + H.arc/2;
      const angEnd   = H.baseAng - H.arc/2;
      const ang = angStart + (angEnd - angStart) * t;

      const cx=this.x+this.width/2;
      const cy=this.y+this.height/2;

      ctx.save();
      ctx.translate(cx,cy);
      ctx.rotate(ang);

      // handle (brown) ‚Äî closer
      ctx.globalAlpha = 0.55;
      ctx.fillStyle = '#b07a56';
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 6;
      ctx.beginPath();
      ctx.rect(H.handleStart, -H.handleW/2, H.handleLen, H.handleW);
      ctx.fill();
      ctx.stroke();

      // head (orange) ‚Äî farther
      ctx.globalAlpha = 0.60;
      ctx.fillStyle = '#ff7f1f';
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 7;
      const hs = H.headSize;
      ctx.beginPath();
      ctx.rect(H.headOffset - hs/2, -hs/2, hs, hs);
      ctx.fill();
      ctx.stroke();

      ctx.restore();
    }



    // Kaerith VFX (fan stretto e lungo)
    if(this.type==='kaerith' && this._kaerithFlame){
      const F=this._kaerithFlame;
      const now=Date.now();
      const t=Math.max(0, Math.min(1, (now - F.start)/160)); // fade-in veloce
      const cx=this.x+this.width/2, cy=this.y+this.height/2;
      const a0=F.dir - F.angle/2;
      const a1=F.dir + F.angle/2;

      ctx.save();
      ctx.globalAlpha = 0.16 + 0.26*t;
      ctx.fillStyle='rgba(255,120,0,0.95)';
      ctx.beginPath();
      ctx.moveTo(cx,cy);
      ctx.arc(cx,cy,F.range,a0,a1,false);
      ctx.closePath();
      ctx.fill();

      ctx.globalAlpha = 0.10 + 0.18*t;
      ctx.strokeStyle='rgba(255,60,0,0.95)';
      ctx.lineWidth=4;
      ctx.beginPath();
      ctx.arc(cx,cy,F.range,a0,a1,false);
      ctx.stroke();
      ctx.restore();
    }


    } else {
      ctx.fillStyle='#3498db';ctx.fillRect(this.x,this.y,this.width,this.height)
    }

    // StellarBonus glow (luminous transparent, 1s ‚Äì only light aura)
    if(this.stellarGlowUntil && Date.now() < this.stellarGlowUntil){
      const cx=this.x+this.width/2, cy=this.y+this.height/2;
      ctx.save();
      ctx.globalCompositeOperation='lighter';
  ctx.shadowColor = 'rgba(255,255,255,0.9)';
  ctx.shadowBlur = 25;

      ctx.globalAlpha = 0.45;
      ctx.fillStyle = 'rgba(255,255,255,0.6)';
      ctx.beginPath();
      ctx.arc(cx, cy, Math.max(this.width,this.height)*0.65, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }


    // Salsy mark indicator
    if(this.salsyMarkUntil && Date.now() < this.salsyMarkUntil){
      ctx.save();
      ctx.font='22px "Press Start 2P", monospace';
      ctx.textAlign='center';
      ctx.fillStyle='#f1c40f';
      ctx.fillText('‚öúÔ∏è', this.x+this.width/2, this.y-10);
      ctx.restore();
    }

    if(this.shieldActive&&!this.shieldBroken){
      ctx.beginPath();ctx.strokeStyle='rgba(127,219,255,0.85)';ctx.lineWidth=6;
      ctx.arc(this.x+this.width/2,this.y+this.height/2,Math.max(this.width,this.height),0,Math.PI*2);ctx.stroke();
      ctx.fillStyle='#fff';ctx.fillRect(this.x,this.y-16,this.width,6);
      ctx.fillStyle='#7fdbff';ctx.fillRect(this.x,this.y-16,this.width*(this.shieldDurability/this.shieldMaxDurability),6)
    }

    if(this.attacking&&!this.isGrappling){
      ctx.save();
      if(this.attackType==='punch'){
        const cx=this.x+this.width/2, cy=this.y+this.height/2;
        const dir=this.facingRight?1:-1;
        const punchX=cx + dir*this.range;

        // Rooney: punch beam with a flared "fist" end (homogeneous)
        if(this.type==='rooney'){
          const shaftW = 18;         // thickness of the shaft
          const fistW  = 34;         // thickness of the fist end
          const fistL  = 34;         // length of the fist end
          ctx.fillStyle='rgba(231,76,60,0.85)'; // solid-ish red punch
          // shaft
          ctx.beginPath();
          ctx.rect(Math.min(cx,punchX), cy-shaftW/2, Math.abs(punchX-cx)-fistL, shaftW);
          ctx.fill();
          // fist end (flared)
          const endStart = punchX - dir*fistL;
          ctx.beginPath();
          ctx.moveTo(endStart, cy - fistW*0.55);
          ctx.lineTo(punchX,  cy - fistW*0.35);
          ctx.lineTo(punchX,  cy + fistW*0.35);
          ctx.lineTo(endStart, cy + fistW*0.55);
          ctx.closePath();
          ctx.fill();
        }else{
          // default punch telegraph
          ctx.strokeStyle='rgba(230,126,34,0.7)';
          ctx.lineWidth=8;
          ctx.beginPath();
          ctx.moveTo(cx,cy);
          ctx.lineTo(punchX,cy);
          ctx.stroke();
        }
      }else if(this.attackType==='sword'){
        ctx.strokeStyle='rgba(155,89,182,0.6)';ctx.lineWidth=5;
        const angle=this.facingRight?0:Math.PI;const arcWidth=Math.PI*1.2;
        ctx.beginPath();ctx.arc(this.x+this.width/2,this.y+this.height/2,this.range,angle-arcWidth/2,angle+arcWidth/2);ctx.stroke()
      }else if(this.attackType==='salsySword'){
        // Visual telegraph: Salsy fan slash area
        const angle=this.facingRight?0:Math.PI;const arcWidth=Math.PI*1.35;
        ctx.fillStyle='rgba(241,196,15,0.12)';
        ctx.strokeStyle='rgba(241,196,15,0.75)';
        ctx.lineWidth=6;
        ctx.beginPath();
        ctx.moveTo(this.x+this.width/2,this.y+this.height/2);
        ctx.arc(this.x+this.width/2,this.y+this.height/2,this.range,angle-arcWidth/2,angle+arcWidth/2);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
      }else if(this.attackType==='axeattack'){
        // Visual area: Bane axe swing (270¬∞)
        const angle=this.facingRight?0:Math.PI;const arcWidth=Math.PI*1.5;
        ctx.fillStyle='rgba(231,76,60,0.20)';
        ctx.strokeStyle='rgba(231,76,60,0.85)';
        ctx.lineWidth=7;
        ctx.beginPath();
        ctx.moveTo(this.x+this.width/2,this.y+this.height/2);
        ctx.arc(this.x+this.width/2,this.y+this.height/2,this.range,angle-arcWidth/2,angle+arcWidth/2);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
      }else if(this.attackType==='lucienBlade'){
        // Visual area: Lucien 4-hit close-range blade fan
        const angle=this.facingRight?0:Math.PI;const arcWidth=Math.PI*1.05;
        ctx.fillStyle='rgba(200,230,255,0.13)';
        ctx.strokeStyle='rgba(200,230,255,0.82)';
        ctx.lineWidth=6;
        ctx.beginPath();
        ctx.moveTo(this.x+this.width/2,this.y+this.height/2);
        ctx.arc(this.x+this.width/2,this.y+this.height/2,this.range,angle-arcWidth/2,angle+arcWidth/2);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
      }else if(this.attackType==='hybrid'){
        ctx.strokeStyle='rgba(243,156,18,0.6)';ctx.lineWidth=6;
        ctx.beginPath();
        ctx.arc(this.x+this.width/2,this.y+this.height/2,110,0,Math.PI*2);
        ctx.stroke();
      }
      else if(this.attackType==='tempostormLaser'){
        const sx=this.x+this.width/2, sy=this.y+this.height/2;
        const tx = sx + (this.facingRight?1:-1)*this.range;
        const ty = sy;
        ctx.strokeStyle='rgba(79,195,247,0.75)';ctx.lineWidth=7;
        ctx.beginPath();ctx.moveTo(sx,sy);ctx.lineTo(tx,ty);ctx.stroke();
      }
      ctx.restore()
    }

    if(this.isDoingSuper){
      if(this.attackType==='punch'){
        ctx.save();ctx.strokeStyle='rgba(243,156,18,0.45)';ctx.lineWidth=12;ctx.beginPath();
        const arcRadius=350;ctx.arc(this.x+this.width/2,this.y+this.height/2,arcRadius,0,Math.PI*2);ctx.stroke();ctx.restore()
      }
      else if(this.attackType==='sword'){
        ctx.save();ctx.strokeStyle='rgba(155,89,182,0.45)';ctx.lineWidth=10;ctx.beginPath();
        const swordRadius=JEFF_SUPER_RADIUS;ctx.arc(this.x+this.width/2,this.y+this.height/2,swordRadius,0,Math.PI*2);ctx.stroke();ctx.restore()
      }
      else if(this.attackType==='grapple'){
        ctx.save();ctx.strokeStyle='rgba(231,76,60,0.45)';ctx.lineWidth=6;
        this.superTargets.forEach(t=>{ctx.beginPath();ctx.arc(t.x+t.width/2,t.y+t.height/2,40,0,Math.PI*2);ctx.stroke()});
        ctx.restore()
      }
      else if(this.attackType==='hybrid'){
        // aura while super is active
        ctx.save();ctx.strokeStyle='rgba(243,156,18,0.35)';ctx.lineWidth=8;
        ctx.beginPath();ctx.arc(this.x+this.width/2,this.y+this.height/2,140,0,Math.PI*2);ctx.stroke();ctx.restore()
      }
            else if(this.attackType==='tempostormLaser'){
        ctx.save();
        ctx.strokeStyle='rgba(0,176,255,0.45)';
        ctx.lineWidth=10;
        ctx.beginPath();
        ctx.arc(canvas.width/2,(canvas.height-30)/2,180,0,Math.PI*2);
        ctx.stroke();
        ctx.restore();
      }
else if(this.attackType==='salsySword'){
        // Show 1-3 target reticles + launch lines during Salsy super
        ctx.save();
        ctx.strokeStyle='rgba(241,196,15,0.75)';
        ctx.fillStyle='rgba(241,196,15,0.20)';
        ctx.lineWidth=5;
        const px=this.x+this.width/2, py=this.y+this.height/2;
        const list=(this.superTargets||[]).slice(0,3);
        list.forEach((t,i)=>{
          const tx=t.x+t.width/2, ty=t.y+t.height/2;
          // dashed aim line
          ctx.setLineDash([10,6]);
          ctx.beginPath();ctx.moveTo(px,py);ctx.lineTo(tx,ty);ctx.stroke();
          ctx.setLineDash([]);
          // reticle
          ctx.beginPath();ctx.arc(tx,ty,26,0,Math.PI*2);ctx.stroke();
          ctx.beginPath();ctx.arc(tx,ty,10,0,Math.PI*2);ctx.fill();ctx.stroke();
        });
        ctx.restore();
      }
    }

    if(this.isGrappling&&this.grappleTarget){
      ctx.strokeStyle='rgba(231,76,60,0.8)';ctx.lineWidth=3;ctx.setLineDash([10,5]);
      ctx.beginPath();ctx.moveTo(this.x+this.width/2,this.y+this.height/2);
      ctx.lineTo(this.grappleTarget.x+this.grappleTarget.width/2,this.grappleTarget.y+this.grappleTarget.height/2);
      ctx.stroke();ctx.setLineDash([])
    }

    if(this.isJetpacking){
      ctx.save();
      ctx.fillStyle='rgba(255,215,0,0.9)';
      ctx.beginPath();
      ctx.ellipse(this.x+this.width/2,this.y+this.height+12,18,8,0,0,Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    // === KOUVAGIA: visualizzazione aree attacco + effetto super ===
    if(this.type==='kouvagia'){
      // Area danno durante dash-attacco
      if(this.isDashing && this._kouvagiaDashActive){
        ctx.save();
        ctx.strokeStyle='rgba(232,67,147,0.55)';
        ctx.lineWidth=6;
        ctx.beginPath();
        ctx.arc(this.x+this.width/2,this.y+this.height/2,110,0,Math.PI*2);
        ctx.stroke();
        ctx.restore();
      }

      // Area esplosione finale (breve telegraph)
      if(this._kouvagiaExplosionPending && this.isDashing){
        ctx.save();
        ctx.strokeStyle='rgba(253,121,168,0.45)';
        ctx.lineWidth=6;
        ctx.beginPath();
        ctx.arc(this.x+this.width/2,this.y+this.height/2,165,0,Math.PI*2);
        ctx.stroke();
        ctx.restore();
      }

      // Effetto super: onda espansiva + flash
      const nowFx=Date.now();
      if(this._kouvagiaSuperFxUntil && nowFx < this._kouvagiaSuperFxUntil){
        const t=(nowFx-(this._kouvagiaSuperFxStart||nowFx)) / (this._kouvagiaSuperFxUntil-(this._kouvagiaSuperFxStart||nowFx)+1);
        const r=60 + t*360;
        ctx.save();
        ctx.strokeStyle='rgba(85,239,196,'+(0.9 - t*0.8)+')';
        ctx.lineWidth=12;
        ctx.beginPath();
        ctx.arc(this.x+this.width/2,this.y+this.height/2,r,0,Math.PI*2);
        ctx.stroke();
        // flash leggero
        ctx.fillStyle='rgba(85,239,196,'+(0.12*(1-t))+')';
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.restore();
      }
    }

  }
}

class Enemy{
  constructor(type,level){
    const cfg=levelConfigs[Math.max(0,Math.min(levelConfigs.length-1,level-1))];
    const mult=1+0.15*level;
    this.type=type;
    this.x=Math.random()*(canvas.width-100)+50;
    this.y=Math.random()*(canvas.height-150)+50;
    this.width=Math.round(56*1.2);
    this.height=Math.round(56*1.2);
    this.vx=(Math.random()-0.5)*cfg.enemySpeed*mult;
    this.vy=(Math.random()-0.5)*cfg.enemySpeed*mult;
    this.maxHP=Math.round(cfg.enemyHP*(1+0.25*level));
    this.hp=this.maxHP;
    const baseDamage=Math.round(cfg.enemyDamage*(1+0.20*level));
    this.damage=(level>=7)?Math.round(baseDamage*0.8):baseDamage;
    this.speed=cfg.enemySpeed*mult;
    if(level===8)this.speed*=0.925;
    this.lastAttack=0;this.attackCooldown=2000;this.spawnFreezeUntil=Date.now()+500;
    // Special enemies
    if(this.type==='veleno'){
      this.attackCooldown=1400;
      this.poisonDuration=6000;
      this.poisonTickDamage=2;
    }
    if(this.type==='oneyes'){
      this.attackCooldown=1600;
      this.keepAway=300;
      this.preferRange=520;
    }
    if(this.type==='boss4'){
      this.width=Math.round(225*1.2);
      this.height=Math.round(230*1.2);
      this.attackCooldown=950;
      this.beamCooldown=12000;
      this.lastBeam=Date.now()-this.beamCooldown;
      this.isChargingBeam=false;
    }

  }
  update(player){
    if(Date.now()<this.spawnFreezeUntil)return;
    // Global stun (e.g., Hendel hammer): freeze AI/movement briefly
    if(this.stunnedUntil && Date.now() < this.stunnedUntil){
      this.vx = 0; this.vy = 0;
      return;
    }
    player = getPreferredTarget(this, player);
    const now=Date.now();

    const cx=this.x+this.width/2;
    const cy=this.y+this.height/2;
    const px=player.x+player.width/2;
    const py=player.y+player.height/2;

    let dx=px-cx;
    let dy=py-cy;
    let dist=Math.hypot(dx,dy)||1;

    // Default: chase
    let nx=dx/dist;
    let ny=dy/dist;

    // OneEyes: keep distance + shoot lasers
    if(this.type==='oneyes'){
      // keep away if too close
      if(dist < (this.keepAway||300)){
        nx = -nx; ny = -ny;
      } else if(dist > (this.preferRange||520)){
        // slightly approach if too far
        // nx,ny already towards player
      } else {
        // strafe / small drift
        const t = nx; nx = -ny*0.7; ny = t*0.7;
      }

      this.vx = nx*this.speed;
      this.vy = ny*this.speed;

      // shoot laser (1s duration), with higher cooldown
      if(dist>220 && (now-this.lastAttack)>this.attackCooldown){
        const angle=Math.atan2(dy,dx);
        spawnLaser({
          owner:this,
          x:cx, y:cy,
          angle,
          length:650,
          width:18,
          ttl:1000,
          damage:15,
          kind:'oneyes',
          chargeMs:0
        });
        createParticles(cx,cy,'#74b9ff',16,4);
        this.lastAttack=now;
      }
    }

    // Boss4: slow melee + photon beam every 12s
    else if(this.type==='boss4'){
      // During charge, slow down a lot
      if(this.isChargingBeam){
        this.vx *= 0.8;
        this.vy *= 0.8;
      } else {
        // chase slowly
        this.vx = nx*this.speed*0.92;
        this.vy = ny*this.speed*0.92;
      }

      // melee hit
      const hitRangeBoss4 = 70 + Math.max(this.width,this.height)*0.35;
      if( (aabbDist2(this.x,this.y,this.width,this.height, player.x,player.y,player.width,player.height) <= hitRangeBoss4*hitRangeBoss4) && (now-this.lastAttack)>this.attackCooldown && !player.isDashing){
        player.takeDamage(this.damage, this);
        this.lastAttack=now;
        createParticles(player.x,player.y,'#e17055',14,4);
      }

      // photon beam
      if((now-this.lastBeam) >= (this.beamCooldown||12000) && !this.isChargingBeam){
        this.isChargingBeam=true;
        this.lastBeam=now;
        const angle=Math.atan2(dy,dx);
        // charge + beam
        spawnLaser({
          owner:this,
          x:cx, y:cy,
          angle,
          length:760,
          width:75,
          ttl:1000,
          damage:70,
          kind:'photon',
          chargeMs:500,
          trackPlayer:true
        });
        // visual charge
        createParticles(cx,cy,'#f1c40f',40,6);
        shakeScreen();
        setTimeout(()=>{ this.isChargingBeam=false; }, 900);
      }
    }

    // Veleno: melee + non-stack poison
    else {
      this.vx = nx*this.speed;
      this.vy = ny*this.speed;

      // melee attack
      if(dist<60 && (now-this.lastAttack)>this.attackCooldown && !player.isDashing){
        if(this.type==='veleno'){
          player.takeDamage(15, this);
          // apply poison only if not already poisoned (non-stackable)
          if(!player.poisonUntil || now >= player.poisonUntil){
            player.poisonUntil = now + (this.poisonDuration||6000);
            player.poisonTickLast = now;
            player.poisonTickDamage = this.poisonTickDamage||2;
            createParticles(player.x,player.y,'#00b894',26,4);
          } else {
            // hit without re-applying poison
            createParticles(player.x,player.y,'#00b894',10,3);
          }
        } else {
          player.takeDamage(this.damage, this);
        }
        this.lastAttack=now;
      }
    }

    this.x+=this.vx;this.y+=this.vy;
    // boundaries
    if(this.x<0)this.x=0;if(this.x+this.width>canvas.width)this.x=canvas.width-this.width;
    if(this.y<0)this.y=0;if(this.y+this.height>canvas.height-30)this.y=canvas.height-30-this.height;
  }
  draw(){
    const imgKey = (this.type==='boss' || this.type==='boss1') ? 'boss1' : this.type;
    const img = enemyImages[imgKey];
    if(img && img.complete){
      ctx.drawImage(img,this.x,this.y,this.width,this.height);
    } else {
      const colors={slime:'#2ecc71',drone:'#95a5a6',mech:'#e67e22',shadow:'#9b59b6',boss:'#e74c3c',shooter:'#95a5a6',attacker:'#e67e22',boss2:'#e74c3c',boss3:'#e74c3c'};
      ctx.fillStyle=colors[this.type]||'#e74c3c';
      ctx.fillRect(this.x,this.y,this.width,this.height);
    }
    const hpPercent=this.hp/this.maxHP;
    ctx.fillStyle='#333';ctx.fillRect(this.x,this.y-10,this.width,5);
    ctx.fillStyle=hpPercent>0.5?'#2ecc71':hpPercent>0.25?'#f39c12':'#e74c3c';
    ctx.fillRect(this.x,this.y-10,this.width*hpPercent,5);
  }
}

class ShooterEnemy extends Enemy{
  constructor(type,level){super(type,level);this.shootCooldown=Math.max(600,1800-level*40);this.lastShoot=0;this.bulletSpeed=5+level*0.15}
  update(player){
    if(Date.now()<this.spawnFreezeUntil)return;
    if(this.stunnedUntil && Date.now() < this.stunnedUntil){
      this.vx = 0; this.vy = 0;
      return;
    }
    player = getPreferredTarget(this, player);
    const dx=(player.x+player.width/2)-(this.x+this.width/2);
    const dy=(player.y+player.height/2)-(this.y+this.height/2);
    const dist=Math.hypot(dx,dy);
    if(dist<220){const nx=dx/(dist||1);const ny=dy/(dist||1);this.vx=-nx*this.speed;this.vy=-ny*this.speed}
    else if(dist>360){const nx=dx/(dist||1);const ny=dy/(dist||1);this.vx=nx*this.speed;this.vy=ny*this.speed}
    else{this.vx*=0.9;this.vy*=0.9}
    this.x+=this.vx;this.y+=this.vy;
    if(this.x<0)this.x=0;if(this.x+this.width>canvas.width)this.x=canvas.width-this.width;
    if(this.y<0)this.y=0;if(this.y+this.height>canvas.height-30)this.y=canvas.height-30-this.height;
    if(Date.now()-this.lastShoot>this.shootCooldown){
      this.lastShoot=Date.now();
      const len=Math.hypot(dx,dy)||1;
      const vx=(dx/len)*this.bulletSpeed;const vy=(dy/len)*this.bulletSpeed;
      spawnProjectile({
        x:this.x+this.width/2,y:this.y+this.height/2,
        vx,vy,damage:Math.max(1,Math.round(this.damage*0.6)),ttl:4000,
        color:'#ffd54f',radius:6,friendly:false,source:this
      })
    }
  }
  draw(){
    const img = enemyImages['shooter'];
    if(img && img.complete) ctx.drawImage(img,this.x,this.y,this.width,this.height);
    else super.draw();
    const hpPercent=this.hp/this.maxHP;
    ctx.fillStyle='#333';ctx.fillRect(this.x,this.y-10,this.width,5);
    ctx.fillStyle=hpPercent>0.5?'#2ecc71':hpPercent>0.25?'#f39c12':'#e74c3c';
    ctx.fillRect(this.x,this.y-10,this.width*hpPercent,5);
  }
}


class ArcherEnemy extends Enemy{
  constructor(type,level){
    super(type,level);
    this.shootCooldown=Math.max(650, 1250 - level*18);
    this.lastShoot=0;
    this.arrowSpeed=9.2 + level*0.20;
    this.keepMin=520; // very far
    this.keepMax=700;
  }
  update(player){
    if(Date.now()<this.spawnFreezeUntil)return;
    if(this.stunnedUntil && Date.now() < this.stunnedUntil){
      this.vx = 0; this.vy = 0;
      return;
    }
    player = getPreferredTarget(this, player);
    const now=Date.now();
    const dx=(player.x+player.width/2)-(this.x+this.width/2);
    const dy=(player.y+player.height/2)-(this.y+this.height/2);
    const dist=Math.hypot(dx,dy)||1;

    // Keep far distance
    if(dist < this.keepMin){
      const nx=dx/dist, ny=dy/dist;
      this.vx = -nx*this.speed*1.05;
      this.vy = -ny*this.speed*1.05;
    } else if(dist > this.keepMax){
      const nx=dx/dist, ny=dy/dist;
      this.vx = nx*this.speed*0.95;
      this.vy = ny*this.speed*0.95;
    } else {
      this.vx*=0.90; this.vy*=0.90;
    }

    this.x+=this.vx; this.y+=this.vy;
    if(this.x<0)this.x=0;if(this.x+this.width>canvas.width)this.x=canvas.width-this.width;
    if(this.y<0)this.y=0;if(this.y+this.height>canvas.height-30)this.y=canvas.height-30-this.height;

    if(now-this.lastShoot>this.shootCooldown){
      this.lastShoot=now;
      const nx=dx/dist, ny=dy/dist;
      const vx=nx*this.arrowSpeed;
      const vy=ny*this.arrowSpeed;
      spawnProjectile({
        x:this.x+this.width/2,
        y:this.y+this.height/2,
        vx, vy,
        friendly:false,
        source:this,
        damage:Math.max(8, Math.round(this.damage*0.85)),
        ttl:3200,
        color:'#e0e0e0',
        radius:4,
        shape:'rect',
        w:18,
        h:4,
        angle:Math.atan2(vy,vx),
        onHitPlayer:(pl)=>{ if(pl && typeof pl.applySlow==='function') pl.applySlow(0.20, 2500); }
      });
    }
  }
  draw(){
    const img = enemyImages['archer'];
    if(img && img.complete) ctx.drawImage(img,this.x,this.y,this.width,this.height);
    else super.draw();
    const hpPercent=this.hp/this.maxHP;
    ctx.fillStyle='#333';ctx.fillRect(this.x,this.y-10,this.width,5);
    ctx.fillStyle=hpPercent>0.5?'#2ecc71':hpPercent>0.25?'#f39c12':'#e74c3c';
    ctx.fillRect(this.x,this.y-10,this.width*hpPercent,5);
  }
}

class GlacialEnemy extends Enemy{
  constructor(type,level){
    super(type,level);
    this.attackCooldown=Math.max(2100, 3400 - level*35);
    this.lastAttack=0;
    this.coneDuration=2000;
    this.coneRange=430;
    this.coneAngle=Math.PI/6; // 30¬∞ total
    this.coneActiveUntil=0;
    this.coneDir=0;
    this._coneInsideMs=0;
    this._coneLastCheck=0;
    this._coneLastTick=0;
    this._lastRegenAt=0;
    this.keepMin=280;
    this.keepMax=440;
  }
  update(player){
    if(Date.now()<this.spawnFreezeUntil)return;
    if(this.stunnedUntil && Date.now() < this.stunnedUntil){
      this.vx = 0; this.vy = 0;
      return;
    }
    player = getPreferredTarget(this, player);
    const now=Date.now();

    // Regen: if not hit for 5s, heal 15 (can repeat every 5s)
    const lastHit=this._lastHitAt||0;
    if(now-lastHit>=5000 && now-(this._lastRegenAt||0)>=5000 && this.hp<this.maxHP){
      this.hp=Math.min(this.maxHP, this.hp+15);
      this._lastRegenAt=now;
      createParticles(this.x+this.width/2,this.y+this.height/2,'#74b9ff',12,4);
    }

    const dx=(player.x+player.width/2)-(this.x+this.width/2);
    const dy=(player.y+player.height/2)-(this.y+this.height/2);
    const dist=Math.hypot(dx,dy)||1;

    // Keep mid distance
    if(dist < this.keepMin){
      const nx=dx/dist, ny=dy/dist;
      this.vx = -nx*this.speed*1.08;
      this.vy = -ny*this.speed*1.08;
    } else if(dist > this.keepMax){
      const nx=dx/dist, ny=dy/dist;
      this.vx = nx*this.speed*0.92;
      this.vy = ny*this.speed*0.92;
    } else {
      this.vx*=0.92; this.vy*=0.92;
    }

    this.x+=this.vx; this.y+=this.vy;
    if(this.x<0)this.x=0;if(this.x+this.width>canvas.width)this.x=canvas.width-this.width;
    if(this.y<0)this.y=0;if(this.y+this.height>canvas.height-30)this.y=canvas.height-30-this.height;

    // Start cone attack
    if(now-this.lastAttack>this.attackCooldown){
      this.lastAttack=now;
      this.coneActiveUntil=now+this.coneDuration;
      this.coneDir=Math.atan2(dy,dx);
      this._coneInsideMs=0;
      this._coneLastCheck=now;
      this._coneLastTick=0;
    }

    // Cone damage while active
    if(this.coneActiveUntil && now < this.coneActiveUntil){
      const dt = now - (this._coneLastCheck || now);
      this._coneLastCheck = now;

      // check player inside cone
      const px=player.x+player.width/2, py=player.y+player.height/2;
      const ex=this.x+this.width/2, ey=this.y+this.height/2;
      const vx=px-ex, vy=py-ey;
      const pdist=Math.hypot(vx,vy)||1;
      const ang=Math.atan2(vy,vx);
      let diff=Math.abs(ang-this.coneDir);
      if(diff>Math.PI) diff=2*Math.PI-diff;

      const inside = (pdist<=this.coneRange) && (diff <= (this.coneAngle/2));

      if(inside){
        this._coneInsideMs += dt;
        // damage ticks every 250ms, increasing while inside
        if(!this._coneLastTick) this._coneLastTick = now;
        if(now - this._coneLastTick >= 250){
          this._coneLastTick = now;
          const insideSec = this._coneInsideMs/1000;
          const base = Math.max(3, Math.round(this.damage*0.20));
          const ramp = Math.round(insideSec * 2.2); // gradual increase
          const dmg = Math.min(22, base + ramp);
          player.takeDamage(dmg, this);
          createParticles(player.x,player.y,'#b2bec3',8,3);
        }
      } else {
        this._coneInsideMs = 0;
      }
    }
  }
  draw(){
    const img = enemyImages['glacial'];
    if(img && img.complete) ctx.drawImage(img,this.x,this.y,this.width*1.5,this.height*1.5);
    else super.draw();

    // Cone visual
    const now=Date.now();
    if(this.coneActiveUntil && now < this.coneActiveUntil){
      const cx=this.x+this.width/2, cy=this.y+this.height/2;
      const a0=this.coneDir - this.coneAngle/2;
      const a1=this.coneDir + this.coneAngle/2;
      ctx.save();
      ctx.globalAlpha=0.28;
      ctx.fillStyle='rgba(180,220,255,0.9)';
      ctx.beginPath();
      ctx.moveTo(cx,cy);
      ctx.arc(cx,cy,this.coneRange,a0,a1,false);
      ctx.closePath();
      ctx.fill();
      ctx.globalAlpha=0.12;
      ctx.strokeStyle='rgba(180,220,255,0.9)';
      ctx.lineWidth=4;
      ctx.beginPath();
      ctx.moveTo(cx,cy);
      ctx.arc(cx,cy,this.coneRange,a0,a1,false);
      ctx.closePath();
      ctx.stroke();
      ctx.restore();
    }

    const hpPercent=this.hp/this.maxHP;
    ctx.fillStyle='#333';ctx.fillRect(this.x,this.y-10,this.width,5);
    ctx.fillStyle=hpPercent>0.5?'#2ecc71':hpPercent>0.25?'#f39c12':'#e74c3c';
    ctx.fillRect(this.x,this.y-10,this.width*hpPercent,5);
  }
}


class AttackReturnEnemy extends Enemy{
  constructor(type,level){super(type,level);this.homeX=this.x;this.homeY=this.y;this.state='idle';this.attackRange=60;this.attackCooldown=2200;this.lastAttackTime=0;this.attackSpeed=this.speed*2.5}
  update(player){
    if(Date.now()<this.spawnFreezeUntil)return;
    if(this.stunnedUntil && Date.now() < this.stunnedUntil){
      this.vx = 0; this.vy = 0;
      return;
    }
    player = getPreferredTarget(this, player);
    const dx=(player.x+player.width/2)-(this.x+this.width/2);
    const dy=(player.y+player.height/2)-(this.y+this.height/2);
    const distToPlayer=Math.hypot(dx,dy);
    if(this.state==='idle'){
      const wanderX=Math.sin(Date.now()/1000+this.homeX)*0.3;const wanderY=Math.cos(Date.now()/1000+this.homeY)*0.3;
      this.vx=wanderX*this.speed;this.vy=wanderY*this.speed;
      if(distToPlayer<220&&Date.now()-this.lastAttackTime>this.attackCooldown)this.state='attack'
    }
    else if(this.state==='attack'){
      const nx=dx/(distToPlayer||1);const ny=dy/(distToPlayer||1);
      this.vx=nx*this.attackSpeed;this.vy=ny*this.attackSpeed;
      if(distToPlayer<this.attackRange){player.takeDamage(this.damage, this);this.lastAttackTime=Date.now();this.state='returning'}
    }
    else if(this.state==='returning'){
      const hx=this.homeX-this.x;const hy=this.homeY-this.y;const distHome=Math.hypot(hx,hy);
      if(distHome>6){
        const nx=hx/(distHome||1);const ny=hy/(distHome||1);
        this.vx=nx*this.speed;this.vy=ny*this.speed
      }else{this.vx=0;this.vy=0;this.state='idle'}
    }
    this.x+=this.vx;this.y+=this.vy;
    if(this.x<0)this.x=0;if(this.x+this.width>canvas.width)this.x=canvas.width-this.width;
    if(this.y<0)this.y=0;if(this.y+this.height>canvas.height-30)this.y=canvas.height-30-this.height;
  }
  draw(){
    const img = enemyImages['attacker'];
    if(img && img.complete) ctx.drawImage(img,this.x,this.y,this.width,this.height);
    else super.draw();
    const hpPercent=this.hp/this.maxHP;
    ctx.fillStyle='#333';ctx.fillRect(this.x,this.y-10,this.width,5);
    ctx.fillStyle=hpPercent>0.5?'#2ecc71':hpPercent>0.25?'#f39c12':'#e74c3c';
    ctx.fillRect(this.x,this.y-10,this.width*hpPercent,5);
  }
}

class BossEnemy extends Enemy{
  constructor(type,level){
    super(type,level);
    this.phase=0;
    this.superCooldown=12000;
    this.lastSuper=0;
    this.superActive=false;
    this.superStart=0;
    this.superDuration=3000;
    this.bulletTimer=0;
    this.attackCooldown=1800;
    this.lastAttack=0;
    this.width=Math.round(200*1.2);
    this.height=Math.round(200*1.2);
  }
  update(player){
    if(Date.now()<this.spawnFreezeUntil)return;
    if(this.stunnedUntil && Date.now() < this.stunnedUntil){
      this.vx = 0; this.vy = 0;
      return;
    }
    player = getPreferredTarget(this, player);
    const cx=this.x+this.width/2, cy=this.y+this.height/2;
    const px=player.x+player.width/2, py=player.y+player.height/2;
    const dx=px-cx; const dy=py-cy; const dist=Math.hypot(dx,dy);
    const attackRange=60;
    const hitRange = attackRange + Math.max(this.width,this.height)*0.35;
    // Range effettivo: include dimensioni del nemico per evitare "zone sicure" ai bordi (clamp)
    if(dist>attackRange){
      const nx=dx/(dist||1);const ny=dy/(dist||1);
      this.vx=nx*this.speed;this.vy=ny*this.speed;
    } else {

      this.vx*=0.9;this.vy*=0.9;
            if(Date.now()-this.lastAttack>this.attackCooldown&&!player.isDashing){
        // Se siamo clamped contro un bordo, potremmo non arrivare mai a dist<=attackRange puro.
        // Usiamo hitRange per consentire il colpo quando siamo realisticamente "a contatto".
        if( (aabbDist2(this.x,this.y,this.width,this.height, player.x,player.y,player.width,player.height) <= hitRange*hitRange) ){
          player.takeDamage(this.damage, this);
          this.lastAttack=Date.now();
        }
      }
    }
    this.x+=this.vx;this.y+=this.vy;
    if(this.x<0)this.x=0;if(this.x+this.width>canvas.width)this.x=canvas.width-this.width;
    if(this.y<0)this.y=0;if(this.y+this.height>canvas.height-30)this.y=canvas.height-30-this.height;
    if(Date.now()-this.lastSuper>this.superCooldown){
      this.lastSuper=Date.now();this.superActive=true;this.superStart=Date.now()
    }
    if(this.superActive&&Date.now()-this.superStart>this.superDuration)this.superActive=false;
  }
  draw(){
    const key = (this.type==='boss' || this.type==='boss1') ? 'boss1' : (this.type==='boss2' ? 'boss2' : (this.type==='boss3' ? 'boss3' : this.type));
    const img = enemyImages[key];
    if(img && img.complete) ctx.drawImage(img,this.x,this.y,this.width,this.height);
    else super.draw();
    const hpPercent=this.hp/this.maxHP;
    ctx.fillStyle='#333';ctx.fillRect(this.x,this.y-10,this.width,5);
    ctx.fillStyle=hpPercent>0.5?'#2ecc71':hpPercent>0.25?'#f39c12':'#e74c3c';
    ctx.fillRect(this.x,this.y-10,this.width*hpPercent,5);
  }
}
class Boss5Enemy extends Enemy{
  constructor(type,level){
    super(type,level);

    // Dimensioni boss
    this.width=Math.round(245*1.2);
    this.height=Math.round(245*1.2);

    // Stat fisse richieste
    this.maxHP=800;
    this.hp=800;

    // "Non troppo veloce"
    this.speed=2.99*0.75; // ~1.69 (leggermente pi√π veloce)

    // Danno base (usato solo per eventuale contatto)
    this.damage=50;

    // --- Attacco: colpo ad ascia a ventaglio 80¬∞ (sweep sinistra->destra) ---
    this.fanRange=470;                 // raggio del ventaglio
    this.fanAngleDeg=142;               // ampiezza ventaglio
    this.swingDuration=1000;           // sweep lento (ms)
    this.swingCooldown=1000;           // cooldown un po' pi√π corto
    this.lastSwing=Date.now()-1800;    // piccolo offset
    this.swingActive=false;
    this.swingStart=0;
    this.swingCenterAngle=0;
    this.swingStartAngle=0;
    this.swingEndAngle=0;
    this.lastSwingTick=0;

    // --- Passiva: ogni 28s respinge + cura 50 ---
    this.passiveInterval=20000;
    this.nextPassive=Date.now()+this.passiveInterval;
    this.passiveFxUntil=0;

    // Area della passiva/super (raggio)
    this.passiveRadius=750; // aumentata
  }

  startSwingTowards(player){
    const cx=this.x+this.width/2, cy=this.y+this.height/2;
    const px=player.x+player.width/2, py=player.y+player.height/2;
    const baseAng=Math.atan2(py-cy, px-cx);

    const half=(this.fanAngleDeg*Math.PI/180)/2;
    this.swingCenterAngle=baseAng;
    // parte dall'estremit√† sinistra del ventaglio e arriva a destra
    this.swingStartAngle=baseAng-half;
    this.swingEndAngle=baseAng+half;

    this.swingActive=true;
    this.swingStart=Date.now();
    this.lastSwingTick=0;

    // piccolo telegraph: particelle
    createParticles(cx,cy,'#e74c3c',26,6);
  }

  doPassive(player){
    const now=Date.now();
    this.nextPassive = now + this.passiveInterval;

    // FX visivo
    const cx=this.x+this.width/2, cy=this.y+this.height/2;
    this.passiveFxUntil = now + 650;
    createParticles(cx,cy,'#00e5ff',55,8);
    shakeScreen();

    // Cura boss
    this.hp = Math.min(this.maxHP, this.hp + 80);

    // Effetto sul player SOLO se dentro l'area della super/passiva
    const px=player.x+player.width/2, py=player.y+player.height/2;
    const dx=px-cx, dy=py-cy;
    const dist=Math.hypot(dx,dy)||1;

    if(dist <= (this.passiveRadius||420)){
      // Knockback player (senza danno)
      const nx=dx/dist, ny=dy/dist;
      const pushDist=240; // "tanti pixel"
      player.x += nx*pushDist;
      player.y += ny*pushDist;

      // Slow: -50% velocit√† per 2s
      if(player && typeof player.applySlow==='function'){
        player.applySlow(0.60, 3200);
      }

      // clamp in arena
      player.x=Math.max(0, Math.min(canvas.width-player.width, player.x));
      player.y=Math.max(0, Math.min(canvas.height-player.height, player.y));
    }
  }

  applySwingDamage(player, now){
    // tick damage durante lo sweep, senza colpire mentre il player √® in dash
    if(player.isDashing) return;
    if(this.lastSwingTick && (now-this.lastSwingTick)<240) return;

    const cx=this.x+this.width/2, cy=this.y+this.height/2;
    const px=player.x+player.width/2, py=player.y+player.height/2;
    const dx=px-cx, dy=py-cy;
    const dist=Math.hypot(dx,dy);

    if(dist>this.fanRange) return;

    // angolo player
    const ang=Math.atan2(dy,dx);

    // calcola dove siamo nello sweep
    const t=Math.max(0, Math.min(1, (now-this.swingStart)/this.swingDuration));
    const cur=this.swingStartAngle + (this.swingEndAngle-this.swingStartAngle)*t;

    // se lo sweep √® verso destra, consideriamo la parte gi√† "coperta" sinistra->cur
    const minA=Math.min(this.swingStartAngle, cur);
    const maxA=Math.max(this.swingStartAngle, cur);

    // normalizza per confronto (gestione wrap a -pi/pi)
    function norm(a){
      while(a<-Math.PI) a+=Math.PI*2;
      while(a> Math.PI) a-=Math.PI*2;
      return a;
    }
    const a=norm(ang);
    const aMin=norm(minA);
    const aMax=norm(maxA);

    let inside=false;
    if(aMin<=aMax){
      inside = (a>=aMin && a<=aMax);
    }else{
      // wrap-around
      inside = (a>=aMin || a<=aMax);
    }

    if(inside){
      this.lastSwingTick=now;
      player.takeDamage(18, this);
    }
  }

  update(player){
    if(Date.now()<this.spawnFreezeUntil)return;
    if(this.stunnedUntil && Date.now() < this.stunnedUntil){
      this.vx = 0; this.vy = 0;
      return;
    }
    player = getPreferredTarget(this, player);

    const now=Date.now();
    const cx=this.x+this.width/2, cy=this.y+this.height/2;
    const px=player.x+player.width/2, py=player.y+player.height/2;
    const dx=px-cx, dy=py-cy;
    const dist=Math.hypot(dx,dy)||1;

    // Passiva (ogni 28s)
    if(now>=this.nextPassive){
      this.doPassive(player);
    }

    // Movimento: inseguimento leggero, ma non troppo aggressivo durante lo swing
    if(!this.swingActive){
      const nx=dx/dist, ny=dy/dist;
      const prefer=210; // distanza "comoda"
      if(dist>prefer){
        this.vx=nx*this.speed;
        this.vy=ny*this.speed;
      }else{
        // drift lento per non essere statico
        this.vx*=0.92;
        this.vy*=0.92;
      }
    }else{
      // durante lo swing resta pi√π "fermo"
      this.vx*=0.85;
      this.vy*=0.85;
    }

    this.x+=this.vx; this.y+=this.vy;

    // clamp arena
    this.x=Math.max(20, Math.min(canvas.width-this.width-20, this.x));
    this.y=Math.max(40, Math.min(canvas.height-this.height-20, this.y));

    // Avvia swing se pronto e player in range
    if(!this.swingActive && dist<=this.fanRange && (now-this.lastSwing)>=this.swingCooldown){
      this.lastSwing=now;
      this.startSwingTowards(player);
    }

    // gestione swing attivo
    if(this.swingActive){
      this.applySwingDamage(player, now);
      if(now-this.swingStart>=this.swingDuration){
        this.swingActive=false;
      }
    }

    // contatto ravvicinato (solo se non in dash) - leggero
    const hitRangeTouch = 55 + Math.max(this.width,this.height)*0.25;
    if( (aabbDist2(this.x,this.y,this.width,this.height, player.x,player.y,player.width,player.height) <= hitRangeTouch*hitRangeTouch) && !player.isDashing && !this.swingActive){
      if(!this._lastTouch) this._lastTouch=0;
      if(now-this._lastTouch>900){
        player.takeDamage(14, this);
        this._lastTouch=now;
      }
    }
  }

  draw(){
    const img = enemyImages.boss5;
    if(img && img.complete) ctx.drawImage(img,this.x,this.y,this.width,this.height);
    else super.draw();

    // HP bar
    const hpPercent=this.hp/this.maxHP;
    ctx.fillStyle='#333';ctx.fillRect(this.x,this.y-10,this.width,5);
    ctx.fillStyle=hpPercent>0.5?'#2ecc71':hpPercent>0.25?'#f39c12':'#e74c3c';
    ctx.fillRect(this.x,this.y-10,this.width*hpPercent,5);

    const now=Date.now();
    const cx=this.x+this.width/2, cy=this.y+this.height/2;

    // FX passiva
    if(now<this.passiveFxUntil){
      ctx.save();
      ctx.globalAlpha=0.45;
      ctx.lineWidth=6;
      ctx.strokeStyle='rgba(0,229,255,0.85)';
      ctx.beginPath();
      ctx.arc(cx,cy, (this.passiveRadius||this.width*0.75), 0, Math.PI*2);
      ctx.stroke();
      ctx.restore();
    }

    // Disegna il ventaglio durante lo swing (telegraph)
    if(this.swingActive){
      const t=Math.max(0, Math.min(1, (now-this.swingStart)/this.swingDuration));
      const cur=this.swingStartAngle + (this.swingEndAngle-this.swingStartAngle)*t;

      ctx.save();
      ctx.globalAlpha=0.18;
      ctx.fillStyle='#e74c3c';
      ctx.beginPath();
      ctx.moveTo(cx,cy);
      ctx.arc(cx,cy, this.fanRange, this.swingStartAngle, cur, false);
      ctx.closePath();
      ctx.fill();

      ctx.globalAlpha=0.65;
      ctx.lineWidth=4;
      ctx.strokeStyle='rgba(231,76,60,0.9)';
      ctx.beginPath();
      ctx.arc(cx,cy, this.fanRange, this.swingStartAngle, this.swingEndAngle, false);
      ctx.stroke();
      ctx.restore();
    }
  }
}


function spawnEnemiesForLevel(level){
  enemies.length=0;
  const lvl = Math.max(1, Math.min(level, levelConfigs.length));
  const cfg=levelConfigs[lvl-1];
  // Bestiario: segna il tipo di nemico/boss come gi√† sfidato (sblocco globale)
  markEnemySeen(cfg.enemyType);

  const count=cfg.enemyCount;
  for(let i=0;i<count;i++){
    let e;
    if(cfg.enemyType==='shooter') e=new ShooterEnemy(cfg.enemyType,lvl);
    else if(cfg.enemyType==='attacker') e=new AttackReturnEnemy(cfg.enemyType,lvl);
    else if(cfg.enemyType==='archer') e=new ArcherEnemy(cfg.enemyType,lvl);
    else if(cfg.enemyType==='glacial') e=new GlacialEnemy(cfg.enemyType,lvl);
    else if(cfg.enemyType==='boss1' || cfg.enemyType==='boss2' || cfg.enemyType==='boss3') e=new BossEnemy(cfg.enemyType,lvl);
    else if(cfg.enemyType==='boss5') e=new Boss5Enemy(cfg.enemyType,lvl);
    else e=new Enemy(cfg.enemyType,lvl);
    enemies.push(e);
  }
  spawnPickupsForLevel(lvl);
}

function updateBackgroundForLevel(level){
  // Levels 1-6: default bg, Levels 7-15: dark bg, Levels 16-20: final bg, Levels 21+: ice bg
  let tier=0;
  if(level>=21) tier=3;
  else if(level>=16) tier=2;
  else if(level>=7) tier=1;

  const applyTier=()=>{
    if(tier===3){
      bgDark.style.backgroundImage=`url('${URL_ICE}')`;
      bgDefault.style.opacity='0';
      bgDark.style.opacity='1';
    }
    else if(tier===2){
      bgDark.style.backgroundImage=`url('${URL_FINAL}')`;
      bgDefault.style.opacity='0';
      bgDark.style.opacity='1';
    } else if(tier===1){
      bgDark.style.backgroundImage=`url('${URL_DARK}')`;
      bgDefault.style.opacity='0';
      bgDark.style.opacity='1';
    } else {
      bgDefault.style.opacity='1';
      bgDark.style.opacity='0';
    }
    _bgTier=tier;
  };

  // Dissolvenza: quando si entra nella "fase finale" (dal 15 -> 16) o cambia tier
  if(fadeOverlay && tier!==_bgTier){
    fadeOverlay.style.opacity='1';
    setTimeout(()=>{
      applyTier();
      setTimeout(()=>{ fadeOverlay.style.opacity='0'; }, 80);
    }, 380);
  } else {
    applyTier();
  }
}

function startGame(){
  currentLevel=1;score=0;kills=0;timer=levelConfigs[0].time;
  player=new Player(selectedCharacter||'jimmy');
  enemies=[];particles=[];projectiles=[];lasers=[];tempBeams=[];pickups=[];wolves=[];
  spawnEnemiesForLevel(currentLevel);
  updateBackgroundForLevel(currentLevel);
  document.getElementById('mainMenu').style.display='none';
  const ss=document.getElementById('startScreen');
  if(ss) ss.style.display='none';
  document.getElementById('uiOverlay').style.display='block';
  document.getElementById('scoreDisplay').style.display='block';
  document.getElementById('killsDisplay').style.display='block';
  document.getElementById('timerDisplay').style.display='block';
  document.getElementById('levelDisplay').style.display='block';
  document.getElementById('superCooldown').style.display='block';
  gameState='playing';
}

function endGame(won){
  if(gameState!=='playing') return;
  gameState='ended';
  document.getElementById('endScreen').style.display='block';
  const kd=document.getElementById('killsDisplay'); if(kd) kd.style.display='none';
  document.getElementById('endTitle').textContent=won?'VICTORY':'GAME OVER';
  document.getElementById('endMessage').textContent=`Score Finale: ${score}`;
  try{ const ek=document.getElementById('endKills'); if(ek) ek.textContent=`Kill: ${kills||0}`; }catch(e){}
  document.getElementById('endSub').textContent=`Hai raggiunto il Livello ${currentLevel}`;
  const rec=records[selectedCharacter]||0;
  if(score>rec){records[selectedCharacter]=score;saveRecords();}
  document.getElementById('recordMessage').textContent=`Record Personaggio: ${records[selectedCharacter]||0}`;
}

function nextLevel(){

// Easy mode sustain: after clearing a level, heal between levels
const clearedLevel = currentLevel;
if(difficultyMode==='easy' && player){
  const healAmt = (clearedLevel % 5 === 0) ? (player.maxHP) : (player.maxHP * 0.25);
  player.hp = Math.min(player.maxHP, (clearedLevel % 5 === 0) ? player.maxHP : (player.hp + healAmt));
}
  if(currentLevel < levelConfigs.length){
    currentLevel++;
    spawnEnemiesForLevel(currentLevel);
    timer=levelConfigs[Math.max(0,currentLevel-1)].time;
    updateBackgroundForLevel(currentLevel);
  } else {
    endGame(true);
  }
}


function drawKaerithFireOverlay(now){
  if(!player || player.type!=='kaerith' || !player._kaerithFireUntil || now>=player._kaerithFireUntil) return;

  // overlay fiamme: flicker + embers
  const t = 1 - Math.max(0, Math.min(1, (player._kaerithFireUntil - now)/9000));
  ctx.save();
  ctx.globalAlpha = 0.18 + 0.10*Math.sin(now/70);
  ctx.fillStyle = '#ff3d00';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // ‚Äúlingue‚Äù di fuoco stilizzate (righe verticali random)
  ctx.globalAlpha = 0.10 + 0.06*Math.sin(now/55);
  for(let i=0;i<22;i++){
    const x = (Math.random()*canvas.width)|0;
    const h = 120 + Math.random()*260;
    const w = 14 + Math.random()*26;
    const y = canvas.height - h;
    ctx.fillRect(x,y,w,h);
  }

  // embers
  ctx.globalAlpha = 0.22;
  ctx.fillStyle = '#ffd180';
  for(let i=0;i<28;i++){
    const x = (Math.random()*canvas.width)|0;
    const y = (Math.random()*canvas.height)|0;
    ctx.fillRect(x,y,2,2);
  }
  ctx.restore();
}
function gameLoop(){
  requestAnimationFrame(gameLoop);
  if(gameState!=='playing')return;
  const now=Date.now();

  if(now-lastSecondTick>1000){
    lastSecondTick=now;
    timer--;
    if(timer<=0){
      timer=0;
      endGame(false);
return;
    }
  }

  if(player) player.update();
    updateHendelCrush();
  enemies.forEach(e=>{e.update(player)});
  updateWolves();
  // Marz Super zone tick damage/expansion
  updateMagicZone(now);
  updatePdorOrbs(now);
  updateParticles();
  updateIraFX();
  updateProjectiles();
  updateLasers();
  updateTempBeams();
  updateFuriaWaves();
  if(player) updatePickups(player);

  for(let i=enemies.length-1;i>=0;i--){
    if(enemies[i].hp<=0){
      dropStellarBonusAtIndexIfNeeded(i);
      const dead=enemies.splice(i,1)[0];
      applyScore(100*currentLevel);
      addKill(); createParticles(dead.x,dead.y,'#fff176',30,6);
    }
  }

  if(enemies.length===0){
    if(!levelAdvanceLock){
      levelAdvanceLock=true;

      // Evolution trigger: after defeating Boss at Level 15 (boss3), only Jimmy/Rooney/Jeff evolve permanently from Level 16 onward
      const canEvolve = player && (player.type==='jimmy' || player.type==='rooney' || player.type==='jeff');
      if(gameState==='playing' && currentLevel===15 && canEvolve && !player.evolved){
        triggerEvolutionThenNextLevel(player.type);
      } else {
        setTimeout(()=>{
          if(gameState==='playing') nextLevel();
          levelAdvanceLock=false;
        }, 200);
      }
    }
  }

  ctx.clearRect(0,0,canvas.width,canvas.height);
  if(shakeAmount>0){
    const sx=(Math.random()-0.5)*shakeAmount;const sy=(Math.random()-0.5)*shakeAmount;
    ctx.save();ctx.translate(sx,sy);shakeAmount*=0.9
  } else ctx.save();

    drawKaerithFireOverlay(now);

  // draw Marz Super zone behind entities
  drawMagicZone(now);
  drawPdorOrbs(now);
  enemies.forEach(e=>e.draw());
  drawWolves();
  if(player) player.draw();
  drawProjectiles();
  drawLasers();
  drawTempBeams();
  drawFuriaWaves();
  drawIraFX();
  drawParticles();
  drawHendelCrush();
    drawPickups();

  ctx.restore();

  // IRA screen tint flash
  if(iraScreenFlash>0){
    ctx.save();
    ctx.globalAlpha = Math.min(0.35, iraScreenFlash/40);
    ctx.fillStyle = '#7a0019';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.restore();
  }

  if(player){
    document.getElementById('hpText').textContent=Math.max(0,Math.round(player.hp));
    document.getElementById('hpFill').style.width=Math.max(0,Math.round((player.hp/player.maxHP)*100))+'%';
  } else {
    document.getElementById('hpText').textContent='0';
    document.getElementById('hpFill').style.width='0%';
  }

  document.getElementById('scoreDisplay').textContent=`Score: ${score}`;
  const kEl=document.getElementById('killsDisplay'); if(kEl) kEl.textContent=`Kill: ${kills}`;
  document.getElementById('timerDisplay').textContent=timer;
  document.getElementById('levelDisplay').textContent=`Level ${currentLevel}`;
  const superReady=(Date.now()-player.lastSuper>=player.superCooldown)?'Ready':Math.ceil((player.superCooldown-(Date.now()-player.lastSuper))/1000)+'s';
  document.getElementById('superCooldown').textContent=`Super: ${superReady}`;

// ===== BONUS TIMER HUD (dentro interfaccia di gioco) =====
const bonusBox=document.getElementById('bonusTimers');
if(bonusBox){
  const nowT=Date.now();
  const rows=[];

  const add=(label,until,color)=>{
    if(until && until>nowT){
      const t=Math.ceil((until-nowT)/1000);
      rows.push('<span style="color:'+color+'">'+label+': '+t+'s</span>');
    }
  };

  add('SCUDO', player.pickupShieldUntil, '#7fdfff');   // azzurro chiaro
  add('SPEED', player.speedBuffUntil, '#3498db');      // blu
  add('<span class="ira-glow">IRA</span>', player.baneSuperUntil, '#ff9800'); // arancione (Bane)
  add('FURIA', player.furiaHealUntil, '#ff00ff');      // fucsia
  add('ATK', player.attackBuffUntil, '#ff3b3b');       // rosso
  add('POISON', player.poisonUntil, '#4b0082');        // viola scuro

  if(rows.length){
    bonusBox.style.display='block';
    bonusBox.innerHTML=rows.join('<br>');
  }else{
    bonusBox.style.display='none';
    bonusBox.innerHTML='';
  }
}
// ===============================================
  if(player.attackBuffUntil) document.getElementById('atkBuffDisplay').textContent=Math.max(0,Math.ceil((player.attackBuffUntil-Date.now())/1000))+'s';
  else document.getElementById('atkBuffDisplay').textContent='0s';
}


function showEvoBanner(name){
  const el=document.getElementById('evoBanner');
  const txt=document.getElementById('evoBannerText');
  if(!el||!txt) return;
  txt.textContent = `${name.toUpperCase()} EVOLUTO!`;
  el.classList.remove('show');
  // force reflow to restart animation
  void el.offsetWidth;
  el.style.display='block';
  el.classList.add('show');
  setTimeout(()=>{ el.classList.remove('show'); el.style.display='none'; }, 980);
}

function triggerEvolutionThenNextLevel(charType){
  if(!player) return;
  // evolve + FX
  player.evolve();
  showEvoBanner(player.type);
  createParticles(player.x+player.width/2, player.y+player.height/2, '#fff176', 50, 6);
  shakeScreen();

  // delay a bit so the player sees the evolution, then go to next level
  setTimeout(()=>{
    if(gameState==='playing') nextLevel();
    levelAdvanceLock=false;
  }, 620);
}

window.addEventListener('keydown',e=>{
  const k=e.key.toLowerCase();
  keys[k]=true;
  if(k==='j'&&gameState==='playing'){ if(player && player.type!=='kaerith'){ player.attack(); } }
  if(k==='k'&&gameState==='playing'){player.superAttack()}
  if(k===' '&&gameState==='playing'){player.dodge()}
});
window.addEventListener('keyup',e=>{keys[e.key.toLowerCase()]=false;});

document.querySelectorAll('.character-card').forEach(card=>{
  card.addEventListener('click',()=>{
    const char=card.getAttribute('data-char');
    if(char==='tempostorm' && !allPrevAbove85k()){
      updateTempostormUnlockUI();
      return;
    }
    if(char==='voltryx' && !allThreeAbove50k()){
      // keep disabled
      updateVoltryxUnlockUI();
      return;
    }
    if(char==='kouvagia' && !voltryxAbove51k()){
      updateKouvagiaUnlockUI();
      return;
    }
    if(char==='salsy' && !allPrevAbove70k()){
      updateSalsyUnlockUI();
      return;
    }
    if(char==='marz' && !allPrevAboveMarz80k()){
      updateMarzUnlockUI();
      return;
    }
    if(char==='hecate' && !allPrevAboveHecate85k()){
      updateHecateUnlockUI();
      return;
    }
    if(char==='lucien' && !lucienUnlocked()){
      updateLucienUnlockUI();
      return;
    }
    if(char==='pdor' && !pdorUnlocked()){
      updatePdorUnlockUI();
      // show lock message popup
      const lockBox=document.getElementById('lockMessage');
      const lockText=document.getElementById('lockText');
      if(lockBox && lockText){
        lockText.innerText = "Personaggio BLOCCATO\nsi sblocca facendo 50.000\ncon marcus e lucien";
        lockBox.style.display='block';
      }
      return;
    }

    if(char==='bane' && !baneUnlocked()){
      updateBaneUnlockUI();
      // show lock message popup
      const lockBox=document.getElementById('lockMessage');
      const lockText=document.getElementById('lockText');
      if(lockBox && lockText){
        lockText.innerText = "Personaggio BLOCCATO\nSblocca facendo 50.000\ncon PDOR";
        lockBox.style.display='block';
      }
      
    if(char==='hendel' && !hendelUnlocked()){
      updateHendelUnlockUI();
      // show lock message popup
      const lockBox=document.getElementById('lockMessage');
      const lockText=document.getElementById('lockText');
      if(lockBox && lockText){
        lockText.innerText = "personaggio BLOCCATO  si sblocca facendo 50.000 con Bane";
        lockBox.style.display='block';
      }
      return;
    }
return;
    }

    document.querySelectorAll('.character-card').forEach(c=>c.classList.remove('selected'));
    card.classList.add('selected');
    selectedCharacter=char;
    updateMenuStatsDisplay(selectedCharacter);
  });
});

function updateMenuStatsDisplay(char){
  const s=characterStats[char];
  if(!s)return;
  document.getElementById(`menu-hp-${char}`).textContent=s.hp;
  document.getElementById(`menu-dmg-${char}`).textContent=
    char==='voltryx' ? `${Math.round(34*SUPER_DAMAGE_MULT)} (ranged AoE), ${50}x2 (melee)` :
    (char==='salsy' ? '33x2' :
     (char==='tempostorm' ? '40 (+30 se resta nel laser)' : (char==='marz' ? '40 / 50 / 60' : (char==='hecate' ? 'Freccia: colpo forte + 3 frecce' : (char==='lucien' ? '15x4' : (char==='pdor' ? 'Dardo: 50 (chain x5)' : (char==='bane' ? '‚Äî' : s.damage)))))));

}

/* === Start screen: choose difficulty mode === */
(function(){
  const startScreen=document.getElementById('startScreen');
  const mainMenu=document.getElementById('mainMenu');
  const hardBtn=document.getElementById('modeHardBtn');
  const easyBtn=document.getElementById('modeEasyBtn');
  if(startScreen && mainMenu){
    // default view
    startScreen.style.display='block';
  try{ updateAccountUI(); }catch(e){}
    mainMenu.style.display='none';
    gameState='start';
  }
  function goToMenu(mode){
    setDifficulty(mode);
    if(startScreen) startScreen.style.display='none';
    if(mainMenu) mainMenu.style.display='block';
    gameState='menu';
    updateMenuRecordsDisplay();
  }
  if(hardBtn) hardBtn.addEventListener('click', ()=>goToMenu('hard'));
  if(easyBtn) easyBtn.addEventListener('click', ()=>goToMenu('easy'));
})();

document.getElementById('startBtn').addEventListener('click',()=>{
  if(!selectedCharacter)selectedCharacter='jimmy';
  updateMenuRecordsDisplay();
  startGame();
});

const extraCharsBtn=document.getElementById('extraCharsBtn');
const extraCharacterSelect=document.getElementById('extraCharacterSelect');
if(extraCharsBtn && extraCharacterSelect){
  extraCharsBtn.addEventListener('click', ()=>{
    const isOpen = extraCharacterSelect.style.display !== 'none';
    extraCharacterSelect.style.display = isOpen ? 'none' : 'block';
  });
}


document.getElementById('restartBtn').addEventListener('click',()=>{
  document.getElementById('endScreen').style.display='none';
  startGame();
});
document.getElementById('menuBtn').addEventListener('click',()=>{
  const kd=document.getElementById('killsDisplay'); if(kd) kd.style.display='none';
  document.getElementById('endScreen').style.display='none';
  document.getElementById('mainMenu').style.display='block';
  gameState='menu';
  updateMenuRecordsDisplay();
});

function populateMenuStatsAll(){
  updateMenuStatsDisplay('jimmy');
  updateMenuStatsDisplay('rooney');
  updateMenuStatsDisplay('jeff');
  updateMenuStatsDisplay('voltryx');
  updateMenuStatsDisplay('kouvagia');
  updateMenuStatsDisplay('salsy');
  updateMenuStatsDisplay('tempostorm');
  updateMenuStatsDisplay('marz');
  updateMenuStatsDisplay('hecate');
  updateMenuStatsDisplay('marcus');
  updateMenuStatsDisplay('lucien');
  updateMenuStatsDisplay('pdor');
  updateMenuStatsDisplay('bane');
  updateMenuStatsDisplay('hendel');
}
populateMenuStatsAll();
updateMenuRecordsDisplay();
updateVoltryxUnlockUI();

gameLoop();
// --- Guida: apertura/chiusura e gestione stato di gioco ---
(function(){
  const guideImgBtn = document.getElementById('guideImgBtn');
  const guideModal = document.getElementById('guideModal');
  const guideClose = document.getElementById('guideClose');
  if(!guideImgBtn || !guideModal || !guideClose) return;
  let gameStateBeforeGuide = undefined;
  function showGuide(){
    guideModal.style.display = 'flex';
  updateGuideUnlockUI();
    guideModal.setAttribute('aria-hidden','false');
    if(typeof gameState !== 'undefined') gameStateBeforeGuide = gameState;
    gameState = 'menu';
    guideClose.focus();
    window._guideOpen = true;
  }
  function hideGuide(){
    guideModal.style.display = 'none';
    guideModal.setAttribute('aria-hidden','true');
    if(typeof gameStateBeforeGuide !== 'undefined') gameState = gameStateBeforeGuide;
    guideImgBtn.focus();
    window._guideOpen = false;
  }
  guideImgBtn.addEventListener('click', function(e){ e.preventDefault(); showGuide(); });
  guideClose.addEventListener('click', function(e){ e.preventDefault(); hideGuide(); });
  guideModal.addEventListener('click', function(e){ if(e.target === guideModal) hideGuide(); });
  document.addEventListener('keydown', function(e){
    if(e.key === 'Escape' && guideModal.style.display === 'flex') hideGuide();
  });
  const guideImg = document.getElementById('guideImg');
  if(guideImg) guideImg.addEventListener('dragstart', function(ev){ ev.preventDefault(); });
})();

// --- Bestiario: apertura/chiusura e gestione stato di gioco ---
(function(){
  const btn = document.getElementById('enemyGuideImgBtn');
  const modal = document.getElementById('enemyGuideModal');
  const close = document.getElementById('enemyGuideClose');
  if(!btn || !modal || !close) return;

  let gameStateBefore = undefined;

  function show(){
    // aggiorna sbloccati e costruisci UI
    try{ enemySeen = loadEnemySeen(); }catch(e){}
    buildEnemyGuideUI();

    modal.style.display='flex';
    modal.setAttribute('aria-hidden','false');
    if(typeof gameState !== 'undefined') gameStateBefore = gameState;
    gameState='menu';
    close.focus();
    window._enemyGuideOpen = true;
  }
  function hide(){
    modal.style.display='none';
    modal.setAttribute('aria-hidden','true');
    if(typeof gameStateBefore !== 'undefined') gameState = gameStateBefore;
    btn.focus();
    window._enemyGuideOpen = false;
  }

  btn.addEventListener('click', function(e){ e.preventDefault(); show(); });
  close.addEventListener('click', function(e){ e.preventDefault(); hide(); });
  modal.addEventListener('click', function(e){ if(e.target === modal) hide(); });
  document.addEventListener('keydown', function(e){
    if(e.key === 'Escape' && modal.style.display === 'flex') hide();
  });

  const img = document.getElementById('enemyGuideImg');
  if(img) img.addEventListener('dragstart', function(ev){ ev.preventDefault(); });
})();


// ===== FURIA WAVES (visual + damage) =====
let furiaWaves=[];
// A wave is: {x,y,start,delay,duration,maxR,damage,doneDamage}
function spawnFuriaWaves(x,y){
  const waves=[
    {delay:0,   maxR:190, duration:620, damage:20},
    {delay:420, maxR:300, duration:760, damage:20},
    {delay:880, maxR:430, duration:920, damage:20},
  ];
  const now=Date.now();
  for(const w of waves){
    furiaWaves.push({
      x,y,
      start: now + w.delay,
      delay:w.delay,
      duration:w.duration,
      maxR:w.maxR,
      damage:w.damage,
      doneDamage:false
    });
  }
  // extra punch
  shakeAmount = Math.max(shakeAmount, 10);
  for(let i=0;i<3;i++) createParticles(x+(Math.random()-0.5)*30,y+(Math.random()-0.5)*30,'#ff00ff',22,5);
}

function updateFuriaWaves(){
  const now=Date.now();
  furiaWaves = furiaWaves.filter(w=>{
    // not started yet
    if(now < w.start) return true;

    const t = (now - w.start);
    const prog = Math.max(0, Math.min(1, t / w.duration));
    const r = w.maxR * prog;

    // Apply damage once, early in the wave (so it feels immediate)
    if(!w.doneDamage && prog >= 0.15){
      w.doneDamage=true;

      // strong particles ring
      for(let i=0;i<26;i++){
        const a = (Math.PI*2)*(i/26);
        createParticles(w.x + Math.cos(a)*Math.min(r+18, w.maxR), w.y + Math.sin(a)*Math.min(r+18, w.maxR), '#ff00ff', 2, 4);
      }

      for(let i=enemies.length-1;i>=0;i--){
        const e=enemies[i];
        const d=Math.hypot((e.x+e.width/2)-w.x,(e.y+e.height/2)-w.y);
        if(d<=w.maxR){
          const _final=applyEnemyDamage(e, w.damage);
          showDamageNumber(e.x,e.y,_final);
          createParticles(e.x,e.y,'#ff4dff',14,5);
          if(e.hp<=0){
            createParticles(e.x,e.y,'#fff176',30,6);
            dropStellarBonusAtIndexIfNeeded(i);
            enemies.splice(i,1);
            applyScore(100*currentLevel);
          addKill(); }
        }
      }
    }

    // keep until finished
    return t <= w.duration;
  });
}

function drawFuriaWaves(){
  const now=Date.now();
  for(const w of furiaWaves){
    if(now < w.start) continue;
    const t = (now - w.start);
    const prog = Math.max(0, Math.min(1, t / w.duration));
    const r = w.maxR * prog;

    // fade out near end
    const fade = (prog < 0.75) ? 1 : Math.max(0, 1 - ((prog-0.75)/0.25));
    const alpha = 0.55 * fade;

    // Outer ring
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.lineWidth = 10;
    ctx.strokeStyle = 'rgba(255,0,255,0.95)';
    ctx.beginPath();
    ctx.arc(w.x, w.y, r, 0, Math.PI*2);
    ctx.stroke();

    // Glow ring
    ctx.globalAlpha = alpha*0.35;
    ctx.lineWidth = 22;
    ctx.beginPath();
    ctx.arc(w.x, w.y, r, 0, Math.PI*2);
    ctx.stroke();

    // Core ripple
    ctx.globalAlpha = alpha*0.25;
    ctx.lineWidth = 6;
    ctx.strokeStyle = 'rgba(255,180,255,0.9)';
    ctx.beginPath();
    ctx.arc(w.x, w.y, Math.max(0, r*0.65), 0, Math.PI*2);
    ctx.stroke();
    ctx.restore();
  }
}


// --- MARCUS UNLOCK: at least one character record >= 70000 ---
function updateMarcusUnlock(){
  const badge=document.getElementById('marcusLockBadge');
  const card=document.getElementById('card-marcus');
  if(!badge||!card) return;

  let maxRecord=0;
  document.querySelectorAll('.record-badge').forEach(r=>{
    const v=parseInt(r.textContent.replace(/[^0-9]/g,''))||0;
    if(v>maxRecord) maxRecord=v;
  });

  if(maxRecord>=70000){
    card.classList.remove('disabled');
    if(badge) badge.style.display='none';
  }
}
setInterval(updateMarcusUnlock,500);
setInterval(updateLucienUnlockUI,500);


// --- Ensure MARCUS selection behaves like others ---
document.querySelectorAll('.char-grid button[data-target]').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    const target = btn.dataset.target;
    const card = document.getElementById('card-'+target);
    if(!card || card.classList.contains('disabled')) return;

    document.querySelectorAll('.character-card').forEach(c=>c.classList.remove('selected'));
    card.classList.add('selected');
    selectedCharacter = target;
  });
});

</script>
</div>
<script>
/* ================================
   KEYBOARD INPUT (WASD + ARROWS)
   ================================ */
function normalizeKey(key) {
  switch (key) {
    case 'ArrowUp': return 'w';
    case 'ArrowDown': return 's';
    case 'ArrowLeft': return 'a';
    case 'ArrowRight': return 'd';
    default: return key.toLowerCase();
  }
}

window.addEventListener('keydown', e => {
  const k = normalizeKey(e.key);
  keys[k] = true;
});

window.addEventListener('keyup', e => {
  const k = normalizeKey(e.key);
  keys[k] = false;
});

// --- MARCUS UNLOCK: at least one character record >= 70000 ---
function updateMarcusUnlock(){
  const badge=document.getElementById('marcusLockBadge');
  const card=document.getElementById('card-marcus');
  if(!badge||!card) return;

  let maxRecord=0;
  document.querySelectorAll('.record-badge').forEach(r=>{
    const v=parseInt(r.textContent.replace(/[^0-9]/g,''))||0;
    if(v>maxRecord) maxRecord=v;
  });

  if(maxRecord>=70000){
    card.classList.remove('disabled');
    if(badge) badge.style.display='none';
  }
}
setInterval(updateMarcusUnlock,500);


// --- Ensure MARCUS selection behaves like others ---
document.querySelectorAll('.char-grid button[data-target]').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    const target = btn.dataset.target;
    const card = document.getElementById('card-'+target);
    if(!card || card.classList.contains('disabled')) return;

    document.querySelectorAll('.character-card').forEach(c=>c.classList.remove('selected'));
    card.classList.add('selected');
    selectedCharacter = target;
  });
});

</script>


<script>
(function(){
  try{ window.selectedCharacter = window.selectedCharacter || null; }catch(e){ window.selectedCharacter = null; }
  function clearSelected(){ document.querySelectorAll('.character-card').forEach(c=>c.classList.remove('selected')); }
  document.querySelectorAll('.character-card').forEach(card=>{
    card.addEventListener('click', function(e){
      if(card.classList.contains('disabled')) return;
      clearSelected();
      card.classList.add('selected');
      var ch = card.dataset && card.dataset.char ? card.dataset.char : null;
      if(ch) window.selectedCharacter = ch;
      var legacy = document.getElementById('card-' + ch);
      if(legacy && legacy !== card){ legacy.classList.add('selected'); }
    });
  });
  document.addEventListener('DOMContentLoaded', function(){
    if(window.selectedCharacter){
      var el = document.querySelector('.character-card[data-char="' + window.selectedCharacter + '"]');
      if(el) el.classList.add('selected');
    }
  });
})();

// --- MARCUS UNLOCK: at least one character record >= 70000 ---
function updateMarcusUnlock(){
  const badge=document.getElementById('marcusLockBadge');
  const card=document.getElementById('card-marcus');
  if(!badge||!card) return;

  let maxRecord=0;
  document.querySelectorAll('.record-badge').forEach(r=>{
    const v=parseInt(r.textContent.replace(/[^0-9]/g,''))||0;
    if(v>maxRecord) maxRecord=v;
  });

  if(maxRecord>=70000){
    card.classList.remove('disabled');
    if(badge) badge.style.display='none';
  }
}
setInterval(updateMarcusUnlock,500);


// --- Ensure MARCUS selection behaves like others ---
document.querySelectorAll('.char-grid button[data-target]').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    const target = btn.dataset.target;
    const card = document.getElementById('card-'+target);
    if(!card || card.classList.contains('disabled')) return;

    document.querySelectorAll('.character-card').forEach(c=>c.classList.remove('selected'));
    card.classList.add('selected');
    selectedCharacter = target;
  });
});

</script>


<script>
document.querySelectorAll('.char-grid button[data-target]').forEach(b=>{
  b.addEventListener('click',()=>{
    const card=document.querySelector('#card-'+b.dataset.target);
    if(card && !card.classList.contains('disabled')){
      card.click();
    }
  });
});

// --- MARCUS UNLOCK: at least one character record >= 70000 ---
function updateMarcusUnlock(){
  const badge=document.getElementById('marcusLockBadge');
  const card=document.getElementById('card-marcus');
  if(!badge||!card) return;

  let maxRecord=0;
  document.querySelectorAll('.record-badge').forEach(r=>{
    const v=parseInt(r.textContent.replace(/[^0-9]/g,''))||0;
    if(v>maxRecord) maxRecord=v;
  });

  if(maxRecord>=70000){
    card.classList.remove('disabled');
    if(badge) badge.style.display='none';
  }
}
setInterval(updateMarcusUnlock,500);


// --- Ensure MARCUS selection behaves like others ---
document.querySelectorAll('.char-grid button[data-target]').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    const target = btn.dataset.target;
    const card = document.getElementById('card-'+target);
    if(!card || card.classList.contains('disabled')) return;

    document.querySelectorAll('.character-card').forEach(c=>c.classList.remove('selected'));
    card.classList.add('selected');
    selectedCharacter = target;
  });
});

</script>


<div id="lockMessage" style="
  position:fixed;
  left:50%;top:50%;
  transform:translate(-50%,-50%);
  background:rgba(0,0,0,0.9);
  border:3px solid #f39c12;
  padding:18px 22px;
  font-family:'Press Start 2P', cursive;
  font-size:12px;
  color:#fff;
  z-index:999;
  display:none;
  text-align:center;
  box-shadow:0 0 25px rgba(0,0,0,0.8);
">
  <div id="lockText"></div>
  <div style="margin-top:12px;">
    <button id="lockCloseBtn" style="
      background:#e74c3c;
      border:none;
      padding:8px 14px;
      font-family:'Press Start 2P', cursive;
      cursor:pointer;
      color:#fff;
      font-size:11px;
    ">OK</button>
  </div>
</div>


<!-- Auto-open / scroll fixes for extra characters (added by assistant) -->
<script>
(function(){
  const extraCharsBtn=document.getElementById('extraCharsBtn');
  const extraCharacterSelect=document.getElementById('extraCharacterSelect');
  // Helper to ensure an element is visible (display:block) and scrolled into view
  function openAndScrollTo(el){
    if(!el) return;
    if(window.getComputedStyle(el).display === 'none') el.style.display = 'block';
    setTimeout(()=>{ try{ el.scrollIntoView({behavior:'smooth', block:'nearest', inline:'center'}); }catch(e){} },60);
  }

  if(extraCharsBtn && extraCharacterSelect){
    extraCharsBtn.addEventListener('click', ()=>{
      const isOpen = extraCharacterSelect.style.display === 'block';
      extraCharacterSelect.style.display = isOpen ? 'none' : 'block';
      if(!isOpen){
        setTimeout(()=>{ try{ extraCharacterSelect.scrollIntoView({behavior:'smooth', block:'nearest', inline:'center'}); 
          const first = extraCharacterSelect.querySelector('.character-card');
          if(first) first.focus && first.focus(); }catch(e){} },80);
      }
    });

    // When clicking compact selector buttons, if the target card lives inside the extraCharacterSelect,
    // open that panel and scroll to it so selection is visible (handles Marcus/H√®cate cases).
    document.querySelectorAll('.char-grid button[data-target]').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        try{
          const target = btn.dataset.target;
          const card = document.getElementById('card-'+target);
          if(card && extraCharacterSelect && extraCharacterSelect.contains(card)){
            // open and scroll to target card
            extraCharacterSelect.style.display = 'block';
            setTimeout(()=>{ try{ card.scrollIntoView({behavior:'smooth', block:'nearest', inline:'center'}); }catch(e){} },80);
          }
        }catch(e){}
      });
    });
  }
})();
</script>


<!-- ===== SAFE MARCUS PATCH (non-invasiva) ===== -->
<script>
(function(){

// ------------------ GLOBAL ------------------
window.marcusSuper = null;

// ------------------ CHARACTER STATS ADD ------------------
if(typeof characterStats!=='undefined' && !characterStats.marcus){
  characterStats.marcus = {
    hp:340,
    speed:5.4,
    damage:20,
    range:720,
    cooldown:650,
    name:'Marcus',
    attackType:'marcusStream',
    superCooldown: 25000,
    superDuration:10000
  };
}

// ------------------ PROJECTILE PATCH ------------------
const _updateProjectiles = updateProjectiles;
updateProjectiles = function(){
  _updateProjectiles();
  const now = Date.now();
  if(!window.projectiles) return;

  for(const p of projectiles){
    if(p.meta && p.meta.marcus){
      const t = (now - p.created) / 1000;
      const freq = (p.meta && p.meta.freq) ? p.meta.freq : 1.0;
      const amp = (p.meta && p.meta.amp) ? p.meta.amp : 14;
      const phase = (p.meta && p.meta.phase) ? p.meta.phase : 0;
      const off = Math.sin(t * freq + phase) * amp;
      const len = Math.hypot(p.vx, p.vy) || 1;
      const perpX = -p.vy / len;
      const perpY = p.vx / len;
      p.x += perpX * off * 0.6;
      p.y += perpY * off * 0.6;
      p.x += p.vx * 0.06;
      p.y += p.vy * 0.06;
    }
  }
};

// (Removed old heal-on-hit logic)



// ------------------ PLAYER ATTACK PATCH ------------------
const _playerAttack = Player.prototype.attack;
Player.prototype.attack = function(){

  if(this.type==='pdor'){
    const now = Date.now();
    if(!this._pdorLastShot) this._pdorLastShot = 0;
    const cd = 420; // slower cadence between darts
    if(now - this._pdorLastShot < cd) return false;
    this._pdorLastShot = now;

    const cx = this.x + this.width/2;
    const cy = this.y + this.height/2;

    // auto-aim to closest enemy
    let target=null, best=999999;
    for(const e of enemies){
      const d=Math.hypot((e.x+e.width/2)-cx,(e.y+e.height/2)-cy);
      if(d<best){best=d;target=e;}
    }

    let ang = target
      ? Math.atan2((target.y+target.height/2)-cy,(target.x+target.width/2)-cx)
      : (this.facingRight?0:Math.PI);

    const speed = 9;
    const vx = Math.cos(ang)*speed;
    const vy = Math.sin(ang)*speed;

    const baseDmg = Math.round((this.damage||50) * (this.attackBuffMultiplier||1));

    spawnProjectile({
      x:cx,
      y:cy,
      vx,vy,speed,
      damage:baseDmg,
      ttl:1600,
      color:'#ffffff',
      radius:10,
      friendly:true,
      shape:'rect',
      w:35,
      h:10,
      angle:ang,
      meta:{ pdorChain:true, hitsLeft:5, hitRefs:[] }
    });
    createParticles(cx,cy,'#ffffff',10,4);
    return true;
  }


  if(this.type==='marcus'){

    const now = Date.now();
    if(!this._marcusLastShot) this._marcusLastShot = 0;

    const cd = 250; // cooldown (faster attacks)
    if(now - this._marcusLastShot < cd) return false;
    this._marcusLastShot = now;
    // ---- HEAL ON ATTACK (1% current HP, integer, min 1) ----
    const healAmount = Math.max(1, Math.floor(this.hp * 0.01));
    this.hp = Math.min(this.maxHP, this.hp + healAmount);


    const cx = this.x + this.width/2;
    const cy = this.y + this.height/2;

    // auto-aim
    let target=null, best=999999;
    for(const e of enemies){
      const d=Math.hypot(e.x-cx,e.y-cy);
      if(d<best){best=d;target=e;}
    }

    let baseAngle = target
      ? Math.atan2((target.y+target.height/2)-cy,(target.x+target.width/2)-cx)
      : (this.facingRight?0:Math.PI);

    // TRUE STREAMS ‚Üí ONE long projectile each
    const spread=[-0.25,0,0.25];
    const speed = 6;

    for(const s of spread){

      const ang=baseAngle+s;

      spawnProjectile({
        x:cx,
        y:cy,
        vx:Math.cos(ang)*speed,
        vy:Math.sin(ang)*speed,
        damage:Math.round(20*this.attackBuffMultiplier*(this.baneSuperAttackMult||1)),
        ttl:900,            // long life = looks like beam/flow
        color:'#b19cff',
        radius:10,          // thicker = stream feeling
        friendly:true,
        meta:{marcus:true, phase:Math.random()*Math.PI*2}, wave:true, amp:16, freq:1.0
      });
    }

    return true;
  }
    
  if(this.type==='hendel'){
    const now=Date.now();
    if(now - this.lastAttack < this.cooldown || this.isDoingSuper) return false;
    this.lastAttack = now;
    this.attacking=true; this.attackTime=now;

    // auto-aim verso il nemico pi√π vicino (se presente)
    if(enemies && enemies.length){
      const pcx=this.x+this.width/2, pcy=this.y+this.height/2;
      let best=null, bestD=Infinity;
      for(const e of enemies){
        const ecx=e.x+e.width/2, ecy=e.y+e.height/2;
        const d=(ecx-pcx)*(ecx-pcx) + (ecy-pcy)*(ecy-pcy);
        if(d<bestD){bestD=d; best=e;}
      }
      if(best){
        const ecx=best.x+best.width/2, ecy=best.y+best.height/2;
        let dx=ecx-pcx, dy=ecy-pcy;
        const len=Math.hypot(dx,dy)||1;
        dx/=len; dy/=len;
        this.aimX=dx; this.aimY=dy;
        this.facingRight = dx>=0;
      }
    }

    // NEW BASE ATTACK (J): hammer sweep clockwise 75¬∞ ‚Äî damage 100 on hit
    const baseAng = Math.atan2(this.aimY||0, this.aimX||1);
    const arc = 75 * Math.PI / 180;

    this._hammerSwing = {
      start: now,
      duration: 260,
      baseAng,
      arc,
      // geometry (in local space: +x = forward)
      handleStart: 22,
      handleLen: 118,
      handleW: 30,
      headOffset: 196,
      headSize: 120,
      hitSet: new WeakSet(),
      hitDone: false
    };

    const cx=this.x+this.width/2, cy=this.y+this.height/2;
    createParticles(cx,cy,'#bdbdbd',14,5);
    shakeScreen();
    return true;
  }
return _playerAttack.call(this);
};

// ------------------ SUPER PATCH ------------------


const _super = Player.prototype.superAttack;
Player.prototype.superAttack = function(){

  if(this.type==='pdor'){
    const now=Date.now();
    const sc = (this.superCooldown!=null)?this.superCooldown:16000;
    if(this.lastSuper && (now - this.lastSuper) < sc) return false;
    this.lastSuper = now;

    // Spawn 7 random luminous orbiting rings for 8 seconds.
    startPdorOrbs(this, now);
    shakeScreen();
    return true;
  }

  if(this.type==='marcus'){
    const now=Date.now();
    // enforce cooldown (25s) ‚Äî fallback to 25000 if this.superCooldown is not set
    const sc = (this.superCooldown!=null)?this.superCooldown:25000;
    if(this.lastSuper && (now - this.lastSuper) < sc) return false;
    this.lastSuper = now;
    marcusSuper={endsAt:now+6500};
    this.pickupShieldUntil=now+6500;
    this.invulnerable=true;
    return true;
  }
  return _super.call(this);
};

// ------------------ ENEMY CONFUSION ------------------
// Marcus Super should "stun/confuse" ALL enemies (including Shooter/Attacker/Boss classes that override update).
// The old patch only wrapped Enemy.prototype.update, so subclasses with their own update() were immune.
function _applyMarcusConfusion(enemy){
  if(!(marcusSuper && Date.now() < marcusSuper.endsAt)) return false;

  // Confusion: wander randomly, no attacks, no AI.
  const s = enemy.speed || 2;
  enemy.vx = (Math.random()-0.5) * s * 2.0;
  enemy.vy = (Math.random()-0.5) * s * 2.0;
  enemy.x += enemy.vx;
  enemy.y += enemy.vy;

  // clamp within arena
  if(enemy.x < 0) enemy.x = 0;
  if(enemy.x + enemy.width > canvas.width) enemy.x = canvas.width - enemy.width;
  if(enemy.y < 0) enemy.y = 0;
  if(enemy.y + enemy.height > canvas.height - 50) enemy.y = canvas.height - 50 - enemy.height;

  return true;
}

(function patchAllEnemyUpdatesForMarcusSuper(){
  const wrappers = [];
  function wrap(proto){
    if(!proto || typeof proto.update !== 'function') return;
    const original = proto.update;
    // avoid double-wrapping
    if(original && original.__marcusWrapped) return;
    const wrapped = function(playerRef){
      if(_applyMarcusConfusion(this)) return;
      return original.call(this, playerRef);
    };
    wrapped.__marcusWrapped = true;
    proto.update = wrapped;
  }

  // Base + all known subclasses in this file
  wrap(Enemy && Enemy.prototype);
  wrap(typeof ShooterEnemy!=='undefined' && ShooterEnemy.prototype);
  wrap(typeof ArcherEnemy!=='undefined' && ArcherEnemy.prototype);
  wrap(typeof GlacialEnemy!=='undefined' && GlacialEnemy.prototype);
  wrap(typeof AttackReturnEnemy!=='undefined' && AttackReturnEnemy.prototype);
  wrap(typeof BossEnemy!=='undefined' && BossEnemy.prototype);
  wrap(typeof Boss5Enemy!=='undefined' && Boss5Enemy.prototype);
})();

})();

/* ==== COMPACT CHARACTER SELECT LOGIC ==== */
document.addEventListener('DOMContentLoaded', ()=>{
  const btns = document.querySelectorAll('.charBtn, .characterBtn, .selectCharBtn, .char-button');
  btns.forEach(b=>{
    b.addEventListener('click', ()=>{
      btns.forEach(x=>x.classList.remove('selected'));
      b.classList.add('selected');
    });
  });
});

</script>

<!-- Injected JS: compact grid selection behaviour -->
<script id="injected-compact-select-script">
document.addEventListener('DOMContentLoaded', function(){
  const grid = document.querySelector('.char-grid');
  if(!grid) return;
  const gridButtons = Array.from(grid.querySelectorAll('button')).filter(b => !b.classList.contains('empty') && !b.disabled);
  // Initialize: if any button has attribute data-selected="true", mark it selected
  let initial = gridButtons.find(b => b.getAttribute('data-selected') === 'true');
  if(!initial){
    // Try to match window.selectedCharacter if available
    try{
      if(window.selectedCharacter){
        initial = gridButtons.find(b => b.getAttribute('data-target') === window.selectedCharacter);
      }
    }catch(e){}
  }
  if(initial) {
    gridButtons.forEach(b=>b.classList.remove('selected'));
    initial.classList.add('selected');
  }

  gridButtons.forEach(btn=>{
    btn.addEventListener('click', function(e){
      // toggle selection: selecting one at a time
      gridButtons.forEach(b=>b.classList.remove('selected'));
      btn.classList.add('selected');

      // update global variable if present
      try{ window.selectedCharacter = btn.getAttribute('data-target'); }catch(e){}

      // also sync with the larger character-card list (visual cue)
      const target = btn.getAttribute('data-target');
      if(target){
        document.querySelectorAll('.character-card').forEach(c=>c.classList.remove('selected'));
        const card = document.querySelector('.character-card[data-char="'+target+'"]');
        if(card) card.classList.add('selected');
      }
    });

    // keyboard accessibility: allow selection with Enter or Space
    btn.addEventListener('keydown', function(e){
      if(e.key === 'Enter' || e.key === ' '){
        e.preventDefault();
        btn.click();
      }
    });
  });
});
</script>


<!-- === LOCKED COMPACT BUTTON LOGIC PATCH (added) === -->
<script id="locked-compact-script">
document.addEventListener('DOMContentLoaded', function(){

  const gridButtons = document.querySelectorAll('.char-grid button[data-target]');

  function syncLockedState(){
    gridButtons.forEach(btn=>{
      const id = btn.dataset.target;
      const card = document.getElementById('card-'+id);
      if(!card) return;

      if(card.classList.contains('disabled')){
        btn.classList.add('locked');
        btn.classList.remove('selected');
        btn.disabled = false; // still clickable to show lock message
      }else{
        btn.classList.remove('locked');
      }
    });
  }

  // initial sync
  syncLockedState();

  // re-check every 500ms (covers unlocks like Marcus)
  setInterval(syncLockedState, 500);

  // block selection glow for locked
  gridButtons.forEach(btn=>{
    btn.addEventListener('click', function(e){
      if(btn.classList.contains('locked')){
        btn.classList.remove('selected');
        return; // do not allow orange selection
      }
    }, true);
  });
});
</script>


<!-- AUTO-START ON COMPACT SELECTION: selects character and starts battle when clicking the compact name+emoji button -->

<script id="compact-selection-only">
document.addEventListener('DOMContentLoaded', function(){
  try{
    const compactButtons = document.querySelectorAll('.char-grid button[data-target]');
    compactButtons.forEach(btn=>{
      btn.addEventListener('click', function(e){
        try{
          const id = btn.dataset.target;
          if(!id) return;
          const card = document.getElementById('card-' + id);
          // Only allow selection if card exists and is not disabled/locked
          if(card && !card.classList.contains('disabled')){
            // set selection in global
            window.selectedCharacter = id;
            // visual: remove previous selected markers
            document.querySelectorAll('.char-grid button').forEach(b=>b.classList.remove('selected'));
            btn.classList.add('selected');
            document.querySelectorAll('.character-card').forEach(c=>c.classList.remove('selected'));
            card.classList.add('selected');
            // update displays if existing functions are available
            if(typeof updateMenuRecordsDisplay === 'function') try{ updateMenuRecordsDisplay(); }catch(e){}
            if(typeof updateMenuStatsDisplay === 'function') try{ updateMenuStatsDisplay(id); }catch(e){}
            // do NOT start the game automatically; user must press INIZIA BATTAGLIA
          } else {
            // Optionally show a brief locked feedback if a function exists
            if(typeof showLockedFeedback === 'function') try{ showLockedFeedback(id); }catch(e){}
          }
        }catch(err){}
      });
    });
  }catch(e){}
});
</script>



<script id="compact-record-sync">
document.addEventListener('DOMContentLoaded', function(){
  function syncCompactRecords(){
    document.querySelectorAll('.record-badge').forEach(r=>{
      const id = r.id.replace('record-','');
      const btn = document.getElementById('btnrec-'+id);
      if(btn){
        const val = parseInt(r.textContent.replace(/[^0-9]/g,''))||0;
        btn.textContent = 'R: ' + val;
      }
    });
  }

  // initial + periodic sync
  syncCompactRecords();
  setInterval(syncCompactRecords, 500);

  // if existing update function exists, hook it
  if(typeof updateMenuRecordsDisplay === 'function'){
    const old = updateMenuRecordsDisplay;
    window.updateMenuRecordsDisplay = function(){
      old();
      syncCompactRecords();
    }
  }
});
</script>


<script id="total-score-sync">
document.addEventListener('DOMContentLoaded', function(){

  const totalEl = document.getElementById('totalScoreDisplay');

  
  function updateVisibility(){
    if(typeof gameState !== 'undefined' && gameState === 'playing'){
      totalEl.style.display = 'none';
    }else{
      totalEl.style.display = 'block';
    }
  }

  function updateTotalScore(){
    let total = 0;
    document.querySelectorAll('.record-badge').forEach(r=>{
      const v = parseInt(r.textContent.replace(/[^0-9]/g,'')) || 0;
      total += v;
    });
    if(totalEl) totalEl.textContent = 'PUNTEGGIO TOTALE: ' + total;
  }

  updateTotalScore();
  setInterval(()=>{updateTotalScore();updateVisibility();}, 300);

  if(typeof updateMenuRecordsDisplay === 'function'){
    const old = updateMenuRecordsDisplay;
    window.updateMenuRecordsDisplay = function(){
      old();
      updateTotalScore();
    }
  }
});
</script>


<!-- === Account Level Button + Modal === -->
<button id="accountLevelBtn" style="display:none;">
  LV <span id="accountLevelValue">1</span>
  <span class="sub"><span id="accountXpText">0/1000 XP</span></span>
</button>

<div id="accountModal">
  <div class="panel">
    <div class="row">
      <h3>üèÖ Livello Account: <span id="accLevelHeader">1</span></h3>
      <button class="closeBtn" id="closeAccountModal">Chiudi</button>
    </div>

    <div class="row" style="flex-direction:column;align-items:flex-start;">
      <div style="width:100%;display:flex;justify-content:space-between;gap:10px;align-items:center;">
        <div style="opacity:0.9;">Progresso al prossimo livello</div>
        <div style="opacity:0.85;font-weight:700;" id="accXpHeader">0/1000 XP</div>
      </div>
      <div class="barWrap"><div class="barFill" id="accXpBar"></div></div>
    </div>

    <h4 style="margin:14px 0 6px 0;">üìú Missioni</h4>
    <div id="missionsList"></div>

    <div style="opacity:0.7;font-size:12px;margin-top:10px;">
      Le missioni danno XP. Quando una missione √® completata, il tasto <strong>Riscatta</strong> diventa verde e cliccabile.
    </div>
  </div>
</div>

</body>

<script>
const unlockMessages = {
  voltryx: "Personaggio BLOCCATO\nSblocca facendo 45.000 punti\ncon Jimmy, Rooney e Jeff",
  kouvagia: "Personaggio BLOCCATO\nSblocca facendo 50.000 punti\ncon Voltryx",
  salsy: "Personaggio BLOCCATO\nSblocca facendo 60.000 punti\ncon tutti i personaggi precedenti",
  tempostorm: "Personaggio BLOCCATO\nSblocca facendo 65.000 punti\ncon tutti i personaggi precedenti",
  marz: "Personaggio BLOCCATO\nSblocca facendo 70.000 punti\ncon tutti i personaggi precedenti",
  hecate: "Personaggio BLOCCATO\nSblocca facendo 75.000 punti\ncon tutti i personaggi precedenti",
  lucien: "Personaggio BLOCCATO\nSblocca facendo un record con Marcus\nsuperiore a 25.000",
  pdor: "Personaggio BLOCCATO\nsi sblocca facendo 50.000\ncon marcus e lucien",
  bane: "Personaggio BLOCCATO\nSblocca facendo 50.000\ncon PDOR",
  hendel: "personaggio BLOCCATO  si sblocca facendo 50.000 con Bane",
  kaerith: "Personaggio BLOCCATO\nsi sblocca facendo 40.000 con Hendel"
};

const lockBox = document.getElementById('lockMessage');
const lockText = document.getElementById('lockText');
document.getElementById('lockCloseBtn').onclick = ()=>lockBox.style.display='none';

document.querySelectorAll('.char-grid button[data-target]').forEach(btn=>{
  btn.addEventListener('click',()=>{
    const id = btn.dataset.target;
    const card = document.getElementById('card-'+id);
    if(card && card.classList.contains('disabled')){
      lockText.innerText = unlockMessages[id] || "Personaggio BLOCCATO\nSblocca facendo un record di 70.000 con un personaggio";
      lockBox.style.display = 'block';
    }
  });
});

// --- MARCUS UNLOCK: at least one character record >= 70000 ---
function updateMarcusUnlock(){
  const badge=document.getElementById('marcusLockBadge');
  const card=document.getElementById('card-marcus');
  if(!badge||!card) return;

  let maxRecord=0;
  document.querySelectorAll('.record-badge').forEach(r=>{
    const v=parseInt(r.textContent.replace(/[^0-9]/g,''))||0;
    if(v>maxRecord) maxRecord=v;
  });

  if(maxRecord>=70000){
    card.classList.remove('disabled');
    if(badge) badge.style.display='none';
  }
}
setInterval(updateMarcusUnlock,500);


// --- Ensure MARCUS selection behaves like others ---
document.querySelectorAll('.char-grid button[data-target]').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    const target = btn.dataset.target;
    const card = document.getElementById('card-'+target);
    if(!card || card.classList.contains('disabled')) return;

    document.querySelectorAll('.character-card').forEach(c=>c.classList.remove('selected'));
    card.classList.add('selected');
    selectedCharacter = target;
  });
});

</script>

</html>
