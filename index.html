<!DOCTYPE html>

<html lang="it">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<title>Platform Fighter - Complete</title>
<!-- Link ai font da Google Fonts -->
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&amp;family=VT323&amp;display=swap" rel="stylesheet"/>
<style>
    *{margin:0;padding:0;box-sizing:border-box}
    html,body{height:100%}
    body{
      font-family:'VT323', monospace; /* Font di gioco */
      background:#000;
      color:#fff;
      display:flex;
      justify-content:center;
      align-items:center;
      height:100vh;
      overflow:hidden;
      position:relative;
    }

    #bgDefault,#bgDark{
      position:absolute;left:0;top:0;width:100%;height:100%;
      background-size:cover;background-position:center;
      transition:opacity 900ms ease;z-index:0;pointer-events:none
    }
    #bgDefault{opacity:1}
    #bgDark{opacity:0}

    #fadeOverlay{position:absolute;left:0;top:0;width:100%;height:100%;background:#000;opacity:0;transition:opacity 650ms ease;z-index:3;pointer-events:none}

    #gameContainer{
      position:relative;width:1200px;height:700px;
      max-width:calc(100vw - 40px);max-height:calc(100vh - 40px);
      z-index:2;display:flex;justify-content:center;align-items:center
    }

    #gameCanvas{
      background:transparent;border:4px solid #fff;
      box-shadow:0 0 30px rgba(255,255,255,0.5);
      image-rendering:pixelated;display:block
    }

    .ui-overlay{position:absolute;top:18px;left:18px;z-index:10;text-shadow:2px 2px 4px #000}

    .hp-bar{width:200px;height:30px;background:#333;border:3px solid #fff;margin-top:8px;position:relative}
    .hp-fill{height:100%;background:linear-gradient(90deg,#e74c3c,#c0392b);transition:width 0.25s}

    .score{position:absolute;top:18px;right:18px;color:#f39c12;font-size:22px;text-shadow:2px 2px 4px #000;z-index:10}
    .timer{position:absolute;top:18px;left:50%;transform:translateX(-50%);font-size:32px;color:#f39c12;text-shadow:2px 2px 4px #000;z-index:10}
    .level-indicator{position:absolute;top:60px;left:50%;transform:translateX(-50%);font-size:18px;z-index:10}
    .super-cooldown{position:absolute;top:100px;left:18px;font-size:14px;color:#f39c12;z-index:10}

    .evo-banner{
      position:absolute;left:50%;top:45%;
      transform:translate(-50%,-50%);
      z-index:50;
      padding:18px 24px;
      border:4px solid #fff;
      background:rgba(0,0,0,0.85);
      font-family:'Press Start 2P', cursive;
      text-align:center;
      pointer-events:none;
      box-shadow:0 0 28px rgba(255,255,255,0.35);
      opacity:0;
    }
    .evo-banner.show{
      display:block !important;
      animation:evoPop 520ms ease forwards;
    }
    @keyframes evoPop{
      0%{opacity:0;transform:translate(-50%,-50%) scale(0.85)}
      25%{opacity:1;transform:translate(-50%,-50%) scale(1.08)}
      100%{opacity:0;transform:translate(-50%,-50%) scale(1.00)}
    }


    .menu,.end-screen{
      position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);
      background:rgba(0,0,0,0.9);padding:30px;border:4px solid #fff;
      text-align:center;z-index:20;width:calc(100% - 80px);max-width:760px;
      font-family:'Press Start 2P', cursive; /* Font menu */
    }

    .menu h1,.end-screen h1{
      font-size:38;color:#e74c3c;text-shadow:3px 3px 6px #000;margin-bottom:12px
    }

    .character-select{
      display:flex;
      gap:16px;
      justify-content:center;
      margin:18px 0;
      flex-wrap:wrap;

      /* NEW: scrollable character list (extra slots) */
      max-height:360px;
      overflow-y:auto;
      overflow-x:hidden;
      padding:8px 6px;
    }
    .character-select::-webkit-scrollbar{width:10px}
    .character-select::-webkit-scrollbar-thumb{background:#555;border:2px solid #111;border-radius:10px}
    .character-select::-webkit-scrollbar-track{background:#111}

    /* Ridotte leggermente le card personaggio per evitare sovrapposizioni */
    .character-card{
      background:#222;border:3px solid #555;padding:12px;
      width:180px; /* ridotta da 200px a 180px */
      cursor:pointer;transition:all .2s;position:relative;
      display:flex;flex-direction:column;align-items:center;
    }
    .character-card:hover{transform:scale(1.03);border-color:#e74c3c}
    .character-card.selected{border-color:#f39c12;background:#333}
    .character-card.disabled{ filter:grayscale(1); opacity:0.55; cursor:not-allowed; }
.character-card.disabled:hover{ transform:none; border-color:#555; }

/* Coming soon (grey, not clickable) */
.character-card.coming-soon{
  background:#3a3a3a;
  border-color:#777;
}
.character-card.coming-soon .menu-stats{color:#cfcfcf}

    /* Immagine personaggio pi√π piccola per evitare sovrapposizioni */
    .character-card img{
      width:110px; /* dimensione immagine ridotta */
      height:auto;
      display:block;
      image-rendering:pixelated;
      margin-bottom:8px;
    }

    /* Riquadro attorno al "tasto" per selezionare il personaggio */
    .character-card .select-btn{
      display:inline-block;
      border:3px solid #fff; /* riquadro visibile */
      padding:8px 10px;
      margin-top:10px;
      background:transparent;
      color:#fff;
      font-family:'Press Start 2P', cursive;
      font-size:12px;
      text-decoration:none;
      cursor:pointer;
    }
    .character-card .select-btn:active{transform:translateY(1px)}

    /* Riquadro leggermente pi√π grande per il nome (evita sovrapposizione con record) */
    .character-card .name-box{
      min-height:34px; /* ingrandito per non sovrapporre il record */
      padding:6px 8px;
      width:100%;
      text-align:center;
      font-size:13px;
      color:#fff;
      background:rgba(0,0,0,0.15);
      border:2px solid rgba(255,255,255,0.06);
      margin-bottom:6px;
      box-sizing:border-box;
    }

    /* Posizionamento del record: sotto il nome del personaggio, non assoluto */
    .record-badge{
      position:static; /* rimosso absolute per evitare sovrapposizioni */
      margin-top:6px;
      font-size:11px;
      color:#ccc;
      background:transparent;
      z-index:2;
    }

    .lock-badge{
      position:absolute;top:8px;right:8px;
      font-size:12px;color:#f39c12;background:#000;padding:3px 6px;border:1px solid #f39c12
    }

    .btn{ background:#e74c3c;color:#fff;border:none;padding:10px 22px; font-size:16px;cursor:pointer;margin:8px; font-family:'Press Start 2P', cursive; /* Bottoni in stile menu */ }

    /* Extra character button + layout */
    .start-row{display:flex;gap:10px;align-items:center;justify-content:center;margin-top:10px;}
    .mini-btn{padding:8px 14px;font-size:22px;line-height:1;min-width:46px;max-width:60px;}
    .extra-characters{margin-top:14px;}


    .damage-number{position:absolute;font-size:20px;font-weight:bold;color:#e74c3c;text-shadow:2px 2px 4px #000;pointer-events:none;animation:floatUp 1s ease-out forwards;z-index:200}
    @keyframes floatUp{to{transform:translateY(-50px);opacity:0}}

    .pickup-label{position:absolute;font-size:14px;color:#fff;text-shadow:2px 2px 4px #000}
    .menu-stats{font-size:13px;color:#ddd;margin-top:8px}

    @media (max-width:900px){
      #gameContainer{width:900px;height:525px}
      .menu,.end-screen{width:calc(100% - 40px);max-width:680px}
    }
/* Pulsante immagine stile */
.img-btn{
  background:transparent;border:0;padding:6px;cursor:pointer;display:inline-flex;
  align-items:center;justify-content:center;transition:transform 160ms ease, box-shadow 160ms ease;
}
.img-btn img{
  width:72px;height:72px;display:block;image-rendering:pixelated;
  border:3px solid #fff;border-radius:8px;transition:transform 160ms ease, box-shadow 160ms ease;
}
.img-btn:hover img{transform:scale(1.08);box-shadow:0 6px 18px rgba(0,0,0,0.6);}

/* Modale guida */
.guide-modal{
  position:fixed;left:0;top:0;width:100%;height:100%;
  background:rgba(0,0,0,0.75);display:flex;justify-content:center;align-items:center;
  z-index:60;padding:20px;
}
.guide-modal-content{
  background:rgba(10,10,10,0.98);border:4px solid #fff;max-width:980px;width:100%;max-height:90vh;
  overflow:auto;padding:22px;font-family:'VT323', monospace;color:#fff;position:relative;
  box-shadow:0 0 30px rgba(0,0,0,0.8);
}
.guide-close{
  position:absolute;right:12px;top:12px;background:transparent;border:2px solid #fff;color:#fff;
  width:36px;height:36px;border-radius:4px;cursor:pointer;font-size:18px;
}
.guide-body h3{color:#f39c12;margin-top:12px}
.guide-body p, .guide-body ul{font-size:14px;line-height:1.45;color:#ddd}

/* === Bestiario (nemici + boss) === */
.enemy-guide-content{max-width:1020px;}
.enemy-guide-body{margin-top:10px}
.enemy-guide-wrap{
  display:flex;gap:16px;align-items:stretch;
  min-height:420px;
}
.enemy-guide-list{
  width:260px;flex:0 0 260px;
  border:2px solid rgba(255,255,255,0.18);
  background:rgba(255,255,255,0.03);
  padding:10px;overflow:auto;max-height:62vh;
}
.enemy-guide-list button{
  width:100%;
  background:rgba(0,0,0,0.35);
  border:2px solid rgba(255,255,255,0.18);
  color:#fff;
  padding:10px 10px;
  margin:0 0 10px 0;
  cursor:pointer;
  font-family:'Press Start 2P', cursive;
  font-size:11px;
  text-align:left;
  display:flex;gap:10px;align-items:center;
}
.enemy-guide-list button:hover{border-color:#f39c12;transform:translateY(-1px)}
.enemy-guide-list button.active{border-color:#e74c3c;background:rgba(231,76,60,0.12)}
.enemy-guide-list .enemy-mini{
  width:44px;height:44px;image-rendering:pixelated;
  border:2px solid rgba(255,255,255,0.7);
  border-radius:6px;flex:0 0 auto;background:#000;
}
.enemy-guide-detail{
  flex:1;
  border:2px solid rgba(255,255,255,0.18);
  background:rgba(255,255,255,0.03);
  padding:14px;
  display:flex;
  align-items:center;
  justify-content:center;
}
.enemy-guide-detail-inner{
  width:100%;
  display:flex;
  gap:16px;
  align-items:flex-start;
}
.enemy-guide-detail-inner img{
  width:240px;height:240px;object-fit:contain;
  image-rendering:pixelated;
  border:3px solid #fff;border-radius:10px;
  background:rgba(0,0,0,0.35);
  flex:0 0 auto;
}
.enemy-guide-detail-inner h3{
  margin:0 0 10px 0;
  color:#f39c12;
  font-family:'Press Start 2P', cursive;
  font-size:14px;
  line-height:1.35;
}
.enemy-guide-detail-inner p{
  margin:0;
  font-size:15px;
  color:#ddd;
  line-height:1.55;
  font-family:'VT323', monospace;
}
.enemy-guide-hint{
  margin:14px 0 0 0;
  font-size:13px;
  color:#cfcfcf;
  font-family:'VT323', monospace;
}
@media (max-width:900px){
  .enemy-guide-wrap{flex-direction:column}
  .enemy-guide-list{width:100%;flex:0 0 auto;max-height:30vh}
  .enemy-guide-detail-inner{flex-direction:column;align-items:center}
  .enemy-guide-detail-inner img{width:220px;height:220px}
}


.guide-body ul{margin-left:18px}
@media (max-width:900px){
  .guide-modal-content{max-width:calc(100% - 20px);padding:14px}
  .guide-body p{font-size:13px}
}
  </style>
</head>
<body>
<div id="bgDefault"></div>
<div id="bgDark"></div>
<div id="fadeOverlay"></div>
<div id="gameContainer">
<canvas height="700" id="gameCanvas" width="1200"></canvas>
<div class="ui-overlay" id="uiOverlay" style="display:none;">
<div>HP: <span id="hpText">100</span></div>
<div class="hp-bar"><div class="hp-fill" id="hpFill" style="width:100%"></div></div>
<div style="margin-top:6px;">Buff Attacco: <span id="atkBuffDisplay">0s</span></div>
</div>
<div class="score" id="scoreDisplay" style="display:none;">Score: 0</div>
<div class="timer" id="timerDisplay" style="display:none;">45</div>
<div class="level-indicator" id="levelDisplay" style="display:none;">Level 1</div>
<div class="super-cooldown" id="superCooldown" style="display:none;">Super: Ready</div>
<div class="evo-banner" id="evoBanner" style="display:none;">
<div id="evoBannerText">EVOLUTO!</div>
</div>
<div class="menu" id="startScreen">
  <h1>‚öîÔ∏è JEFF‚ÄôS CHRONICLES‚öîÔ∏è</h1>
  <h2>Scegli la modalit√†</h2>
  <p style="margin-top:10px;font-size:15px;color:#ddd;line-height:1.4;">
    <strong>Difficile</strong>: gioco originale.<br>
    <strong>Facile</strong>: cure tra i livelli (+25% ogni livello, <em>cura totale</em> ogni 5¬∞ livello) ma <em>punteggio dimezzato</em>.
  </p>
  <div class="start-row" style="margin-top:18px;flex-wrap:wrap;">
    <button class="btn" id="modeHardBtn" type="button">MODALIT√Ä DIFFICILE</button>
    <button class="btn" id="modeEasyBtn" type="button">MODALIT√Ä FACILE</button>
  </div>
</div>

<div class="menu" id="mainMenu" style="display:none;">
<h1>‚öîÔ∏è JEFF‚ÄôS CHRONICLES‚öîÔ∏è</h1>
<h2>Seleziona il tuo combattente</h2>
<div class="character-select">
<div class="character-card" data-char="jimmy" id="card-jimmy">
<h3>JIMMY</h3>
<p>"üî´"</p>
<div class="menu-stats">HP: <span id="menu-hp-jimmy">-</span> Danno: <span id="menu-dmg-jimmy">-</span></div>
<div class="record-badge" id="record-jimmy">Record: 0</div>
</div>
<div class="character-card" data-char="rooney" id="card-rooney">
<h3>ROONEY</h3>
<p>"üê±"</p>
<div class="menu-stats">HP: <span id="menu-hp-rooney">-</span> Danno: <span id="menu-dmg-rooney">-</span></div>
<div class="record-badge" id="record-rooney">Record: 0</div>
</div>
<div class="character-card" data-char="jeff" id="card-jeff">
<h3>JEFF</h3>
<p>"üó°Ô∏è"</p>
<div class="menu-stats">HP: <span id="menu-hp-jeff">-</span> Danno: <span id="menu-dmg-jeff">-</span></div>
<div class="record-badge" id="record-jeff">Record: 0</div>
</div>
<!-- Voltryx card (locked until all three records > 50000) -->
<div class="character-card disabled" data-char="voltryx" id="card-voltryx" title="Sblocca completando 45.000 punti con ogni personaggio">
<h3>VOLTRYX</h3>
<p>"ü¶ä"</p>
<div class="menu-stats">HP: <span id="menu-hp-voltryx">-</span> Danno: <span id="menu-dmg-voltryx">-</span></div>
<div class="record-badge" id="record-voltryx">Record: 0</div>
<div class="lock-badge" id="voltryxLockBadge">LOCKED</div>
</div>
<!-- Kouvagia card (locked until 51.000 score with Voltryx) -->
<div class="character-card disabled" data-char="kouvagia" id="card-kouvagia" title="Sblocca facendo 51.000 punti con Voltryx">
<h3>KOUVAGIA</h3>
<p>"ü¶â"</p>
<div class="menu-stats">HP: <span id="menu-hp-kouvagia">-</span> Danno: <span id="menu-dmg-kouvagia">-</span></div>
<div class="record-badge" id="record-kouvagia">Record: 0</div>
<div class="lock-badge" id="kouvagiaLockBadge">LOCKED</div>
</div>
<!-- Salsy card (locked until 60.000 score with Jimmy, Rooney, Jeff, Voltryx and Kouvagia) -->
<div class="character-card disabled" data-char="salsy" id="card-salsy" title="Sblocca facendo 60.000 punti con Jimmy, Rooney, Jeff, Voltryx e Kouvagia">
<h3>SALSY</h3>
<p>"‚öúÔ∏è"</p>
<div class="menu-stats">HP: <span id="menu-hp-salsy">-</span> Danno: <span id="menu-dmg-salsy">-</span></div>
<div class="record-badge" id="record-salsy">Record: 0</div>
<div class="lock-badge" id="salsyLockBadge">LOCKED</div>
</div>
<!-- Altri personaggi (aperti con +) -->
<div class="character-select extra-characters" id="extraCharacterSelect" style="display:none;">
<!-- Tempostorm card (moved here as FIRST extra character) -->
<div class="character-card disabled" data-char="tempostorm" id="card-tempostorm" style="margin-right:8px;" title="Sblocca facendo 70.000 punti con tutti i personaggi precedenti (Jimmy, Rooney, Jeff, Voltryx, Kouvagia e Salsy)">
<h3>TEMPOSTORM</h3>
<p>"üîã"</p>
<div class="menu-stats">HP: <span id="menu-hp-tempostorm">-</span> Danno: <span id="menu-dmg-tempostorm">-</span></div>
<div class="record-badge" id="record-tempostorm">Record: 0</div>
<div class="lock-badge" id="tempostormLockBadge">LOCKED</div>
</div>
<!-- Marz card (SECOND, to the right) -->
<div class="character-card disabled" data-char="marz" id="card-marz" title="Sblocca facendo 80.000 punti con tutti i personaggi precedenti (Jimmy, Rooney, Jeff, Voltryx, Kouvagia, Salsy e Tempostorm)">
<h3>MARZ</h3>
<p>"ü™Ñ"</p>
<div class="menu-stats">HP: <span id="menu-hp-marz">-</span> Danno: <span id="menu-dmg-marz">-</span></div>
<div class="record-badge" id="record-marz">Record: 0</div>
<div class="lock-badge" id="marzLockBadge">LOCKED</div>
</div>
<!-- H√®cate card (locked until 85.000 score with all previous characters) -->
<div class="character-card disabled" data-char="hecate" id="card-hecate" title="Sblocca facendo 85.000 punti con tutti i personaggi precedenti (Jimmy, Rooney, Jeff, Voltryx, Kouvagia, Salsy, Tempostorm e Marz)">
<h3>H√àCATE</h3>
<p>"üåò"</p>
<div class="menu-stats">HP: <span id="menu-hp-hecate">-</span> Danno: <span id="menu-dmg-hecate">-</span></div>
<div class="record-badge" id="record-hecate">Record: 0</div>
<div class="lock-badge" id="hecateLockBadge">LOCKED</div>
</div>
</div>
<div class="start-row">
<button class="btn mini-btn" id="extraCharsBtn" title="Altri personaggi" type="button">+</button>
<button class="btn" id="startBtn">INIZIA BATTAGLIA</button>
</div>
<!-- Pulsante immagine per aprire la guida -->
<button aria-label="Apri guida" class="img-btn" id="guideImgBtn" style="display:inline-block;" title="Apri guida" type="button">
<img alt="Guida" id="guideImg" src="https://i.postimg.cc/JztT9fJH/bea.png"/>
</button>
<!-- Pulsante immagine per aprire il bestiario (nemici + boss) -->
<button aria-label="Apri bestiario" class="img-btn" id="enemyGuideImgBtn" style="display:inline-block;" title="Bestiario (Nemici &amp; Boss)" type="button">
<img alt="Bestiario" id="enemyGuideImg" src="https://i.postimg.cc/NFVhJNLC/pixelcut-export-(2).png"/>
</button>
<p style="margin-top:12px;font-size:15px;color:#ddd">Controlli: WASD - Muovi | J - Attacco | K - Super Mossa | Spazio - Schivata</p>
</div>

</div>
<div class="end-screen" id="endScreen" style="display:none;">
<h1 id="endTitle">GAME OVER</h1>
<p id="endMessage">Score Finale: 0</p>
<p id="endSub">Hai raggiunto il Livello 1</p>
<p id="recordMessage">Record Personaggio: 0</p>
<button class="btn" id="restartBtn">RIPROVA</button>
<button class="btn" id="menuBtn">TORNA AL MENU</button>
</div>

<!-- Modale guida -->
<div aria-hidden="true" aria-labelledby="guideTitle" class="guide-modal" id="guideModal" role="dialog" style="display:none;">
<div class="guide-modal-content" role="document">
<button aria-label="Chiudi guida" class="guide-close" id="guideClose">‚úï</button>
<h2 id="guideTitle">Guida completa a Jeff‚Äôs Chronicles</h2>
<div class="guide-body">
<h3>1) PANORAMICA GENERALE</h3>
<p><strong>Jeff‚Äôs Chronicles</strong> √® un arena-fighter a schermo fisso. Il giocatore sceglie un combattente e affronta ondate di nemici e boss all‚Äôinterno di un‚Äôarena chiusa, cercando di ottenere il punteggio pi√π alto possibile prima della fine del tempo.</p>
<p>Il gioco combina: azione rapida, gestione dei cooldown, uso intelligente di dash, super e pickup, progressione tramite record personali. Ogni partita √® diversa grazie alla variet√† di nemici, livelli e potenziamenti.</p>
<h3>2) OBIETTIVO, LIVELLI E PUNTEGGIO</h3>
<p><strong>Obiettivo del livello</strong>: eliminare tutti i nemici presenti nell‚Äôarena e sopravvivere fino allo scadere del tempo.</p>
<p><strong>Livelli</strong>: cambiano per tipo di nemici, numero di avversari, tempo disponibile e presenza di boss. La difficolt√† aumenta progressivamente.</p>
<p><strong>Punteggio</strong>: ogni nemico ucciso fornisce <strong>+100 √ó livello corrente</strong>. Subire danno comporta <strong>‚àí50 punti</strong> (il punteggio non scende mai sotto zero). I livelli avanzati permettono di ottenere score molto pi√π elevati.</p>
<h3>3) CONTROLLI</h3>
<ul>
<li><strong>W A S D</strong> ‚Üí Movimento</li>
<li><strong>J</strong> ‚Üí Attacco base</li>
<li><strong>K</strong> ‚Üí Super mossa</li>
<li><strong>Spazio</strong> ‚Üí Dash / Schivata</li>
</ul>
<h3>4) INTERFACCIA (HUD)</h3>
<p>Durante la partita sono sempre visibili: HP e barra della vita, timer del livello, livello corrente, cooldown della super, punteggio totale e indicatori di buff attivi. Tenere d‚Äôocchio il timer e la super √® fondamentale per sopravvivere nei livelli avanzati.</p>
<h3>5) MOVIMENTO E DASH</h3>
<p>Il movimento √® libero in 8 direzioni.</p>
<p><strong>Dash / Schivata</strong>: √® uno scatto rapido che rende pi√π difficile essere colpiti. Ha un cooldown breve. Serve per evitare attacchi corpo a corpo, schivare proiettili e laser e riposizionarsi rapidamente. Alcuni personaggi hanno dash pi√π lunghi o pi√π veloci rispetto ad altri.</p>
<h3>6) ATTACCO BASE</h3>
<p>Ogni personaggio ha: un tipo di attacco unico, un range specifico e un cooldown personale. Il gioco utilizza un aim-assist leggero: quando attacchi, il personaggio tende a orientarsi verso il nemico pi√π vicino per rendere i colpi pi√π fluidi.</p>
<h3>7) SUPER MOSSA</h3>
<p>Ogni personaggio possiede una super unica. Le super hanno cooldown lunghi. Possono colpire pi√π nemici, marchiare bersagli o creare zone di danno. Usarle nel momento giusto √® la chiave per superare i livelli pi√π difficili.</p>
<h3>8) DIFESA, SCUDI E STATUS</h3>
<p><strong>Scudi</strong>: alcuni personaggi possiedono scudi con durabilit√†. Esistono pickup che forniscono invulnerabilit√† temporanea.</p>
<p><strong>Status negativi</strong>: <strong>Poison</strong> (perdita di HP nel tempo). I danni da status possono uccidere se non gestiti.</p>
<h3>9) PICKUP E POTENZIAMENTI</h3>
<p>I pickup iniziano a comparire nei livelli avanzati.</p>
<ul>
<li><strong>Heal</strong>: cura il 25% degli HP massimi.</li>
<li><strong>Atk</strong>: aumenta il danno per alcuni secondi.</li>
<li><strong>Super</strong>: ricarica immediatamente la super.</li>
<li><strong>Speed</strong>: aumenta la velocit√† di movimento.</li>
<li><strong>Shield</strong>: invulnerabilit√† temporanea.</li>
<li><strong>Gold</strong>: cura totale + grande aumento del danno + super pronta.</li>
<li><strong>Malus</strong>: applica poison.</li>
<li><strong>Furia</strong>: emana 3 grandi onde ad area (sempre pi√π grandi) che infliggono <strong>20 danni</strong> ciascuna; inoltre cura <strong>+10 HP/s</strong> per <strong>10s</strong>.</li>
<li><strong>Ice</strong>: rallenta drasticamente <strong>tutti i nemici presenti</strong> (effetto permanente fino alla loro morte) e infligge <strong>2 danni/s</strong> per <strong>17s</strong>.</li>
</ul>
<p>Usare correttamente i pickup pu√≤ ribaltare completamente una partita.</p>
<h3>10) PERSONAGGI ‚Äì FUNZIONALIT√Ä E MECCANICHE</h3>
<h4>üî´ JIMMY </h4>
<p><strong>Ruolo</strong>: inseguimento e eliminazione rapida di bersagli.</p>
<p><strong>Attacco base (Grapple)</strong>: Jimmy aggancia automaticamente un nemico vicino. Finch√© √® agganciato, lo insegue in modo automatico. Quando lo raggiunge, infligge danni elevati. Se il bersaglio muore o scompare, il grapple termina.</p>
<p><strong>Scudo a durabilit√†</strong>: durante gli attacchi Jimmy attiva uno scudo. Ogni colpo assorbito consuma 1 punto di durabilit√†. Quando la durabilit√† √® zero, lo scudo si rompe e smette di funzionare temporaneamente.</p>
<p><strong>Super</strong>: seleziona pi√π bersagli. Jimmy li insegue uno dopo l‚Äôaltro colpendoli con danni potenziati. Durante la super √® molto pi√π difficile da fermare.</p>
<p><strong>Passiva ‚Äì Jetpack</strong>: ogni tot secondi si attiva automaticamente. Fornisce aumento di velocit√† e garantisce maggiore sicurezza nei movimenti.</p>
<p><strong>Stile consigliato</strong>: aggressivo e mobile.</p>
<h4>üê± ROONEY</h4>
<p><strong>Ruolo</strong>: resistenza e danni ravvicinati.</p>
<p><strong>Attacco base</strong>: serie di pugni potenti a corto raggio. Ottimo contro nemici lenti o raggruppati.</p>
<p><strong>Super</strong>: colpo ad area che frantuma il terreno in una <strong>zona quadrata</strong> centrata su Rooney. Il <strong>danno totale massimo √® 300</strong> (senza buff) e viene distribuito tra tutti i nemici presenti nell‚Äôarea: chi √® pi√π vicino al centro subisce pi√π danno, chi √® verso i bordi ne subisce meno. Perfetta per ripulire ondate e per fare burst se resti vicino al bersaglio principale.</p>
<p><strong>Stile consigliato</strong>: restare vicino ai nemici e controllare lo spazio.</p>
<h4>üó°Ô∏è JEFF </h4>
<p><strong>Ruolo</strong>: controllo dell‚Äôarena.</p>
<p><strong>Attacco base</strong>: fendente ad arco con la spada. Buona velocit√† e affidabilit√†.</p>
<p><strong>Super</strong>: crea una grande area intorno a Jeff. Infligge danni periodici a tutti i nemici all‚Äôinterno. Molto efficace contro boss e gruppi.</p>
<p><strong>Stile consigliato</strong>: posizionamento intelligente.</p>
<div id="guide-voltryx-locked" style="margin-top:10px;padding:10px;border:2px dashed rgba(255,255,255,0.35);background:rgba(255,255,255,0.05);">
<h4>ü¶ä VOLTRYX </h4>
<p><em>Questo personaggio si sblocca facendo oltre 45.000 punti con Jimmy, Rooney e Jeff.. La descrizione apparir√† automaticamente appena lo sblocchi.</em></p>
</div>
<div id="guide-voltryx" style="display:none;">
<h4>ü¶ä VOLTRYX </h4>
<p><strong>Ruolo</strong>: versatilit√† totale.</p>
<p><strong>Attacco base</strong>: da lontano spara un proiettile energetico ad area; da vicino esegue due pugni rapidi.</p>
<p><strong>Super</strong>: genera una sfera energetica che rilascia impulsi di danno ad area, colpendo ripetutamente i nemici nel raggio.</p>
<p><strong>Stile consigliato</strong>: alternare distanza e mischia.</p>
<p><strong>Sblocco</strong>: oltre 45.000 punti con Jimmy, Rooney e Jeff.</p>
</div>
<div id="guide-kouvagia-locked" style="margin-top:10px;padding:10px;border:2px dashed rgba(255,255,255,0.35);background:rgba(255,255,255,0.05);">
<h4>ü¶â KOUVAGIA </h4>
<p><em>Questo personaggio si sblocca facendo 50.000 punti con Voltryx. La descrizione apparir√† automaticamente appena lo sblocchi.</em></p>
</div>
<div id="guide-kouvagia" style="display:none;">
<h4>ü¶â KOUVAGIA </h4>
<p><strong>Ruolo</strong>: sopravvivenza e danni da contatto.</p>
<p><strong>Attacco base</strong>: dash offensivo che infligge danni ai nemici attraversati. Al termine del dash esplode infliggendo danni ad area.</p>
<p><strong>Passiva ‚Äì Dash offensivo</strong>: ogni schivata infligge danni ai nemici vicini.</p>
<p><strong>Passiva ‚Äì Cura su uccisione</strong>: ogni nemico ucciso a distanza ravvicinata cura Kouvagia.</p>
<p><strong>Super</strong>: cura completa e genera un‚Äôonda che respinge i nemici.</p>
<p><strong>Stile consigliato</strong>: usare spesso il dash e restare nel caos.</p>
<p><strong>Sblocco</strong>: 50.000 punti con Voltryx.</p>
</div>
<div id="guide-salsy-locked" style="margin-top:10px;padding:10px;border:2px dashed rgba(255,255,255,0.35);background:rgba(255,255,255,0.05);">
<h4>‚öúÔ∏è SALSY </h4>
<p><em>Questo personaggio si sblocca facendo 60.000 punti con tutti gli altri personaggi.. La descrizione apparir√† automaticamente appena lo sblocchi.</em></p>
</div>
<div id="guide-salsy" style="display:none;">
<h4>‚öúÔ∏è SALSY </h4>
<p><strong>Ruolo</strong>: burst damage e controllo dei bersagli.</p>
<p><strong>Attacco base</strong>: doppio fendente consecutivo. Pu√≤ colpire lo stesso nemico due volte con un singolo attacco.</p>
<p><strong>Super ‚Äì Marchio</strong>: marchia fino a 3 nemici. I nemici marchiati subiscono danni raddoppiati per alcuni secondi.</p>
<p><strong>Passiva ‚Äì Boost velocit√†</strong>: periodicamente ottiene un aumento temporaneo di velocit√†, perfetto per entrare e uscire dai combattimenti.</p>
<p><strong>Stile consigliato</strong>: colpisci, marchia e ritirati.</p>
<p><strong>Sblocco</strong>: 60.000 punti con tutti gli altri personaggi.</p>
</div>
<div id="guide-tempostorm-locked" style="margin-top:10px;padding:10px;border:2px dashed rgba(255,255,255,0.35);background:rgba(255,255,255,0.05);">
<h4>üîã TEMPOSTORM</h4>
<p><em>Questo personaggio si sblocca facendo <strong>70.000 punti</strong> con tutti i personaggi precedenti (Jimmy, Rooney, Jeff, Voltryx, Kouvagia e Salsy). La descrizione completa apparir√† automaticamente appena lo sblocchi.</em></p>
</div>
<div id="guide-tempostorm" style="display:none;">
<h4>üîã TEMPOSTORM</h4>
<p><strong>Ruolo</strong>: controllo di zona + sustain tramite Super.</p>
<p><strong>Statistiche</strong>: 300 HP, velocit√† leggermente superiore a Rooney.</p>
<p><strong>Attacco base</strong>: fasci di energia blu (laser). Infligge <strong>40</strong> danni al primo impatto e altri <strong>30</strong> se il nemico resta dentro il fascio dopo essere stato colpito.</p>
<p><strong>Super ‚Äì Tempesta Centrale</strong>: raggruppa tutti i nemici esattamente al centro dell‚Äôarena, dimezza la loro vita e converte la somma della vita sottratta in una <strong>cura personale</strong> tramite un effetto speciale blu.</p>
<p><strong>Sblocco</strong>: 70.000 punti con tutti i personaggi precedenti.</p>
</div>
<div id="guide-marz-locked" style="margin-top:10px;padding:10px;border:2px dashed rgba(255,255,255,0.35);background:rgba(255,255,255,0.05);">
<h4>ü™Ñ MARZ</h4>
<p><em>Questo personaggio si sblocca facendo <strong>80.000 punti</strong> con tutti i personaggi precedenti (Jimmy, Rooney, Jeff, Voltryx, Kouvagia, Salsy e Tempostorm). La descrizione completa apparir√† automaticamente appena lo sblocchi.</em></p>
</div>
<div id="guide-marz" style="display:none;">
<h4>ü™Ñ MARZ</h4>
<p><strong>Ruolo</strong>: mago da controllo e danno a bersagli multipli.</p>
<p><strong>Statistiche</strong>: 320 HP, velocit√† 7.2.</p>
<p><strong>Attacco base</strong>: spara <strong>tre fasci magici</strong> (corti) con danni diversi: <strong>40</strong>, <strong>50</strong>, <strong>60</strong>. Se ci sono almeno 3 nemici, colpisce fino a 3 bersagli differenti; se i nemici sono meno, i fasci si concentrano sugli stessi bersagli disponibili.</p>
<p><strong>Super ‚Äì Sigillo Arcano</strong>: crea esattamentte al centro della mappa un <strong>cerchi arcano </strong> che si espande molto lentamente causando molti danni ai nemici presenti all'interno inoltre Marz all'interno dell'area del sigillo ottiene <strong>un aumento del 50% della velocit√†</strong> finche la super resta attiva quindi per <strong>10 secondi</strong>.</p>
<p><strong>Sblocco</strong>: 80.000 punti con tutti i personaggi precedenti.</p>
</div>

<div id="guide-hecate-locked" style="margin-top:10px;padding:10px;border:2px dashed rgba(255,255,255,0.35);background:rgba(255,255,255,0.05);">
<h4>üåò H√àCATE</h4>
<p><em>Questo personaggio si sblocca facendo <strong>85.000 punti</strong> con tutti i personaggi precedenti (Jimmy, Rooney, Jeff, Voltryx, Kouvagia, Salsy, Tempostorm e Marz). La descrizione completa apparir√† automaticamente appena lo sblocchi.</em></p>
</div>
<div id="guide-hecate" style="display:none;">
<h4>üåò H√àCATE</h4>
<p><strong>Ruolo</strong>: tiratrice a lunga distanza + sustain tramite Super.</p>
<p><strong>Statistiche</strong>: 325 HP, dash identico a Voltryx.</p>
<p><strong>Attacco base</strong>: scocca una <strong>freccia a lunghissima distanza</strong> che infligge il danno maggiore al <strong>primo nemico colpito</strong>. Nel punto d‚Äôimpatto la freccia si <strong>divide istantaneamente</strong> (effetto visivo) in <strong>tre frecce</strong> che cercano e colpiscono <strong>altri nemici</strong> (non quello gi√† colpito).</p>
<p><strong>Super ‚Äì Richiamo Lunare</strong>: si cura di <strong>5 HP per ogni nemico presente</strong> nell‚Äôarena al momento dell‚Äôattivazione. Inoltre richiama tre lupi che attaccano i nemici con morsi letali il richiamo puo essere attivato piu volte ma in campo ci possono essere massimo 6 lupi</p>
<p><strong>Sblocco</strong>: 85.000 punti con tutti i personaggi precedenti.</p>
</div>
<h3>11) NEMICI E PERICOLI</h3>
<p>Nemici melee, veloci, resistenti e a distanza. Nemici con poison. Nemici con laser che richiedono schivata precisa. Boss con attacchi speciali e grandi quantit√† di HP.</p>
<h3>12) CONSIGLI FINALI</h3>
<ul>
<li>Usa il dash pi√π spesso di quanto pensi.</li>
<li>Le super vanno usate nei momenti critici.</li>
<li>Evitare danni √® importante anche per il punteggio.</li>
<li>Ogni personaggio √® forte se usato nel modo giusto.</li>
</ul>
<h3>‚ú¥Ô∏è EVOLUZIONI </h3>
<p>rappresentano una fase avanzata del combattimento e si attivano automaticamente durante la partita. Non sono potenziamenti temporanei, ma un vero e proprio cambiamento nello stile di gioco del personaggio.</p> <p><strong>Quando avvengono</strong>: dopo aver superato un boss avanzato (oltre met√† progressione), il personaggio entra nello stato <em>Evoluto</em>. L‚Äôevoluzione viene annunciata a schermo con un banner dedicato.</p> <p><strong>Filosofia delle evoluzioni</strong>: le evoluzioni <u>non aumentano direttamente HP, velocit√† o danno base</u>. Al contrario, sbloccano <strong>passive speciali</strong> che premiano l‚Äôuso intelligente delle meccaniche del personaggio. Questo mantiene il gioco bilanciato e strategico.</p> <h4>Effetti generali</h4> <ul> <li>L‚Äôevoluzione dura per il resto della partita.</li> <li>Ogni personaggio ottiene un <strong>vantaggio unico</strong>, coerente con il suo ruolo.</li> <li>Le evoluzioni premiano precisione, timing e gestione dei nemici.</li> </ul> <h4>‚öôÔ∏è Evoluzioni attuali</h4> <p><strong>üî´ Jimmy ‚Äì Predatore Evoluto</strong><br/> Jimmy carica la <strong>Super pi√π velocemente (+25%)</strong> e il <strong>cooldown dell‚Äôattacco base √® ridotto del 15%</strong>.</p>
<p><strong>üê± Rooney ‚Äì Impatto Brutale</strong><br/> Il <strong>primo colpo</strong> inflitto a ogni nemico infligge <strong>+50% danni</strong>.</p>
<p><strong>üó°Ô∏è Jeff ‚Äì Rigenerazione da Combattimento</strong><br/> Ogni nemico ucciso cura Jeff di <strong>5 HP</strong>.</p> <p><em>Nota:</em> i personaggi sbloccabili avanzati potrebbero ottenere evoluzioni dedicate in futuro.</p> <h4> Consigli strategici</h4> <ul> <li>Sfrutta l‚Äôevoluzione per cambiare approccio: da difensivo a aggressivo (o viceversa).</li> <li>Dopo l‚Äôevoluzione, eliminare i nemici velocemente diventa ancora pi√π importante per massimizzare punteggio e controllo.</li> <li>Le evoluzioni non rendono invincibili: il posizionamento resta fondamentale.</li> </ul> <p><strong>Le evoluzioni sono il momento in cui Jeff‚Äôs Chronicles premia davvero la padronanza del personaggio.</strong></p>
<h3>üèÅ CONCLUSIONE</h3>
<p><strong>Jeff‚Äôs Chronicles</strong> premia abilit√†, strategia e conoscenza dei personaggi. Impara i loro meccanismi, sfrutta i pickup e punta al record massimo.</p>
</div>
</div>
</div>
<!-- Modale bestiario (nemici e boss) -->
<div aria-hidden="true" aria-labelledby="enemyGuideTitle" class="guide-modal enemy-guide-modal" id="enemyGuideModal" role="dialog" style="display:none;">
<div class="guide-modal-content enemy-guide-content" role="document">
<button aria-label="Chiudi bestiario" class="guide-close" id="enemyGuideClose">‚úï</button>
<h2 id="enemyGuideTitle">Bestiario ‚Äì Nemici &amp; Boss</h2>
<div class="enemy-guide-body">
<div class="enemy-guide-wrap">
<div aria-label="Lista nemici sbloccati" class="enemy-guide-list" id="enemyGuideList"></div>
<div aria-live="polite" class="enemy-guide-detail" id="enemyGuideDetail">
<div class="enemy-guide-empty">
<h3 style="margin:0 0 8px 0;color:#f39c12;">Nessun nemico sbloccato</h3>
<p style="margin:0;color:#ddd;">Affronta un nemico o un boss almeno una volta per sbloccarlo qui.</p>
</div>
</div>
</div>
<p class="enemy-guide-hint">Nota: nel Bestiario compaiono solo i nemici/boss che hai gi√† sfidato almeno una volta (vale per tutti i personaggi).</p>
</div>
</div>
</div>
<script>
const HP_MULT=1.40;
const DAMAGE_MULT=0.85;
const SUPER_DAMAGE_MULT=0.8;
const JEFF_SUPER_RADIUS=Math.round(320*0.8);
const GOLD_PROB=0.10;
const JEFF_ATTACK_RANGE_MULT=0.8;
const JIMMY_SUPER_ADDITIONAL_MULT=0.85;
const JIMMY_BASE_ADDITIONAL_MULT=1.10;

const URL_DEFAULT='https://i.postimg.cc/8CBFTKs4/Progetto-senza-titolo.png';
const URL_DARK='https://i.postimg.cc/JhpWH3jJ/Copilot-20251209-232827.png';


const URL_FINAL='https://i.postimg.cc/pTHFKHgz/Progetto-senza-titolo-(2).png';
const URL_ICE='https://i.postimg.cc/K8pgVhTx/icebiome1.png';
const canvas=document.getElementById('gameCanvas');
const ctx=canvas.getContext('2d');

const bgDefault=document.getElementById('bgDefault');
const bgDark=document.getElementById('bgDark');
const fadeOverlay=document.getElementById('fadeOverlay');
let _bgTier=0; // 0=default,1=dark,2=final,3=ice

bgDefault.style.backgroundImage=`url('${URL_DEFAULT}')`;
bgDark.style.backgroundImage=`url('${URL_DARK}')`;
bgDefault.style.backgroundSize=bgDark.style.backgroundSize='cover';
bgDefault.style.backgroundPosition=bgDark.style.backgroundPosition='center';

let gameState='start';
let selectedCharacter=null;
let player=null;
let currentLevel=0;
let score=0;
let timer=45;
let enemies=[];
let particles=[];
let pickups=[];
let difficultyMode='hard'; // 'hard' | 'easy'
let scoreMultiplier=1;     // easy => 0.5

function setDifficulty(mode){
  difficultyMode = (mode==='easy') ? 'easy' : 'hard';
  scoreMultiplier = (difficultyMode==='easy') ? 0.5 : 1;
}

function applyScore(delta){
  // In easy mode all score changes are halved (including penalties), and score never goes below 0.
  const scaled = delta * scoreMultiplier;
  // keep integers (same feeling as before)
  const d = (scaled>=0) ? Math.floor(scaled) : Math.ceil(scaled);
  score = Math.max(0, score + d);
}


// --- Pickup hitbox tuning ---
// Bigger pickup hitbox (bonuses easier to collect), malus stays tighter.
const BONUS_HIT_RADIUS = 26; // was ~18
const MALUS_HIT_RADIUS = 18;

// Lower malus probability (weighted pick)
function pickRandomPickupType(){
  const weighted = [
    ['heal', 1],
    ['atk', 1],
    ['super', 1],
    ['speed', 1],
    ['shieldPickup', 1],
    ['furia', 1],
    ['ice', 1],
    ['malus', 0.25], // nerfed
  ];
  let sum = 0;
  for (const [,w] of weighted) sum += w;
  let r = Math.random() * sum;
  for (const [t,w] of weighted){
    r -= w;
    if (r <= 0) return t;
  }
  return 'heal';
}
let projectiles=[];

// --- MARZ SUPER: expanding magic zone ---
// Active only when Marz uses his Super.
let magicZone=null;
function updateMagicZone(now){
  if(!magicZone) return;
  if(now >= magicZone.endsAt){ magicZone = null; return; }

  // Expand slowly over the full duration
  const t = Math.max(0, Math.min(1, (now - magicZone.startsAt) / magicZone.durationMs));
  magicZone.radius = magicZone.startRadius + (magicZone.maxRadius - magicZone.startRadius) * t;

  // Periodic damage to enemies inside
  if(!magicZone.lastTick) magicZone.lastTick = now;
  if(now - magicZone.lastTick >= magicZone.tickMs){
    magicZone.lastTick = now;
    for(let i=enemies.length-1;i>=0;i--){
      const e=enemies[i];
      const ex=e.x+e.width/2, ey=e.y+e.height/2;
      const d=Math.hypot(ex-magicZone.x, ey-magicZone.y);
      if(d <= magicZone.radius){
        const dmg=Math.round(magicZone.damagePerTick);
        const _dmg=dmg; const _final=applyEnemyDamage(e,_dmg);
        showDamageNumber(e.x,e.y,_final);
        // colorful hit FX
        createParticles(ex,ey, magicZone.colors[(magicZone.colorIdx++)%magicZone.colors.length], 10, 4);
        if(e.hp<=0){
          createParticles(e.x,e.y,'#fff176',30,6);
          enemies.splice(i,1);
          applyScore(100*currentLevel);
        }
      }
    }

    // ambient zone particles (center swirl)
    createParticles(magicZone.x, magicZone.y, magicZone.colors[(magicZone.colorIdx++)%magicZone.colors.length], 18, 4);
  }
}

function drawMagicZone(now){
  if(!magicZone) return;
  const t = Math.max(0, Math.min(1, (now - magicZone.startsAt) / magicZone.durationMs));
  const pulse = 0.5 + 0.5*Math.sin(now/120);

  ctx.save();
  ctx.globalAlpha = 0.18 + 0.18*(1-t);
  const grad = ctx.createRadialGradient(magicZone.x, magicZone.y, 10, magicZone.x, magicZone.y, magicZone.radius);
  grad.addColorStop(0, 'rgba(255,0,255,0.55)');
  grad.addColorStop(0.5, 'rgba(0,229,255,0.35)');
  grad.addColorStop(1, 'rgba(255,241,118,0.08)');
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.arc(magicZone.x, magicZone.y, magicZone.radius, 0, Math.PI*2);
  ctx.fill();

  // rings
  ctx.globalAlpha = 0.55;
  ctx.lineWidth = 6 + 6*pulse;
  ctx.strokeStyle = 'rgba(255,0,255,0.55)';
  ctx.beginPath(); ctx.arc(magicZone.x, magicZone.y, magicZone.radius*(0.35+0.05*pulse), 0, Math.PI*2); ctx.stroke();
  ctx.strokeStyle = 'rgba(0,229,255,0.55)';
  ctx.beginPath(); ctx.arc(magicZone.x, magicZone.y, magicZone.radius*(0.65+0.06*(1-pulse)), 0, Math.PI*2); ctx.stroke();
  ctx.strokeStyle = 'rgba(255,241,118,0.55)';
  ctx.beginPath(); ctx.arc(magicZone.x, magicZone.y, magicZone.radius, 0, Math.PI*2); ctx.stroke();

  ctx.restore();
}

function isPointInsideMagicZone(x,y){
  if(!magicZone) return false;
  const now=Date.now();
  if(now >= magicZone.endsAt) return false;
  return Math.hypot(x-magicZone.x, y-magicZone.y) <= magicZone.radius;
}

let lasers=[];
let tempBeams=[]; // Tempostorm lasers (friendly beams)
let wolves=[]; // H√®cate Super: lupi amichevoli
let keys={};
let lastSecondTick=Date.now();
let levelAdvanceLock=false;
let shakeAmount=0;

const images={rooney:new Image(),jimmy:new Image(),jeff:new Image(),voltryx:new Image(),kouvagia:new Image(),salsy:new Image(),tempostorm:new Image() ,marz:new Image(),hecate:new Image()};
images.rooney.src='https://i.postimg.cc/Vs0G7ZPV/rooneyy.png';
images.jimmy.src='https://i.postimg.cc/13Qzjdn4/jimmyy.png';
images.jeff.src='https://i.postimg.cc/gkQN3v7R/jeff-(1).png';
images.voltryx.src='https://i.postimg.cc/GhjK4WCy/Voltryxx.png';
images.kouvagia.src='https://i.postimg.cc/gj1xjk0G/kouvagiaa-(1).png';
images.salsy.src='https://i.ibb.co/20zSkjsB/salsy.png';
images.tempostorm.src='https://i.postimg.cc/mkzj763m/tempostorm.png';
images.marz.src='https://i.postimg.cc/j5WJZL5X/marz.png';
images.hecate.src='https://i.postimg.cc/9QjRg424/hecate.png';
const wolfImg=new Image(); wolfImg.src='https://i.postimg.cc/4y9yBGFw/lupo.png';
const imagesEvo={jimmy:new Image(),rooney:new Image(),jeff:new Image()};
imagesEvo.jimmy.src='https://i.postimg.cc/g26ZX0n9/jimmyevo.png';
imagesEvo.rooney.src='https://i.postimg.cc/x8Ck0fWs/rooneyevo.png';
imagesEvo.jeff.src='https://i.postimg.cc/FsYf8KbV/jeffevo.png';
// --- Pickup images (keep pickup size small; same dimensions already used) ---
const pickupImgs={
  heal: new Image(),
  shield: new Image(),
  speed: new Image(),
  atk: new Image(),
  super: new Image(),
  gold: new Image(),
  malus: new Image(),
};
pickupImgs.heal.src='https://i.postimg.cc/c4jNccLC/heal.png';
pickupImgs.shield.src='https://i.postimg.cc/9XnS3QHh/shield.png';
pickupImgs.speed.src='https://i.postimg.cc/DzCV8QHb/speed.png';
pickupImgs.atk.src='https://i.postimg.cc/cHjVcxsS/ATK.png';
pickupImgs.super.src='https://i.postimg.cc/3rss4xSD/Super.png';
pickupImgs.gold.src='https://i.postimg.cc/wjVZGc6h/gold.png';
pickupImgs.malus.src='https://i.postimg.cc/tT1cJKFm/malus.png';
pickupImgs.furia = new Image(); pickupImgs.furia.src='https://i.postimg.cc/BvCsTjYD/furia.png';
pickupImgs.ice = new Image(); pickupImgs.ice.src='https://i.postimg.cc/GmF1RB1k/ice.png';

function getPickupImage(type){
  // internal type names
  const key = (type==='shieldPickup') ? 'shield' : type;
  return pickupImgs[key] || null;
}
 
const enemyImages={
  slime:new Image(),drone:new Image(),boss1:new Image(),mech:new Image(),
  shadow:new Image(),boss2:new Image(),shooter:new Image(),attacker:new Image(),boss3:new Image(),
  veleno:new Image(),oneyes:new Image(),boss4:new Image(),boss5:new Image(),archer:new Image(),glacial:new Image()
};
enemyImages.slime.src='https://i.postimg.cc/NFVhJNLC/pixelcut-export-(2).png';
enemyImages.drone.src='https://i.postimg.cc/13x9HtxZ/image-(1).png';
enemyImages.boss1.src='https://i.postimg.cc/B6bmxMJt/boss1-(1).png';
enemyImages.mech.src='https://i.postimg.cc/qqkys7cT/mech-(1).png';
enemyImages.shadow.src='https://i.postimg.cc/tgWx86Dv/shadow-(1).png';
enemyImages.boss2.src='https://i.postimg.cc/Bvpq8QnR/boss2-(1).png';
enemyImages.shooter.src='https://i.postimg.cc/yNxVZC3D/shooter-(1).png';
enemyImages.attacker.src='https://i.postimg.cc/sxVHMs1H/attacker.png';
enemyImages.boss3.src='https://i.postimg.cc/xjzKWcTs/boss3-(1).png';


enemyImages.veleno.src='https://i.postimg.cc/3xNWGRWY/veleno.png';
enemyImages.oneyes.src='https://i.postimg.cc/g2xkJTBG/oneyes.png';
enemyImages.boss4.src='https://i.postimg.cc/Px6d8kgr/boss4.png';
enemyImages.boss5.src='https://i.postimg.cc/wvGJm86S/boss5.png';
enemyImages.archer.src='https://i.postimg.cc/VLSg4gpV/archer.png';
enemyImages.glacial.src='https://i.postimg.cc/W1LG8vMN/glacial.png';

// ===== Bestiario (Nemici & Boss) - sblocco globale (tutti i personaggi) =====
const ENEMY_SEEN_KEY='jeffsChronicles_enemySeen_v1';
function loadEnemySeen(){
  try{
    const raw=localStorage.getItem(ENEMY_SEEN_KEY);
    return raw ? JSON.parse(raw) : {};
  }catch(e){ return {}; }
}
function saveEnemySeen(map){
  try{ localStorage.setItem(ENEMY_SEEN_KEY, JSON.stringify(map||{})); }catch(e){}
}
let enemySeen = loadEnemySeen();
function markEnemySeen(type){
  if(!type) return;
  if(!enemySeen[type]){
    enemySeen[type]=true;
    saveEnemySeen(enemySeen);
  }
}

// Dati descrittivi (nome + descrizione + chiave immagine)
const enemyGuideData={
  slime:{ name:'SLIME', imgKey:'slime', desc:'Creatura base gelatinosa. Lenta, prevedibile, pensata per mettere pressione numerica pi√π che tecnica. Insegue costantemente il giocatore e infligge danno da contatto.  HP: 45‚Äì50 ‚≠ê‚≠ê‚òÜ‚òÜ‚òÜ Danno: 9‚Äì10 ‚≠ê‚≠ê‚òÜ‚òÜ‚òÜ Velocit√†:   ‚≠ê‚≠ê‚òÜ‚òÜ‚òÜ'},
  drone:{ name:'DRONE', imgKey:'drone', desc:'Unit√† volante veloce e nervosa, progettata per punire chi resta fermo.  Movimento rapido e irregolare, attacco da contatto. HP: ~40 ‚≠ê‚≠ê‚òÜ‚òÜ‚òÜ Danno: 11‚Äì12 ‚≠ê‚≠ê‚≠ê‚òÜ‚òÜ Velocit√†: ‚≠ê‚≠ê‚≠ê‚≠ê‚òÜ'},
  mech:{ name:'MECH', imgKey:'mech', desc:'Nemico corazzato e resistente, fa da ‚Äútank‚Äù nelle ondate.  Avanza lentamente verso il giocatore e colpisce a contatto. HP: 60‚Äì65 ‚≠ê‚≠ê‚≠ê‚≠ê‚òÜ Danno:  16-17 ‚≠ê‚≠ê‚≠ê‚òÜ‚òÜ Velocit√†: ‚≠ê‚≠ê‚òÜ‚òÜ‚òÜ'},
  shadow:{ name:'SHADOW', imgKey:'shadow', desc:'Entit√† oscura estremamente aggressiva, specializzata nel combattimento ravvicinato. Insegue molto velocemente, attacco immediato a contatto. HP: 50‚Äì52 ‚≠ê‚≠ê‚≠ê‚òÜ‚òÜ Danno: 17‚Äì18 ‚≠ê‚≠ê‚≠ê‚≠ê‚òÜ Velocit√†: ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê'},
  shooter:{ name:'SHOOTER', imgKey:'shooter', desc:'Attaccante a distanza che costringe il giocatore a schivare costantemente. Spara proiettili dalla distanza mantenendo posizione.  HP: 45 ‚≠ê‚≠ê‚òÜ‚òÜ‚òÜ Danno: 20‚Äì21 ‚≠ê‚≠ê‚≠ê‚≠ê‚òÜ Velocit√†: ‚≠ê‚≠ê‚≠ê‚òÜ‚òÜ'},
  attacker:{ name:'ATTACKER', imgKey:'attacker', desc:'Assalitore aggressivo con pattern ‚Äúhit & run‚Äù. Carica, colpisce e si allontana rapidamente. HP: 90‚Äì99 ‚≠ê‚≠ê‚≠ê‚≠ê‚òÜ Danno: 17‚Äì19 ‚≠ê‚≠ê‚≠ê‚òÜ‚òÜ Velocit√†: ‚≠ê‚≠ê‚≠ê‚≠ê‚òÜ'},
  archer:{ name:'ARCHER', imgKey:'archer', desc:'Tiratore preciso che punisce il posizionamento sbagliato. Spara frecce a distanza, ricarica tra un colpo e l‚Äôaltro. HP: 78‚Äì86 ‚≠ê‚≠ê‚≠ê‚òÜ‚òÜ Danno: 14‚Äì15 ‚≠ê‚≠ê‚≠ê‚òÜ‚òÜ Velocit√†: ‚≠ê‚≠ê‚≠ê‚òÜ‚òÜ'},
  glacial:{ name:'GLACIAL', imgKey:'glacial', desc:'Nemico pesante del bioma ghiaccio, domina il controllo dell‚Äôarena. Movimento lento ma pressante, danno da contatto. HP: 150‚Äì165 ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Danno: 22‚Äì24 ‚≠ê‚≠ê‚≠ê‚≠ê‚òÜ Velocit√†: ‚≠ê‚≠ê‚òÜ‚òÜ‚òÜ'},
  veleno:{ name:'VELENO', imgKey:'veleno', desc:'Creatura tossica estremamente pericolosa se ignorata. Attacco a contatto che applica Poison. HP: 60‚Äì70 ‚≠ê‚≠ê‚≠ê‚òÜ‚òÜ Danno: 13‚Äì15 ‚≠ê‚≠ê‚≠ê‚òÜ‚òÜ Velocit√†: ‚≠ê‚≠ê‚≠ê‚òÜ‚òÜ Abilit√† passive: ‚ò†Ô∏è Poison ‚Äì danni nel tempo'},
  oneyes:{ name:'ONE-EYE', imgKey:'oneyes', desc:'Entit√† strategica che mantiene distanza e punisce inseguimenti sbagliati. Avanza a scatti, attacca quando il giocatore si espone con attacchi a laser precisi e letali con danni continui se si rimane dentro il raggio del laser. HP: 55‚Äì60 ‚≠ê‚≠ê‚≠ê‚òÜ‚òÜ Danno: 8‚Äì9 ‚≠ê‚≠ê‚òÜ‚òÜ‚òÜ Velocit√†: ‚≠ê‚≠ê‚òÜ‚òÜ‚òÜ'},
  boss1:{ name:'BOSS I', imgKey:'boss1', desc:'HP: 150 ‚≠ê‚≠ê‚≠ê‚òÜ‚òÜ Danno: 20 ‚≠ê‚≠ê‚≠ê‚òÜ‚òÜ Velocit√†: ‚≠ê‚≠ê‚òÜ‚òÜ‚òÜ Passiva: ‚ùå | Boss introduttivo, pressione costante.'},
  boss2:{ name:'BOSS II', imgKey:'boss2', desc:'HP: 300 ‚≠ê‚≠ê‚≠ê‚≠ê‚òÜ Danno: 27 ‚≠ê‚≠ê‚≠ê‚≠ê‚òÜ Velocit√†: ‚≠ê‚≠ê‚≠ê‚òÜ‚òÜ Passiva: ‚ùå | Molto pi√π aggressivo, richiede gestione super.'},
  boss3:{ name:'BOSS III', imgKey:'boss3', desc:'HP: 666 ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Danno:  33 ‚≠ê‚≠ê‚≠ê‚≠ê‚òÜ Velocit√†: ‚≠ê‚≠ê‚òÜ‚òÜ‚òÜ Passiva: ‚ùå | Spartiacque del gioco, alta difficolt√† tecnica.'},
  boss4:{ name:'BOSS IV', imgKey:'boss4', desc:'HP: 999 ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Danno: 35 ‚≠ê‚≠ê‚≠ê‚≠ê‚òÜ Velocit√†: ‚≠ê‚≠ê‚òÜ‚òÜ‚òÜ Passiva: üß† Attacchi telegraphed Premia lettura e tempismo.'},
  boss5:{ name:'BOSS V', imgKey:'boss5', desc:'HP: 800 ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Danno: 32 ‚≠ê‚≠ê‚≠ê‚≠ê‚òÜ Velocit√†: ‚≠ê‚≠ê‚òÜ‚òÜ‚òÜ Abilit√† passive: ‚ôªÔ∏è Rigenerazione HP ogni 28s üåä Onda di respinta üßä Rallentamento 50% per 2s se nel raggio'}
};

// Ordine consigliato nella lista
const enemyGuideOrder=['slime','drone','mech','shadow','shooter','attacker','veleno','oneyes','archer','glacial','boss1','boss2','boss3','boss4','boss5'];

function buildEnemyGuideUI(){
  const listEl=document.getElementById('enemyGuideList');
  const detailEl=document.getElementById('enemyGuideDetail');
  if(!listEl || !detailEl) return;

  listEl.innerHTML='';
  const unlocked = enemyGuideOrder.filter(k=>enemySeen && enemySeen[k] && enemyGuideData[k]);

  // empty state
  if(unlocked.length===0){
    // keep existing empty panel text
    detailEl.innerHTML = `<div class="enemy-guide-empty">
      <h3 style="margin:0 0 8px 0;color:#f39c12;">Nessun nemico sbloccato</h3>
      <p style="margin:0;color:#ddd;">Affronta un nemico o un boss almeno una volta per sbloccarlo qui.</p>
    </div>`;
    return;
  }

  function selectKey(key){
    const data=enemyGuideData[key];
    if(!data) return;

    // active state
    listEl.querySelectorAll('button').forEach(b=>b.classList.toggle('active', b.dataset.key===key));

    const img = enemyImages[data.imgKey];
    const src = (img && img.src) ? img.src : '';
    detailEl.innerHTML = `
      <div class="enemy-guide-detail-inner">
        <img src="${src}" alt="${data.name}">
        <div>
          <h3>${data.name}</h3>
          <p>${data.desc}</p>
        </div>
      </div>
    `;
  }

  for(const key of unlocked){
    const data=enemyGuideData[key];
    const btn=document.createElement('button');
    btn.type='button';
    btn.dataset.key=key;

    const img = enemyImages[data.imgKey];
    const src = (img && img.src) ? img.src : '';

    btn.innerHTML = `<img class="enemy-mini" src="${src}" alt="${data.name}"><span>${data.name}</span>`;
    btn.addEventListener('click', ()=>selectKey(key));
    listEl.appendChild(btn);
  }

  // default selection: first unlocked
  selectKey(unlocked[0]);
}

const characterStats={
  jimmy:{
    hp:305,
    speed:8*0.75,
    damage:47,
    range:600,
    cooldown:800,
    name:'Jimmy',
    attackType:'grapple',
    superCooldown:7000,
    superDuration:3000
  },
  rooney:{
    hp:410,
    speed:6*0.75,
    damage:Math.round(80*DAMAGE_MULT),
    range:150,
    cooldown:520,
    name:'Rooney',
    attackType:'punch',
    superCooldown:13000,
    superDuration:750
  },
  jeff:{
    hp:330, 
    speed:7.5*0.75,
    damage:Math.round(57*DAMAGE_MULT), // 38
    range:Math.round(320*JEFF_ATTACK_RANGE_MULT),
    cooldown:700,
    name:'Jeff',
    attackType:'sword',
    superCooldown:11000,
    superDuration:2800
  },
  voltryx:{
    hp:340, 
    speed:9*0.75,               
    damage:Math.round(55*DAMAGE_MULT),
    range:Math.round(600), 
    cooldown:650,
    name:'Voltryx',
    attackType:'hybrid',
    superCooldown:9000,
    superDuration:1500 
  },
  kouvagia:{
    hp:350,
    speed:7*0.75,
    damage:55,
    range:220,
    cooldown:760,
    name:'Kouvagia',
    attackType:'kouvagia',
    superCooldown:25000,
    superDuration:600
  },
  salsy:{
    hp:330,
    speed:8*0.75,  // leggermente pi√π veloce di prima
    damage:33,       // per colpo (x2)
    range:330,       // medio ravvicinata
    cooldown:750,
    name:'Salsy',
    attackType:'salsySword',
    superCooldown:6000,
    superDuration:400
  },
  tempostorm:{
  hp:360,
  speed:6.1*0.75, // leggermente piu di Rooney
  damage:40,      // hit iniziale (extra +30 se il nemico resta nel fascio)
  range:400,
  cooldown:850,
  name:'Tempostorm',
  attackType:'tempostormLaser',
  superCooldown:50000,
  superDuration:500
},
  marz:{
    hp:320,
    speed:6.5*0.75,
    damage:40,
    tripleDamage:[40,50,60],
    range:480,
    cooldown:820,
    name:'Marz',
    attackType:'magic',
    superCooldown:20000,
    superDuration:2200
  }

  ,hecate:{
    hp:325,
    speed:9*0.75,
    damage:52,
    range:990,
    cooldown:900,
    name:'H√®cate',
    attackType:'hecateBow',
    superCooldown:22000,
    superDuration:700
  }
};

const levelConfigs=[
  {enemyType:'slime',enemyHP:45,enemyDamage:9,enemySpeed:2*0.75,time:45,enemyCount:4},
  {enemyType:'slime',enemyHP:50,enemyDamage:10,enemySpeed:2*0.75,time:45,enemyCount:9 },
  {enemyType:'drone',enemyHP:40,enemyDamage:11,enemySpeed:3*0.75,time:40,enemyCount:6},
  {enemyType:'drone',enemyHP:40,enemyDamage:12,enemySpeed:3*0.75,time:40,enemyCount:7},
  {enemyType:'boss1',enemyHP:150,enemyDamage:20,enemySpeed:2.8*0.75,time:60,enemyCount:1},
  {enemyType:'mech',enemyHP:60,enemyDamage:16,enemySpeed:2.5*0.75,time:35,enemyCount:7},
  {enemyType:'shadow',enemyHP:50,enemyDamage:17,enemySpeed:4*0.75,time:30,enemyCount:6},
  {enemyType:'shadow',enemyHP:52,enemyDamage:18,enemySpeed:4 *0.75,time:30,enemyCount:6},
  {enemyType:'mech',enemyHP:65,enemyDamage:16,enemySpeed:2.5*0.75,time:35,enemyCount:8},
  {enemyType:'boss2',enemyHP:300,enemyDamage:27,enemySpeed:3*0.75,time:60,enemyCount:1},
  {enemyType:'shooter',enemyHP:45,enemyDamage:20,enemySpeed:2.5*0.75,time:45,enemyCount:5},
  {enemyType:'shooter',enemyHP:45,enemyDamage:21,enemySpeed:2.7*0.75,time:45,enemyCount:7},
  {enemyType:'attacker',enemyHP:90,enemyDamage:17,enemySpeed:3.2*0.75,time:50,enemyCount:5},
  {enemyType:'attacker',enemyHP:99,enemyDamage:19,enemySpeed:3.4*0.75,time:60,enemyCount:6},
  {enemyType:'boss3',enemyHP:666,enemyDamage:33,enemySpeed:2.4*0.75,time:100,enemyCount:1}
  ,{enemyType:'veleno',enemyHP:60,enemyDamage:13,enemySpeed:3.1*0.75,time:50,enemyCount:7} // Level 16
  ,{enemyType:'veleno',enemyHP:70,enemyDamage:15,enemySpeed:3.3*0.75,time:50,enemyCount:9} // Level 17
  ,{enemyType:'oneyes',enemyHP:55,enemyDamage:8,enemySpeed:2.1*0.75,time:55,enemyCount:4} // Level 18
  ,{enemyType:'oneyes',enemyHP:60,enemyDamage:9,enemySpeed:2.3*0.75,time:55,enemyCount:5} // Level 19
  ,{enemyType:'boss4',enemyHP:999,enemyDamage:35,enemySpeed:2.2*0.75,time:180,enemyCount:1} // Level 20
  ,{enemyType:'archer',enemyHP:78,enemyDamage:14,enemySpeed:2.6*0.75,time:65,enemyCount:4} // Level 21 (Ice)
  ,{enemyType:'archer',enemyHP:86,enemyDamage:15,enemySpeed:2.8*0.75,time:65,enemyCount:5} // Level 22 (Ice)
  ,{enemyType:'glacial',enemyHP:150,enemyDamage:22,enemySpeed:2.3*0.75,time:70,enemyCount:2} // Level 23 (Ice)
  ,{enemyType:'glacial',enemyHP:165,enemyDamage:24,enemySpeed:2.4*0.75,time:80,enemyCount:3} // Level 24 (Ice)

  ,{enemyType:'boss5',enemyHP:800,enemyDamage:32,enemySpeed:2.2*0.75,time:200,enemyCount:1} // Level 25 (Boss V)
];

const RECORDS_KEY='pf_records_v19'; 
// Backward compatibility: try older keys used by previous versions
const LEGACY_RECORDS_KEYS = ['pf_records_v18','pf_records_v17','pf_records_v16','pf_records_v15','pf_records'];
// bumped key to include tempostormnclude salsy + new unlock rules // bumped key to include voltryx
let records=loadRecords();
// === SANITIZZAZIONE RECORD (fix bug Marz -> H√®cate) ===
(function sanitizeRecords(){
  if(!records) return;
  // Se H√®cate ha un record ma non √® ancora realmente sbloccata,
  // e Marz ha 0, spostiamo il record su Marz.
  const hecateUnlocked = allPrevAboveHecate85k();
  if(!hecateUnlocked && records.hecate > 0 && records.marz === 0){
    records.marz = records.hecate;
    records.hecate = 0;
    try{
      localStorage.setItem(RECORDS_KEY, JSON.stringify(records));
      console.warn('[SANITIZE] Record spostato da H√®cate a Marz');
    }catch(e){}
  }
})();


function loadRecords(){
  const base={jimmy:0,rooney:0,jeff:0,voltryx:0,kouvagia:0,salsy:0,tempostorm:0,marz:0,hecate:0};
  try{
    // Primary key (current version)
    const r=localStorage.getItem(RECORDS_KEY);
    if(r){
      const obj=JSON.parse(r);
      return Object.assign({}, base, obj);
    }
    // Migration: older versions may have used a different key
    for(const k of (typeof LEGACY_RECORDS_KEYS!=='undefined'?LEGACY_RECORDS_KEYS:[])){
      const old=localStorage.getItem(k);
      if(old){
        const obj=JSON.parse(old);
        const merged=Object.assign({}, base, obj);
        // persist into the current key so future loads are stable
        try{localStorage.setItem(RECORDS_KEY, JSON.stringify(merged));}catch(e){}
        return merged;
      }
    }
  }catch(e){}
  return base;
}
function saveRecords(){
  try{localStorage.setItem(RECORDS_KEY,JSON.stringify(records))}catch(e){}
}
function updateMenuRecordsDisplay(){
  document.getElementById('record-jimmy').textContent=`Record: ${records.jimmy||0}`;
  document.getElementById('record-rooney').textContent=`Record: ${records.rooney||0}`;
  document.getElementById('record-jeff').textContent=`Record: ${records.jeff||0}`;
  document.getElementById('record-voltryx').textContent=`Record: ${records.voltryx||0}`;
  document.getElementById('record-kouvagia').textContent=`Record: ${records.kouvagia||0}`;
  document.getElementById('record-salsy').textContent=`Record: ${records.salsy||0}`;
  document.getElementById('record-tempostorm').textContent=`Record: ${records.tempostorm||0}`;
  document.getElementById('record-marz').textContent=`Record: ${records.marz||0}`;
  document.getElementById('record-hecate').textContent=`Record: ${records.hecate||0}`;
  updateVoltryxUnlockUI();
  updateKouvagiaUnlockUI();
  updateSalsyUnlockUI();
  updateTempostormUnlockUI();
  updateMarzUnlockUI();
  updateHecateUnlockUI();
  updateGuideUnlockUI();
}
function allThreeAbove50k(){
  return (records.jimmy||0)>45000 && (records.rooney||0)>45000 && (records.jeff||0)>45000;
}

function setLockBadgeState(badge, isLocked){
  if(!badge) return;
  if(isLocked){
    badge.style.display = 'block';
    badge.textContent = 'LOCKED';
    badge.style.color = '#f39c12';
    badge.style.borderColor = '#f39c12';
  } else {
    // When unlocked we want the card to look "normal": no extra UNLOCKED label.
    badge.style.display = 'none';
  }
}

function updateVoltryxUnlockUI(){
  const card=document.getElementById('card-voltryx');
  const badge=document.getElementById('voltryxLockBadge');
  if(!card||!badge) return;

  const unlocked = allThreeAbove50k();
  if(unlocked){
    card.classList.remove('disabled');
    setLockBadgeState(badge, false);
    card.title='Voltryx sbloccata!';
  }else{
    card.classList.add('disabled');
    setLockBadgeState(badge, true);
    card.title='Sblocca completando 50.000 punti con Jimmy, Rooney e Jeff';
  }
}



function voltryxAbove51k(){
  return (records.voltryx||0) >= 50000;
}

function updateKouvagiaUnlockUI(){
  const card=document.getElementById('card-kouvagia');
  const badge=document.getElementById('kouvagiaLockBadge');
  if(!card||!badge) return;

  const unlocked = voltryxAbove51k();
  if(unlocked){
    card.classList.remove('disabled');
    setLockBadgeState(badge, false);
    card.title='Kouvagia sbloccato!';
  }else{
    card.classList.add('disabled');
    setLockBadgeState(badge, true);
    card.title='Sblocca facendo 50.000 punti con Voltryx';
  }
}


function allPrevAbove70k(){
  return (records.jimmy||0)>=60000 && (records.rooney||0)>=60000 && (records.jeff||0)>=60000 && (records.voltryx||0)>=60000 && (records.kouvagia||0)>=60000;
}
function updateSalsyUnlockUI(){
  const card=document.getElementById('card-salsy');
  const badge=document.getElementById('salsyLockBadge');
  if(!card||!badge) return;

  const unlocked = allPrevAbove70k();
  if(unlocked){
    card.classList.remove('disabled');
    setLockBadgeState(badge, false);
    card.title='Salsy sbloccata!';
  }else{
    card.classList.add('disabled');
    setLockBadgeState(badge, true);
    card.title='Sblocca facendo 60.000 punti con Jimmy, Rooney, Jeff, Voltryx e Kouvagia';
  }
}



function allPrevAbove85k(){
  return (records.jimmy||0) >= 70000 &&
         (records.rooney||0) >= 70000 &&
         (records.jeff||0) >= 70000 &&
         (records.voltryx||0) >= 70000 &&
         (records.kouvagia||0) >= 70000 &&
         (records.salsy||0) >= 70000;
}
function updateTempostormUnlockUI(){
  const card=document.getElementById('card-tempostorm');
  const badge=document.getElementById('tempostormLockBadge');
  if(!card||!badge) return;

  const unlocked = allPrevAbove85k();
  if(unlocked){
    card.classList.remove('disabled');
    card.classList.remove('coming-soon');
    setLockBadgeState(badge, false);
    card.title='Tempostorm sbloccato!';
  }else{
    card.classList.add('disabled');
    setLockBadgeState(badge, true);
    card.title='Sblocca facendo 70.000 punti con tutti i personaggi precedenti (Jimmy, Rooney, Jeff, Voltryx, Kouvagia e Salsy)';
  }
}



function allPrevAboveMarz80k(){
  return (records.jimmy||0) >= 80000 &&
         (records.rooney||0) >= 80000 &&
         (records.jeff||0) >= 80000 &&
         (records.voltryx||0) >= 80000 &&
         (records.kouvagia||0) >= 80000 &&
         (records.salsy||0) >= 80000 &&
         (records.tempostorm||0) >= 80000 ;
}
function updateMarzUnlockUI(){
  const card=document.getElementById('card-marz');
  const badge=document.getElementById('marzLockBadge');
  if(!card||!badge) return;

  const unlocked = allPrevAboveMarz80k();
  if(unlocked){
    card.classList.remove('disabled');
    setLockBadgeState(badge, false);
    card.title='Marz sbloccato!';
  }else{
    card.classList.add('disabled');
    setLockBadgeState(badge, true);
    card.title='Sblocca facendo 80.000 punti con tutti i personaggi precedenti';
  }
}


function allPrevAboveHecate85k(){
  return (records.jimmy||0) >= 85000 &&
         (records.rooney||0) >= 85000 &&
         (records.jeff||0) >= 85000 &&
         (records.voltryx||0) >= 85000 &&
         (records.kouvagia||0) >= 85000 &&
         (records.salsy||0) >= 85000 &&
         (records.tempostorm||0) >= 85000 &&
         (records.marz||0) >= 85000;
}
function updateHecateUnlockUI(){
  const card=document.getElementById('card-hecate');
  const badge=document.getElementById('hecateLockBadge');
  if(!card||!badge) return;

  const unlocked = allPrevAboveHecate85k();
  if(unlocked){
    card.classList.remove('disabled');
    card.classList.remove('coming-soon');
    setLockBadgeState(badge, false);
    card.title='H√®cate sbloccata!';
  }else{
    card.classList.add('disabled');
    setLockBadgeState(badge, true);
    card.title='Sblocca facendo 85.000 punti con tutti i personaggi precedenti';
  }
}
function updateGuideUnlockUI(){
  const vUnlocked = allThreeAbove50k();
  const kUnlocked = voltryxAbove51k();
  const sUnlocked = allPrevAbove70k();
  const tUnlocked = allPrevAbove85k();
  const mUnlocked = allPrevAboveMarz80k();
  const hUnlocked = allPrevAboveHecate85k();

  const vBox=document.getElementById('guide-voltryx');
  const vLock=document.getElementById('guide-voltryx-locked');
  if(vBox&&vLock){ vBox.style.display = vUnlocked ? 'block' : 'none'; vLock.style.display = vUnlocked ? 'none' : 'block'; }

  const kBox=document.getElementById('guide-kouvagia');
  const kLock=document.getElementById('guide-kouvagia-locked');
  if(kBox&&kLock){ kBox.style.display = kUnlocked ? 'block' : 'none'; kLock.style.display = kUnlocked ? 'none' : 'block'; }

  const sBox=document.getElementById('guide-salsy');
  const sLock=document.getElementById('guide-salsy-locked');
  if(sBox&&sLock){ sBox.style.display = sUnlocked ? 'block' : 'none'; sLock.style.display = sUnlocked ? 'none' : 'block'; }

  const tBox=document.getElementById('guide-tempostorm');
  const tLock=document.getElementById('guide-tempostorm-locked');
  if(tBox&&tLock){ tBox.style.display = tUnlocked ? 'block' : 'none'; tLock.style.display = tUnlocked ? 'none' : 'block'; }

  const mBox=document.getElementById('guide-marz');
  const mLock=document.getElementById('guide-marz-locked');
  if(mBox&&mLock){ mBox.style.display = mUnlocked ? 'block' : 'none'; mLock.style.display = mUnlocked ? 'none' : 'block'; }

  const hBox=document.getElementById('guide-hecate');
  const hLock=document.getElementById('guide-hecate-locked');
  if(hBox&&hLock){ hBox.style.display = hUnlocked ? 'block' : 'none'; hLock.style.display = hUnlocked ? 'none' : 'block'; }
}


function createParticles(x,y,color,count=10,size=4){
  for(let i=0;i<count;i++){
    particles.push({
      x:x+Math.random()*20-10,
      y:y+Math.random()*20-10,
      vx:(Math.random()-0.5)*6,
      vy:(Math.random()-0.5)*6,
      life:30,
      color,size
    });
  }
}
function updateParticles(){
  particles=particles.filter(p=>{
    p.x+=p.vx;p.y+=p.vy;p.vy+=0.2;p.life--;
    return p.life>0
  });
}
function drawParticles(){
  particles.forEach(p=>{
    ctx.fillStyle=p.color;
    ctx.globalAlpha=p.life/30;
    ctx.fillRect(p.x,p.y,p.size,p.size)
  });
  ctx.globalAlpha=1
}
function showDamageNumber(x,y,dmg){
  const div=document.createElement('div');
  div.className='damage-number';
  div.textContent=`-${dmg}`;
  const rect=canvas.getBoundingClientRect();
  div.style.left=(rect.left+x)+'px';
  div.style.top=(rect.top+y-10)+'px';
  document.body.appendChild(div);
  setTimeout(()=>div.remove(),1000)
}

// ===== Lupi amichevoli (H√àCATE SUPER) =====
const WOLF_MAX = 6;
class Wolf{
  constructor(x,y){
    this.x=x; this.y=y;
    this.width=72; this.height=72;
    this.maxHP=90; this.hp=90;
    this.speed=3.5; // movimento rapido ma non OP
    this.damage=30;
    this.range=70; // morso ravvicinato
    this.cooldown=700;
    this.lastAttack=0;

    // per compatibilit√† con l'AI dei nemici (che si aspetta un "player-like")
    this.invulnerable=false;
    this.shieldActive=false;
  }
  takeDamage(d){
    if(this.hp<=0) return;
    this.hp -= d;
    createParticles(this.x+this.width/2, this.y+this.height/2, '#90caf9', 14, 4);
  }
  _nearestEnemy(){
    if(!enemies || enemies.length===0) return null;
    const cx=this.x+this.width/2, cy=this.y+this.height/2;
    let best=null, bestD=1e9;
    for(const e of enemies){
      const ex=e.x+e.width/2, ey=e.y+e.height/2;
      const d=Math.hypot(ex-cx, ey-cy);
      if(d<bestD){ bestD=d; best=e; }
    }
    return best;
  }
  update(){
    const now=Date.now();
    const target=this._nearestEnemy();
    if(!target) return;

    const cx=this.x+this.width/2, cy=this.y+this.height/2;
    const tx=target.x+target.width/2, ty=target.y+target.height/2;
    const dx=tx-cx, dy=ty-cy;
    const dist=Math.hypot(dx,dy) || 1;

    // Move towards target
    const nx=dx/dist, ny=dy/dist;
    this.x += nx*this.speed;
    this.y += ny*this.speed;

    // Clamp arena
    this.x=Math.max(0, Math.min(canvas.width-this.width, this.x));
    this.y=Math.max(0, Math.min(canvas.height-this.height, this.y));

    // Bite
    if(dist <= this.range && (now-this.lastAttack) >= this.cooldown){
      this.lastAttack=now;
      const finalDmg = Math.max(0, Math.round(this.damage * markMult(target)));
      target.hp -= finalDmg;
      showDamageNumber(target.x, target.y, finalDmg);
      createParticles(tx, ty, '#b0bec5', 10, 3);

      if(target.hp<=0){
        // kill credit: same as normal kill
        createParticles(target.x, target.y, '#fff176', 30, 6);
        const idx=enemies.indexOf(target);
        if(idx>=0) enemies.splice(idx,1);
        applyScore(100*currentLevel);
      }
    }
  }
  draw(){
    // sprite
    if(wolfImg && wolfImg.complete){
      ctx.drawImage(wolfImg, this.x, this.y, this.width, this.height);
    }else{
      ctx.fillStyle='#90caf9';
      ctx.fillRect(this.x,this.y,this.width,this.height);
    }

    // mini HP bar
    const barW=this.width, barH=6;
    const pct=Math.max(0, Math.min(1, this.hp/this.maxHP));
    ctx.fillStyle='rgba(0,0,0,0.55)';
    ctx.fillRect(this.x, this.y-10, barW, barH);
    ctx.fillStyle='#66bb6a';
    ctx.fillRect(this.x, this.y-10, barW*pct, barH);
  }
}

function spawnWolvesNearPlayer(playerObj, wanted){
  if(!playerObj) return;
  const free = Math.max(0, WOLF_MAX - (wolves?.length||0));
  const n = Math.max(0, Math.min(wanted||0, free));
  if(n<=0) return;

  const px=playerObj.x+playerObj.width/2;
  const py=playerObj.y+playerObj.height/2;

  for(let i=0;i<n;i++){
    const a=Math.random()*Math.PI*2;
    const r=55 + Math.random()*25;
    const x=Math.max(0, Math.min(canvas.width-64, px + Math.cos(a)*r - 32));
    const y=Math.max(0, Math.min(canvas.height-64, py + Math.sin(a)*r - 32));
    wolves.push(new Wolf(x,y));
    createParticles(x+32,y+32,'#90caf9',18,4);
  }
}

function updateWolves(){
  if(!wolves || wolves.length===0) return;
  // remove dead
  wolves = wolves.filter(w => w && w.hp>0);
  for(const w of wolves) w.update();
}

function drawWolves(){
  if(!wolves || wolves.length===0) return;
  for(const w of wolves) w.draw();
}

// I nemici attaccano i lupi se pi√π vicini del player
function getPreferredTarget(enemy, playerObj){
  try{
    if(!wolves || wolves.length===0) return playerObj;
    if(!enemy || !playerObj) return playerObj;

    const ex=enemy.x+enemy.width/2, ey=enemy.y+enemy.height/2;
    const px=playerObj.x+playerObj.width/2, py=playerObj.y+playerObj.height/2;
    const dp=Math.hypot(px-ex, py-ey);

    let best=null, bestD=1e9;
    for(const w of wolves){
      if(!w || w.hp<=0) continue;
      const wx=w.x+w.width/2, wy=w.y+w.height/2;
      const d=Math.hypot(wx-ex, wy-ey);
      if(d<bestD){ bestD=d; best=w; }
    }
    return (best && bestD < dp) ? best : playerObj;
  }catch(e){
    return playerObj;
  }
}

function markMult(enemy){
  return (enemy && enemy.salsyMarkUntil && Date.now() < enemy.salsyMarkUntil) ? 2 : 1;
}
function applyEnemyDamage(enemy, baseDmg){
  // Rooney EVO passive: first hit on a given enemy deals +15% damage (doesn't change stats)
  let mult=1;
  if(typeof player!=='undefined' && player && player.type==='rooney' && player.evolved && enemy && !enemy._rooneyFirstHit){
    mult=1.5; // EVO: Rooney first hit +50% damage
    enemy._rooneyFirstHit=true;
  }
  const finalDmg = Math.max(0, Math.round(baseDmg * mult * markMult(enemy)));
  enemy._lastHitAt = Date.now();
  enemy.hp -= finalDmg;
  return finalDmg;
}

function shakeScreen(){shakeAmount=8}

// Extended projectile to support friendly, AoE, homing, pulse damage
function spawnProjectile(opts){
  // opts: {x,y,vx,vy,damage,ttl,color,radius,friendly,aoeRadius,aoeFullDamage,homing,speed,isVoltryxSuper,pulseInterval,lastPulse,targetRef,explodeOnExpire}
  const p={
    x:opts.x,y:opts.y,vx:opts.vx||0,vy:opts.vy||0,
    damage:opts.damage||10,created:Date.now(),
    ttl:opts.ttl||3000,color:opts.color||'#fff',
    radius:opts.radius||6,friendly:!!opts.friendly,
    aoeRadius:opts.aoeRadius||0,aoeFullDamage:!!opts.aoeFullDamage,homing:!!opts.homing,
    speed:opts.speed||Math.hypot(opts.vx||0,opts.vy||0)||6,
    isVoltryxSuper:!!opts.isVoltryxSuper,
    pulseInterval:opts.pulseInterval||0,
    lastPulse:opts.lastPulse||0,
  targetRef:opts.targetRef||null,
    explodeOnExpire:!!opts.explodeOnExpire,
    shape:opts.shape||'circle',
    w:opts.w||0,
    h:opts.h||0,
    angle:typeof opts.angle==='number'?opts.angle:null,
    onHitPlayer:opts.onHitPlayer||null,
    meta:opts.meta||null,
    excludeRef:opts.excludeRef||null
  };
  projectiles.push(p);
}

function updateProjectiles(){
  const now=Date.now();

  // NOTE: Player/enemy freeze logic used to live here (Marz old super).
  // updateProjectiles runs in global scope; player state is handled in Player.update().


    // Grapple safety: prevent rare stuck state (e.g., Jimmy vs shooter)
    if(this.isGrappling){
      if(!this.grappleTarget || !enemies.includes(this.grappleTarget) || (this.grappleStartTime && now-this.grappleStartTime>1400)){
        this.isGrappling=false;this.grappleTarget=null;this.vx=0;this.vy=0;
          this.grappleStartTime=0;
        this.grappleStartTime=0;
        if(this.type==='jimmy' && this.shieldActive && !this.isDoingSuper) this.shieldActive=false;
      }
    }

  projectiles=projectiles.filter(p=>{
    // homing behavior (friendly):
    // - if targetRef exists and is still alive, home on it
    // - otherwise fall back to nearest enemy
    if(p.homing && p.friendly && enemies.length>0){
      let target = (p.targetRef && enemies.includes(p.targetRef)) ? p.targetRef : null;

      if(!target){
        let closest=null, best=Infinity;
        for(const e of enemies){
          const dx=(e.x+e.width/2)-p.x;
          const dy=(e.y+e.height/2)-p.y;
          const d=Math.hypot(dx,dy);
          if(d<best){best=d;closest=e}
        }
        target = closest;
      }

      if(target){
        const dx=(target.x+target.width/2)-p.x;
        const dy=(target.y+target.height/2)-p.y;
        const len=Math.hypot(dx,dy)||1;
        const steerX=(dx/len)*p.speed;
        const steerY=(dy/len)*p.speed;
        // soft steer
        p.vx = p.vx*0.6 + steerX*0.4;
        p.vy = p.vy*0.6 + steerY*0.4;
      }
    }

    p.x+=p.vx;
    p.y+=p.vy;

    // Bounds
    const aliveInBounds = p.x>=-60 && p.x<=canvas.width+60 && p.y>=-60 && p.y<=canvas.height+60;

    // Voltryx super orb pulse AoE damage
    if(p.isVoltryxSuper){
      if(!p.lastPulse || now - p.lastPulse >= p.pulseInterval){
        p.lastPulse = now;
        // damage all enemies within aoeRadius
        for(let i=enemies.length-1;i>=0;i--){
          const e=enemies[i];
        if(p.excludeRef && e===p.excludeRef) continue;
          const dist=Math.hypot((e.x+e.width/2)-p.x,(e.y+e.height/2)-p.y);
          if(dist <= p.aoeRadius){
            const dmg = p.aoeFullDamage ? Math.round(p.damage) : Math.round(p.damage*SUPER_DAMAGE_MULT);
            const _dmg=dmg; const _final=applyEnemyDamage(e,_dmg);
            createParticles(e.x,e.y,'#f39c12',12,5);
            showDamageNumber(e.x,e.y, _final);
            if(e.hp<=0){
              createParticles(e.x,e.y,'#fff176',30,6);
              enemies.splice(i,1);
              applyScore(100*currentLevel);
                if(this.type==='kouvagia'){this.hp=Math.min(this.maxHP,this.hp+3);createParticles(this.x,this.y,'#2ecc71',6,3);}
            }
          }
        }
      }
    }

    // Collision: friendly hits enemies
    if(p.friendly){
      for(let i=enemies.length-1;i>=0;i--){
        const e=enemies[i];
        const dx=(e.x+e.width/2)-p.x;
        const dy=(e.y+e.height/2)-p.y;
        const dist=Math.hypot(dx,dy);
        if(dist <= (p.radius + Math.max(e.width,e.height)/2)*0.8){
          // impact
          if(p.aoeRadius>0){
            // area explosion
            for(let j=enemies.length-1;j>=0;j--){
              const ee=enemies[j];
              const d2=Math.hypot((ee.x+ee.width/2)-p.x,(ee.y+ee.height/2)-p.y);
              if(d2<=p.aoeRadius){
                const dmg = p.aoeFullDamage ? Math.round(p.damage) : Math.round(p.damage*SUPER_DAMAGE_MULT);
                const _dmg=dmg; const _final=applyEnemyDamage(ee,_dmg);
                createParticles(ee.x,ee.y,'#ffb74d',8,4);
                showDamageNumber(ee.x,ee.y, _final);
                if(ee.hp<=0){
                  createParticles(ee.x,ee.y,'#fff176',30,6);
                  enemies.splice(j,1);
                  applyScore(100*currentLevel);
                }
              }
            }
          }else{
            // single target
            const dmg=Math.round(p.damage);
            const _dmg=dmg; const _final=applyEnemyDamage(e,_dmg);
            createParticles(e.x,e.y,'#ffd54f',8,4);
            showDamageNumber(e.x,e.y, _final);
            // H√®cate: main arrow splits into 3 arrows to OTHER enemies
            if(p.meta && p.meta.type==='hecateMain'){
              const impactX=p.x, impactY=p.y;
              createParticles(impactX, impactY, '#c5cae9', 18, 4);
              const others = enemies.filter(ee=>ee!==e).sort((a,b)=>{
                const da=Math.hypot((a.x+a.width/2)-impactX,(a.y+a.height/2)-impactY);
                const db=Math.hypot((b.x+b.width/2)-impactX,(b.y+b.height/2)-impactY);
                return da-db;
              }).slice(0,3);
              const splitDmg = Math.round((p.meta.splitDamage || Math.round(p.damage * 0.5)));
              for(const t of others){
                const dx=(t.x+t.width/2)-impactX;
                const dy=(t.y+t.height/2)-impactY;
                const len=Math.hypot(dx,dy)||1;
                const speed=12;
                const vx=(dx/len)*speed;
                const vy=(dy/len)*speed;
                spawnProjectile({
                  x:impactX,y:impactY,vx,vy,speed,
                  damage:splitDmg,ttl:520,color:'#c5cae9',
                  radius:6,friendly:true,
                  shape:'rect',w:18,h:4,angle:Math.atan2(vy,vx),
                  excludeRef:e
                });
                createParticles(impactX,impactY,'#c5cae9',6,3);
              }
            }
            if(e.hp<=0){
              createParticles(e.x,e.y,'#fff176',30,6);
              enemies.splice(i,1);
              applyScore(100*currentLevel);
                if(this.type==='kouvagia'){this.hp=Math.min(this.maxHP,this.hp+3);createParticles(this.x,this.y,'#2ecc71',6,3);}
            }
          }
          return false; // projectile consumed
        }
      }
    }else{
      // enemy projectiles hit player
      if(player && p.x>player.x && p.x<player.x+player.width && p.y>player.y && p.y<player.y+player.height){
        if(typeof p.onHitPlayer==='function'){ try{ p.onHitPlayer(player); }catch(e){} }
        player.takeDamage(p.damage);
        return false;
      }
    }

    const aliveTime = (now-p.created)<p.ttl;
    const alive = aliveTime && aliveInBounds;

    // Optional AoE explosion when the projectile stops (ttl end / out of bounds)
    if(!alive && p.explodeOnExpire && p.friendly && p.aoeRadius>0){
      // apply AoE at last position
      for(let j=enemies.length-1;j>=0;j--){
        const ee=enemies[j];
        const dx=(ee.x+ee.width/2)-p.x;
        const dy=(ee.y+ee.height/2)-p.y;
        const d=Math.hypot(dx,dy);
        if(d<=p.aoeRadius){
          const dmg=Math.round(p.damage);
          const _dmg=dmg; const _final=applyEnemyDamage(ee,_dmg);
          createParticles(ee.x,ee.y,'#ffb74d',8,4);
          showDamageNumber(ee.x,ee.y, _final);
          if(ee.hp<=0){
            createParticles(ee.x,ee.y,'#fff176',30,6);
            enemies.splice(j,1);
            applyScore(100*currentLevel);
          }
        }
      }
      createParticles(p.x,p.y,'#ffa726',18,5);
    }

    return alive;
  });
}

function drawProjectiles(){
  projectiles.forEach(p=>{
    ctx.globalAlpha = p.isVoltryxSuper ? 0.8 : 1;

    // Archer arrows (small elongated hits)
    if(p.shape==='rect'){
      const ang = (p.angle!==null && !Number.isNaN(p.angle)) ? p.angle : Math.atan2(p.vy||0, p.vx||0);
      const w = p.w || 16;
      const h = p.h || 4;
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(ang);
      ctx.fillStyle=p.color;
      ctx.fillRect(-w/2, -h/2, w, h);
      ctx.restore();
      ctx.globalAlpha = 1;
      return;
    }

    // Default circular bullets
    ctx.fillStyle=p.color;
    ctx.beginPath();
    ctx.arc(p.x,p.y,p.isVoltryxSuper ? 18 : p.radius,0,Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    if(p.isVoltryxSuper){
      // draw a soft aura
      ctx.strokeStyle='rgba(243,156,18,0.5)';
      ctx.lineWidth=4;
      ctx.beginPath();
      ctx.arc(p.x,p.y,p.aoeRadius,0,Math.PI*2);
      ctx.stroke();
    }
  });
}


// Laser hazards (OneEyes + Boss4)
function spawnLaser(opts){
  // opts: {x,y,angle,length,width,ttl,damage,kind,chargeMs,chargedAt}
  lasers.push({
    x:opts.x,y:opts.y,angle:opts.angle||0,length:opts.length||520,width:opts.width||14,
    created:Date.now(),ttl:opts.ttl||1000,damage:opts.damage||15,
    kind:opts.kind||'laser', chargeMs:opts.chargeMs||0, chargedAt:Date.now()+ (opts.chargeMs||0),
    hitCooldown:220, lastHit:0,
    hitOnce:false
  });
}

function updateLasers(){
  const now=Date.now();
  lasers = lasers.filter(L=>{
    const alive = (now - L.created) < (L.ttl + (L.chargeMs||0));
    if(!alive) return false;

    // During charge: no damage
    const active = now >= L.chargedAt;

    if(active && player){
      // Collision: distance from player center to laser segment
      const px = player.x + player.width/2;
      const py = player.y + player.height/2;

      const x2 = L.x + Math.cos(L.angle)*L.length;
      const y2 = L.y + Math.sin(L.angle)*L.length;

      // projection
      const vx = x2 - L.x, vy = y2 - L.y;
      const wx = px - L.x, wy = py - L.y;
      const c1 = wx*vx + wy*vy;
      const c2 = vx*vx + vy*vy;
      let t = c2 ? (c1 / c2) : 0;
      t = Math.max(0, Math.min(1, t));
      const cx = L.x + t*vx;
      const cy = L.y + t*vy;
      const dist = Math.hypot(px - cx, py - cy);

      if(dist <= (L.width/2 + Math.max(player.width, player.height)*0.20)){
        // OneEyes: il danno pu√≤ essere preso una sola volta per raggio
        if(L.kind==='oneyes'){
          if(!L.hitOnce){
            L.hitOnce=true;
            player.takeDamage(L.damage);
          }
        } else {
          if(now - L.lastHit >= L.hitCooldown){
            L.lastHit = now;
            player.takeDamage(L.damage);
          }
        }
      }
    }

    return true;
  });
}

function drawLasers(){
  const now=Date.now();
  lasers.forEach(L=>{
    const active = now >= L.chargedAt;
    const x2 = L.x + Math.cos(L.angle)*L.length;
    const y2 = L.y + Math.sin(L.angle)*L.length;

    ctx.save();
    ctx.lineCap='round';

    if(!active){
      // charge preview
      ctx.globalAlpha = 0.55;
      ctx.strokeStyle = 'rgba(255,255,255,0.7)';
      ctx.lineWidth = Math.max(6, L.width*0.5);
      ctx.beginPath(); ctx.moveTo(L.x,L.y); ctx.lineTo(x2,y2); ctx.stroke();
      ctx.globalAlpha = 1;
    } else {
      // active beam
      ctx.globalAlpha = (L.kind==='photon') ? 0.92 : 0.75;
      ctx.strokeStyle = (L.kind==='photon') ? 'rgba(243,156,18,0.9)' : 'rgba(52,152,219,0.9)';
      ctx.lineWidth = L.width;
      ctx.beginPath(); ctx.moveTo(L.x,L.y); ctx.lineTo(x2,y2); ctx.stroke();

      // glow
      ctx.globalAlpha = 0.28;
      ctx.lineWidth = L.width*1.9;
      ctx.beginPath(); ctx.moveTo(L.x,L.y); ctx.lineTo(x2,y2); ctx.stroke();
      ctx.globalAlpha = 1;
    }

    ctx.restore();
  });
}


function spawnTempBeam(opts){
  // opts: {x1,y1,x2,y2,width,ttl,damage1,damageStay,friendly}
  tempBeams.push({
    x1:opts.x1,y1:opts.y1,x2:opts.x2,y2:opts.y2,
    width:opts.width||18,
    created:Date.now(),
    ttl:opts.ttl||260,
    damage1:opts.damage1||40,
    damageStay:opts.damageStay||30,
    hitMap:new Map() // enemy -> {firstHit, left, extraDone}
  });
}

// distance from point to segment
function _distPointToSeg(px,py,x1,y1,x2,y2){
  const vx=x2-x1, vy=y2-y1;
  const wx=px-x1, wy=py-y1;
  const c1=wx*vx+wy*vy;
  if(c1<=0) return Math.hypot(px-x1,py-y1);
  const c2=vx*vx+vy*vy;
  if(c2<=c1) return Math.hypot(px-x2,py-y2);
  const b=c1/c2;
  const bx=x1+b*vx, by=y1+b*vy;
  return Math.hypot(px-bx,py-by);
}

function updateTempBeams(){
  const now=Date.now();
  for(let i=tempBeams.length-1;i>=0;i--){
    const B=tempBeams[i];
    const age=now-B.created;
    if(age>B.ttl){ tempBeams.splice(i,1); continue; }

    // collisions with enemies
    enemies.forEach(e=>{
      const ex=e.x+e.width/2, ey=e.y+e.height/2;
      const dist=_distPointToSeg(ex,ey,B.x1,B.y1,B.x2,B.y2);
      const inside = dist <= (B.width*0.55 + Math.max(e.width,e.height)*0.18);

      const state = B.hitMap.get(e);
      if(inside){
        if(!state){
          // first hit
          const dmg = B.damage1;
          const final = applyEnemyDamage(e, dmg);
          showDamageNumber(e.x,e.y, final);
          createParticles(e.x+e.width/2,e.y+e.height/2,'#4fc3f7',10,4);
          B.hitMap.set(e,{firstHit:now,left:false,extraDone:false});
        } else {
          // check linger bonus only if stayed inside continuously
          if(!state.extraDone && !state.left && (now - state.firstHit) >= 180){
            const dmg2=B.damageStay;
            const final2 = applyEnemyDamage(e, dmg2);
            showDamageNumber(e.x,e.y, final2);
            createParticles(e.x+e.width/2,e.y+e.height/2,'#81d4fa',12,4);
            state.extraDone=true;
          }
        }
      } else {
        if(state && !state.extraDone){
          state.left=true;
        }
      }
    });
  }
}

function drawTempBeams(){
  tempBeams.forEach(B=>{
    const x1=B.x1, y1=B.y1, x2=B.x2, y2=B.y2;
    ctx.save();
    ctx.lineCap='round';

    // glow
    ctx.globalAlpha=0.22;
    ctx.strokeStyle='#00b0ff';
    ctx.lineWidth=B.width*2.4;
    ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();

    // core
    ctx.globalAlpha=0.85;
    ctx.strokeStyle='#4fc3f7';
    ctx.lineWidth=B.width;
    ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();

    // white highlight
    ctx.globalAlpha=0.65;
    ctx.strokeStyle='rgba(255,255,255,0.9)';
    ctx.lineWidth=Math.max(2, B.width*0.22);
    ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();

    ctx.restore();
  });
}

function spawnPickup(x,y,type,value=0){
  // Small collectible pickup (compatible with updatePickups / drawPickups)
  const hitR = (type==='malus') ? MALUS_HIT_RADIUS : BONUS_HIT_RADIUS;
  pickups.push({x,y,type,value,created:Date.now(),ttl:20000,radius:18,hitRadius:hitR,w:28,h:28});
}
function spawnPickupsForLevel(level){
  // IMPORTANT: do NOT clear existing pickups here.
  // Bonus pickups remain on the field when the level ends.
  if(level<4) return;

  const count=1+Math.floor(Math.random()*2);
  for(let i=0;i<count;i++){
    const isGold=Math.random()<GOLD_PROB;
    const type=isGold ? 'gold' : pickRandomPickupType();

    const x=60+Math.random()*(canvas.width-120);
    const y=60+Math.random()*(canvas.height-180);

    const hitR = (type==='malus') ? MALUS_HIT_RADIUS : BONUS_HIT_RADIUS;
    // keep visual size small (radius:18) but increase hitbox via hitRadius
    pickups.push({type,x,y,radius:18,hitRadius:hitR,created:Date.now(),ttl:20000});
  }
}
function drawPickups(){
  pickups.forEach(p=>{
    const img = getPickupImage(p.type);
    // Keep the existing small pickup size:
    // - if pickup defines w/h use those
    // - else if pickup defines radius use diameter
    // - fallback to 28px
    const w = (p.w!=null)?p.w: (p.radius!=null)?(p.radius*2):28;
    const h = (p.h!=null)?p.h: (p.radius!=null)?(p.radius*2):28;
    const dw = w*2;
    const dh = h*2;

    if(img && img.complete && img.naturalWidth>0){
      ctx.drawImage(img, p.x - dw/2, p.y - dh/2, dw, dh);
    } else {
      // Fallback if image not yet loaded
      if(p.type==='heal')ctx.fillStyle='#2ecc71';
      else if(p.type==='atk')ctx.fillStyle='#e74c3c';
      else if(p.type==='super')ctx.fillStyle='#f1c40f';
      else if(p.type==='gold')ctx.fillStyle='gold';
      else if(p.type==='speed')ctx.fillStyle='#3498db';
      else if(p.type==='shieldPickup')ctx.fillStyle='#7fdbff';
      else if(p.type==='malus')ctx.fillStyle='#8b0000';
      ctx.beginPath();
      ctx.arc(p.x,p.y,(p.radius!=null)?p.radius:Math.min(w,h)/2,0,Math.PI*2);
      ctx.fill();
    }
  });
}

function updatePickups(playerRef){
  pickups=pickups.filter(p=>{
    if(Date.now()-p.created>p.ttl) return false;
    const dist=Math.hypot((p.x-playerRef.x),(p.y-playerRef.y));
    const pr = (p.hitRadius!=null) ? p.hitRadius : (p.radius!=null ? p.radius : 18);
    if(dist<pr+Math.max(playerRef.width,playerRef.height)/2){
      applyPickupEffect(playerRef,p.type);
      return false;
    }
    return true;
  });
}
function applyPickupEffect(playerRef,type){
  if(type==='heal'){
    const healAmount=Math.round(playerRef.maxHP*0.25);
    playerRef.hp=Math.min(playerRef.maxHP,playerRef.hp+healAmount);
    createParticles(playerRef.x,playerRef.y,'#2ecc71',20);
  } else if(type==='atk'){
    playerRef.attackBuffMultiplier=1.6;
    playerRef.attackBuffUntil=Date.now()+10000;
    createParticles(playerRef.x,playerRef.y,'#e74c3c',20);
  } else if(type==='super'){
    playerRef.lastSuper=Date.now()-playerRef.superCooldown-100;
    createParticles(playerRef.x,playerRef.y,'#f1c40f',20);
  } else if(type==='gold'){
    playerRef.hp=playerRef.maxHP;
    playerRef.attackBuffMultiplier=2.0;
    playerRef.attackBuffUntil=Date.now()+15000;
    playerRef.lastSuper=Date.now()-playerRef.superCooldown-100;
    createParticles(playerRef.x,playerRef.y,'gold',40);
    for(let i=0;i<8;i++) createParticles(playerRef.x+(Math.random()-0.5)*40,playerRef.y+(Math.random()-0.5)*40,'#fff176',6);
  } else if(type==='speed'){
    playerRef.speed=playerRef._baseSpeed*1.5;
    playerRef.speedBuffUntil=Date.now()+7000;
    createParticles(playerRef.x,playerRef.y,'#3498db',20);
  } else if(type==='shieldPickup'){
    playerRef.pickupShieldUntil=Date.now()+6000;
    playerRef.invulnerable=true;
    createParticles(playerRef.x,playerRef.y,'#7fdbff',30);

    } else if(type==='furia'){
    // Cura nel tempo: +10 HP/s per 10s
    playerRef.furiaHealUntil = Date.now()+10000;
    playerRef.furiaLastHeal = Date.now();

    // Onde di danno (3 aree visibili che si allargano)
    const cx = playerRef.x + playerRef.width/2;
    const cy = playerRef.y + playerRef.height/2;
    spawnFuriaWaves(cx, cy);

    // Extra feedback visivo
    createParticles(cx,cy,'#ff00ff',70,6);
  } else if(type==='ice'){
    enemies.forEach(e=>{
      e.speed *= 0.4;
      e.iceUntil = Date.now()+17000;
      e.iceDps = 2;
      e.iceLastTick = Date.now();
    });
    createParticles(playerRef.x,playerRef.y,'#ffffff',40);
  } else if(type==='malus'){
    playerRef.poisonUntil=Date.now()+10000;
    playerRef.poisonTickLast=Date.now();
    playerRef.poisonTickDamage=1;
    createParticles(playerRef.x,playerRef.y,'#8b0000',30);
  }
}

class Player{
  constructor(type){
    const s=characterStats[type];
    this.type=type;
    this.x=canvas.width/2;this.y=canvas.height/2;
    this.width=130;this.height=135;
    this.vx=0;this.vy=0;
    this.maxHP=s.hp;this.hp=s.hp;
    this.speed=s.speed;this._baseSpeed=s.speed;
    // Archer slow (temporary): stacks up to -15% total
    this._slowPct=0;
    this._slowUntil=0;
    this.damage=s.damage;this.range=s.range;
    this.cooldown=s.cooldown;this.attackType=s.attackType;
    this.lastAttack=0;this.facingRight=true;
    this.dashCooldown=0;this.attacking=false;this.attackTime=0;
    this.combo=0;this.damageTaken=0;this.isDashing=false;this.dashTime=0;
    this.superCooldown=s.superCooldown;this.superDuration=s.superDuration;
    this.lastSuper=-s.superCooldown;this.isDoingSuper=false;this.superStartTime=0;
    this.superTargets=[];this.grappleTarget=null;this.isGrappling=false;
    this.grappleStartTime=0; // safety timeout for grapple

    // Jimmy SUPER grapple pass-through helpers (no "grab" interaction)
    this._superGrapplePassUntil=0;
    this._superGrappleDirX=1;
    this._superGrappleDirY=0;
    this.aimAssistRadius=400;this.aimAssistStrength=0.35;
    this._superHitDone=false;this._superPhase=0;
    this.shieldActive=false;this.shieldDurability=4;this.shieldMaxDurability=4;this.shieldBroken=false;this.shieldBrokenTime=0;this.shieldRegenMs=6000;
    this.attackBuffMultiplier=1;this.attackBuffUntil=0;this.speedBuffUntil=0;this.pickupShieldUntil=0;this.invulnerable=false;
    this._dashSpeedMult=3;
    this._dashDuration=200;

    // Kouvagia dash-attack helpers
    this._kouvagiaDashActive=false;
    this._kouvagiaDashHitCd=0;
    this._kouvagiaExplosionPending=false;
    this._kouvagiaSuperFxStart=0;
    this._kouvagiaSuperFxUntil=0;

    // Jimmy jetpack
    this.jetpackCooldown=15000;
    this.lastJetpack=Date.now()-this.jetpackCooldown;
    this.isJetpacking=false;
    this.jetpackDuration=3000;
    this._jetpackSpeedMultiplier=2;

    this.lastSuper=-99999;
    this.poisonUntil=0;
    this.poisonTickLast=0;
    this.poisonTickDamage=1;

    // --- Evolution (after Boss level 15) ---
    this.evolved=false;
    this._evoFxUntil=0;
    this._jimmyNextGrappleCdMult=1;
  }

  evolve(){
    if(this.evolved) return;
    this.evolved=true;
    this._evoFxUntil=Date.now()+650;
    // passive is enabled by this.evolved flag, no stat changes
  }


  // Rallentamento temporaneo (usato da alcuni nemici/boss)
  // pct: 0.10 = -10% velocit√†. durationMs in millisecondi.
  applySlow(pct, durationMs){
    const now=Date.now();
    const p=Math.max(0, Math.min(0.60, pct||0)); // cap 60% (Boss5 usa 50%)
    this._slowPct = Math.min(0.60, Math.max(this._slowPct||0, p));
    this._slowUntil = Math.max(this._slowUntil||0, now + (durationMs||0));
  }

  findClosestEnemy(radius=this.aimAssistRadius){
    let closest=null;let best=radius;
    enemies.forEach(e=>{
      const dx=(e.x+e.width/2)-(this.x+this.width/2);
      const dy=(e.y+e.height/2)-(this.y+this.height/2);
      const dist=Math.hypot(dx,dy);
      if(dist<best){best=dist;closest=e}
    });
    return closest;
  }

  update(){
    const now=Date.now();

    if(this.shieldBroken&&now-this.shieldBrokenTime>this.shieldRegenMs){
      this.shieldBroken=false;this.shieldDurability=this.shieldMaxDurability
    }
    if(this.attackBuffUntil && now>this.attackBuffUntil){this.attackBuffMultiplier=1;this.attackBuffUntil=0}
    if(this._slowUntil && now>this._slowUntil){ this._slowUntil=0; this._slowPct=0; }
    if(this.speedBuffUntil && now>this.speedBuffUntil){
      this.speed=this._baseSpeed;this.speedBuffUntil=0;this.isJetpacking=false;this.invulnerable=false
    }
    if(this.pickupShieldUntil && now>this.pickupShieldUntil){this.pickupShieldUntil=0;this.invulnerable=false}

    // Furia heal-over-time (+10 HP/s for 10s)
    if(this.furiaHealUntil && now < this.furiaHealUntil){
      if(!this.furiaLastHeal) this.furiaLastHeal = now;
      if(now - this.furiaLastHeal >= 1000){
        this.furiaLastHeal = now;
        this.hp = Math.min(this.maxHP, this.hp + 10);
        createParticles(this.x+this.width/2, this.y+this.height/2, '#ff00ff', 8, 3);
      }
    } else {
      this.furiaLastHeal = 0;
      this.furiaHealUntil = 0;
    }

    // Jimmy jetpack passive
    if(this.type==='jimmy'){
      if(!this.isJetpacking && now-this.lastJetpack>=this.jetpackCooldown && !this.isDoingSuper){
        this.isJetpacking=true;
        this.lastJetpack=now;
        this.invulnerable=true;
        this.speed=this._baseSpeed * this._jetpackSpeedMultiplier;
        this.speedBuffUntil=now+this.jetpackDuration;
      }
      if(this.isJetpacking && now>=this.speedBuffUntil){
        this.isJetpacking=false;
        this.invulnerable=false;
        this.speed=this._baseSpeed;
      }
    }


    // Salsy passive: speed boost every 12s for 2s (DOUBLES BASE SPEED ONLY)
    if(this.type==='salsy'){
      if(!this._salsyBoostCooldown){
        this._salsyBoostCooldown = 12000;
        this._salsyBoostDuration = 2000;
        this.lastSalsyBoost = now - this._salsyBoostCooldown;
        this.salsyBoostUntil = 0;
      }

      if(!this.isDoingSuper && now - this.lastSalsyBoost >= this._salsyBoostCooldown){
        this.lastSalsyBoost = now;
        this.salsyBoostUntil = now + this._salsyBoostDuration;
      }

      if(this.salsyBoostUntil && now < this.salsyBoostUntil){
        // SOLO velocit√† base raddoppiata
        this.speed = this._baseSpeed * 2;
      }
      else if(this.salsyBoostUntil && now >= this.salsyBoostUntil){
        this.salsyBoostUntil = 0;

        // Ripristino corretto
        if(this.speedBuffUntil && now < this.speedBuffUntil){
          this.speed = this._baseSpeed * 1.5;
        } else {
          this.speed = this._baseSpeed;
        }
      }
    }

    // Poison

    if(this.poisonUntil && now < this.poisonUntil){
      if(!this.poisonTickLast) this.poisonTickLast = now;
      if(now - this.poisonTickLast >= 1000){
        this.poisonTickLast = now;
        this.hp = Math.max(0, this.hp - (this.poisonTickDamage||1));
        createParticles(this.x,this.y,'#8b0000',6,3);
        if(this.hp<=0 && gameState==='playing') endGame(false);
      }
    } else this.poisonTickLast = 0;

    // Movement
    let moveX=0,moveY=0;
    if(!this.isGrappling){
      if(keys['a']){moveX=-1;this.facingRight=false}
      if(keys['d']){moveX=1;this.facingRight=true}
      if(keys['w'])moveY=-1;
      if(keys['s'])moveY=1
    }
    if(moveX!==0&&moveY!==0){moveX*=0.707;moveY*=0.707}

    // Marz super bonus: +50% speed while inside the magic zone
    const marzZoneMult = (this.type==='marz' && isPointInsideMagicZone(this.x+this.width/2, this.y+this.height/2)) ? 1.5 : 1;

    if(this.isDashing){
      const speedNow=this.speed*marzZoneMult*(1-(this._slowPct||0));
      const dashSpeed=speedNow*(this._dashSpeedMult||3);
      this.vx=(this.facingRight?1:-1)*dashSpeed;
      if(this.type==='kouvagia' && this._kouvagiaDashActive){this.vy=0;}

      // Kouvagia: deal damage during dash (tick-based)
      if(this.type==='kouvagia' && this._kouvagiaDashActive){
        if(this._kouvagiaDashHitCd<=0){
          this._kouvagiaDashHitCd=4; // roughly every few frames
          for(let i=enemies.length-1;i>=0;i--){
            const e=enemies[i];
            const dist=Math.hypot((e.x+e.width/2)-(this.x+this.width/2),(e.y+e.height/2)-(this.y+this.height/2));
            if(dist<110){
              const dmg=Math.round(40*this.attackBuffMultiplier);
              const _dmg=dmg; const _final=applyEnemyDamage(e,_dmg);
              createParticles(e.x,e.y,'#e84393',10,5);
              showDamageNumber(e.x,e.y, _final);
              if(e.hp<=0){
                createParticles(e.x,e.y,'#fff176',30,6);
                enemies.splice(i,1);
                applyScore(100*currentLevel);
                if(this.type==='kouvagia'){this.hp=Math.min(this.maxHP,this.hp+3);createParticles(this.x,this.y,'#2ecc71',6,3);}
              }
            }
          }
        }else this._kouvagiaDashHitCd--;
      }
      if(now-this.dashTime>(this._dashDuration||200)){
        this.isDashing=false; this.vx=0; this.vy=0; this._dashSpeedMult=3; this._dashDuration=200; if(this.type==='kouvagia'){this._kouvagiaDashActive=false;}
        // Kouvagia: explosion at end of dash
        if(this.type==='kouvagia' && this._kouvagiaExplosionPending){
          this._kouvagiaExplosionPending=false;
    this._kouvagiaSuperFxStart=0;
    this._kouvagiaSuperFxUntil=0;
          this._kouvagiaDashActive=false;
          for(let i=enemies.length-1;i>=0;i--){
            const e=enemies[i];
            const dist=Math.hypot((e.x+e.width/2)-(this.x+this.width/2),(e.y+e.height/2)-(this.y+this.height/2));
            if(dist<165){
              const dmg=Math.round(65*this.attackBuffMultiplier);
              const _dmg=dmg; const _final=applyEnemyDamage(e,_dmg);
              createParticles(e.x,e.y,'#fd79a8',16,5);
              showDamageNumber(e.x,e.y, _final);
              if(e.hp<=0){
                createParticles(e.x,e.y,'#fff176',30,6);
                enemies.splice(i,1);
                applyScore(100*currentLevel);
                if(this.type==='kouvagia'){this.hp=Math.min(this.maxHP,this.hp+3);createParticles(this.x,this.y,'#2ecc71',6,3);}
              }
            }
          }
          shakeScreen();
        }

      }
    } else if(!this.isGrappling){
      const speedNow=this.speed*marzZoneMult*(1-(this._slowPct||0));
      this.vx=moveX*speedNow+this.vx*0.1;
            this.vy=moveY*speedNow+this.vy*0.1;
    }

    // Grapple chase
    // Jimmy grapple rework:
    // - L'attacco base NON "si attacca" al bersaglio: Jimmy si avvicina e si ferma a pochi pixel.
    // - Quando √® abbastanza vicino, esegue un colpo a ventaglio (120¬∞) con raggio 90.
    if(this.isGrappling&&this.grappleTarget){
      if(!enemies.includes(this.grappleTarget)){
        this.isGrappling=false;this.grappleTarget=null;this.grappleStartTime=0;
      } else {
        const pcx=this.x+this.width/2, pcy=this.y+this.height/2;
        const tcx=this.grappleTarget.x+this.grappleTarget.width/2, tcy=this.grappleTarget.y+this.grappleTarget.height/2;
        const dx=tcx-pcx;const dy=tcy-pcy;
        const dist=Math.hypot(dx,dy);const speedMult=5;

        const stopDist=62; // "un po' di pixel" dal nemico
        if(dist>stopDist){
          this.vx=(dx/(dist||1))*this.speed*marzZoneMult*speedMult;
          this.vy=(dy/(dist||1))*this.speed*marzZoneMult*speedMult;
        } else {
          // Fan hit: 120¬∞ cone, radius 90 (small hit)
          const dirAngle=Math.atan2(dy,dx);
          const arcWidth=Math.PI*(120/180);
          const radius=90;

          const baseDmg=Math.round(this.damage*0.65*this.attackBuffMultiplier);

          let killedGrappleTarget=false;

          for(let i=enemies.length-1;i>=0;i--){
            const e=enemies[i];
            const ex=e.x+e.width/2, ey=e.y+e.height/2;
            const edx=ex-pcx, edy=ey-pcy;
            const edist=Math.hypot(edx,edy);
            if(edist<=radius){
              const ang=Math.atan2(edy,edx);
              let diff=ang-dirAngle;
              while(diff>Math.PI) diff-=Math.PI*2;
              while(diff<-Math.PI) diff+=Math.PI*2;
              if(Math.abs(diff)<=arcWidth/2){
                const _final=applyEnemyDamage(e, baseDmg);
                createParticles(e.x,e.y,'#e74c3c',14,5);
                showDamageNumber(e.x,e.y,_final);
                if(e.hp<=0){
                  if(e===this.grappleTarget) killedGrappleTarget=true;
                  createParticles(e.x,e.y,'#fff176',30,6);
                  enemies.splice(i,1);
                  applyScore(100*currentLevel);
                }
              }
            }
          }

          // Jimmy EVO passive: next grapple has -20% cooldown after a grappled target dies
          if(this.type==='jimmy' && this.evolved && killedGrappleTarget){ this._jimmyNextGrappleCdMult=0.8; }

          this.isGrappling=false;this.grappleTarget=null;this.vx=0;this.vy=0;this.grappleStartTime=0;
        }
      }
    }

    // Super handling
    if(this.isDoingSuper){
      const elapsed=now-this.superStartTime;
      if(this.type==='jimmy'){this.invulnerable=true;this.shieldActive=true}

      if(this.attackType==='punch'){
        if(!this._superHitDone&&elapsed>=300){
          this._superHitDone=true;
          if(this.type==='rooney'){
            // Rooney SUPER (rework):
            // - Area QUADRATA centrata su Rooney.
            // - Danno totale massimo: 300 (senza buff) distribuito tra TUTTI i nemici nell'area.
            // - Falloff: pi√π un nemico √® lontano dal centro, meno danno subisce.
            const half=200; // mezzo lato del quadrato (lato=400)
            const px=this.x+this.width/2, py=this.y+this.height/2;
            const hits=[];
            const maxDist=Math.hypot(half,half) || 1;

            for(const enemy of enemies){
              const ex=enemy.x+enemy.width/2, ey=enemy.y+enemy.height/2;
              const dx=ex-px, dy=ey-py;
              if(Math.abs(dx)<=half && Math.abs(dy)<=half){
                const dist=Math.hypot(dx,dy);
                const w=Math.max(0.10, 1 - (dist/maxDist)); // minimo 10% al bordo
                hits.push({enemy,w, dist});
              }
            }

            if(hits.length>0){
              // Compensiamo SUPER_DAMAGE_MULT cos√¨ che la SOMMA dei danni (senza buff) sia 300.
              const totalBase=Math.round(350 / SUPER_DAMAGE_MULT);
              const sumW=hits.reduce((a,h)=>a+h.w,0) || 1;

              for(const h of hits){
                const share=h.w/sumW;
                const raw=totalBase*share;
                const dmg=Math.max(6, Math.round(raw * SUPER_DAMAGE_MULT * this.attackBuffMultiplier));
                const _final=applyEnemyDamage(h.enemy, dmg);

                // Hit FX
                createParticles(h.enemy.x,h.enemy.y,'#f39c12',22,6);
                showDamageNumber(h.enemy.x,h.enemy.y, _final);
              }

              // Ground-break FX (debris + dust) nell'area quadrata
              createParticles(px,py,'#795548',55,8);
              for(let k=0;k<12;k++){
                const rx=px + (Math.random()*2-1)*half;
                const ry=py + (Math.random()*2-1)*half;
                createParticles(rx,ry,'#6d4c41',14,6);
                createParticles(rx,ry,'#b0bec5',8,4);
              }

              // rimuovi i morti (e assegna score) subito, come per le altre super
              for(let i=enemies.length-1;i>=0;i--){
                if(enemies[i].hp<=0){
                  createParticles(enemies[i].x,enemies[i].y,'#fff176',30,6);
                  enemies.splice(i,1);
                  applyScore(100*currentLevel);
                }
              }
            }
          } else {
            enemies.forEach((enemy,idx)=>{
              const dist=Math.hypot(enemy.x-this.x,enemy.y-this.y);
              if(dist<350){
                const base=(this.type==='jimmy')?300:140;
                const mult=(this.type==='jimmy')?(SUPER_DAMAGE_MULT*JIMMY_SUPER_ADDITIONAL_MULT):SUPER_DAMAGE_MULT;
                let extra=1;if(this.type==='rooney'&&dist<150)extra=1.5;
                const dmg=Math.round(base*mult*extra*this.attackBuffMultiplier);
                const _dmg=dmg; const _final=applyEnemyDamage(enemy,_dmg);
                createParticles(enemy.x,enemy.y,'#f39c12',30,6);
                showDamageNumber(enemy.x,enemy.y, _final);
                if(enemy.hp<=0){
  if(player && player.type==='jeff' && player.evolved){
    player.hp = Math.min(player.maxHp, player.hp + 5);
  }
                  createParticles(enemy.x,enemy.y,'#fff176',30,6);
                  enemies.splice(idx,1);
                  applyScore(100*currentLevel);}
              }
            });
          }
          shakeScreen();
        }
        if(elapsed>=this.superDuration)this.endSuper();

            } else if(this.attackType==='grapple'){
        // Jimmy SUPER rework:
        // - NON si aggrappa ai nemici (niente "stop" sul bersaglio).
        // - Jimmy li attraversa (pass-through) e applica lo stesso colpo/danni quando li raggiunge.
        const chaseSpeed=this.speed*6;

        // Se siamo nel "pass-through window", continua dritto nella direzione salvata
        if(this._superGrapplePassUntil && now < this._superGrapplePassUntil){
          this.vx=this._superGrappleDirX*chaseSpeed;
          this.vy=this._superGrappleDirY*chaseSpeed;
        } else {
          this._superGrapplePassUntil=0;

          if(this.superTargets.length>0){
            const target=this.superTargets[0];
            if(!enemies.includes(target)){
              this.superTargets.shift();
            } else {
              const px=this.x+this.width/2, py=this.y+this.height/2;
              const tx=target.x+target.width/2, ty=target.y+target.height/2;
              const dx=tx-px;const dy=ty-py;
              const dist=Math.hypot(dx,dy);

              if(dist>50){
                this.vx=(dx/(dist||1))*chaseSpeed;
                this.vy=(dy/(dist||1))*chaseSpeed;
              } else {
                // hit once, then keep moving forward briefly (pass-through)
                const base=120;
                const mult=(this.type==='jimmy')?(SUPER_DAMAGE_MULT*JIMMY_SUPER_ADDITIONAL_MULT):SUPER_DAMAGE_MULT;
                const dmg=Math.round(base*mult*this.attackBuffMultiplier*(this.type==='jimmy'?2.0:1));
                const _final=applyEnemyDamage(target, dmg);
                createParticles(target.x,target.y,'#e74c3c',15,6);
                showDamageNumber(target.x,target.y, _final);
                if(target.hp<=0){
                  createParticles(target.x,target.y,'#fff176',30,6);
                  const idx=enemies.indexOf(target);
                  if(idx>-1){enemies.splice(idx,1);applyScore(100*currentLevel);}
                }

                // store direction and move through (no interaction/stop)
                let nx=dx/(dist||1), ny=dy/(dist||1);
                if(!isFinite(nx) || !isFinite(ny)){ nx=this.facingRight?1:-1; ny=0; }
                this._superGrappleDirX=nx; this._superGrappleDirY=ny;
                this._superGrapplePassUntil=now+160;

                // next target
                this.superTargets.shift();
                this._superPhase=Date.now();
              }
            }
          } else {
            if(now-this.superStartTime>=Math.min(this.superDuration,1200))this.endSuper();
          }
        }
      } else if(this.attackType==='sword'){
        if(elapsed>=0&&elapsed<this.superDuration){
          if(!this._lastSwordTick||now-this._lastSwordTick>=180){
            this._lastSwordTick=now;
            enemies.forEach((enemy,idx)=>{
              const dist=Math.hypot(enemy.x-this.x,enemy.y-this.y);
              if(dist<JEFF_SUPER_RADIUS){
                const tickDmg=Math.round(28*SUPER_DAMAGE_MULT);
                const _dmg=tickDmg; const _final=applyEnemyDamage(enemy,_dmg);
                createParticles(enemy.x,enemy.y,'#9b59b6',8,4);
                showDamageNumber(enemy.x,enemy.y, _final);
                if(enemy.hp<=0){
  if(player && player.type==='jeff' && player.evolved){
    player.hp = Math.min(player.maxHp, player.hp + 5);
  }
                  createParticles(enemy.x,enemy.y,'#fff176',30,6);
                  enemies.splice(idx,1);
                  applyScore(100*currentLevel);}
              }
            });
          }
        } else this.endSuper();

      
      } else if(this.attackType==='salsySword'){
        if(elapsed>=this.superDuration) this.endSuper();

      } else if(this.attackType==='kouvagia'){
        if(elapsed>=this.superDuration) this.endSuper();
} else if(this.attackType==='hybrid'){

        if(now - this.superStartTime >= this.superDuration){
          this.endSuper();
        }
      } else if(this.attackType==='tempostormLaser'){
        // Tempostorm SUPER is applied instantly in superAttack(); keep VFX only for superDuration.
        if(elapsed>=this.superDuration){
          this.endSuper();
        }
      } else if(this.attackType==='hecateBow'){
        // H√®cate SUPER: heal happens instantly; keep short FX then end.
        if(elapsed>=this.superDuration){
          this.endSuper();
        }
      } else if(this.attackType==='magic'){
        // Freeze is applied instantly in superAttack(); keep VFX only for superDuration.
        if(elapsed>=this.superDuration){
          this.endSuper();
        }
      }
    }

    // integrate velocity
    this.x+=this.vx;this.y+=this.vy;
    if(!keys['a']&&!keys['d']&&!this.isDashing&&!this.isGrappling)this.vx*=0.86;
    if(!keys['w']&&!keys['s']&&!this.isGrappling)this.vy*=0.86;

    const margin=10;
    if(this.x<margin)this.x=margin;
    if(this.x+this.width>canvas.width-margin)this.x=canvas.width-this.width-margin;
    if(this.y<margin)this.y=margin;
    if(this.y+this.height>canvas.height-50-margin)this.y=canvas.height-50-this.height-margin;

    if(this.dashCooldown>0)this.dashCooldown--;

    if(this.attacking&&Date.now()-this.attackTime>300){
      this.attacking=false;
      if(this.type==='jimmy'&&this.shieldActive&&!this.isDoingSuper){
        this.shieldActive=false;
      }
    }
  }

  dodge(){
    if(this.dashCooldown<=0&&!this.isDoingSuper){
      this.isDashing=true;this.dashTime=Date.now();

      // Kouvagia passive: dodge deals 10 damage to nearby enemies
      if(this.type==='kouvagia'){
        for(let i=enemies.length-1;i>=0;i--){
          const e=enemies[i];
          const dist=Math.hypot((e.x+e.width/2)-(this.x+this.width/2),(e.y+e.height/2)-(this.y+this.height/2));
          if(dist<95){
            const _dmg=10; const _final=applyEnemyDamage(e,_dmg);
            createParticles(e.x,e.y,'#ff7675',8,4);
            showDamageNumber(e.x,e.y, _final);
            if(e.hp<=0){
              createParticles(e.x,e.y,'#fff176',30,6);
              enemies.splice(i,1);
              applyScore(100*currentLevel);
                if(this.type==='kouvagia'){this.hp=Math.min(this.maxHP,this.hp+3);createParticles(this.x,this.y,'#2ecc71',6,3);}
            }
          }
        }
      }
      if(this.type==='jimmy' || this.type==='voltryx' || this.type==='kouvagia' || this.type==='hecate'){
        this._dashSpeedMult=4;
        this._dashDuration=300;
        this.dashCooldown=90;
      } else {
        this._dashSpeedMult=3;
        this._dashDuration=200;
        this.dashCooldown=90;
      }
    }
  }

  attack(){
    const now=Date.now();
    if(now-this.lastAttack<this.cooldown||this.isDoingSuper)return false;
    // Jimmy EVO passive: if unlocked, the next grapple gets -20% cooldown (only for that next grapple)
    if(this.type==='jimmy' && this.evolved && this.attackType==='grapple' && this._jimmyNextGrappleCdMult && this._jimmyNextGrappleCdMult<1){
      const mult=this._jimmyNextGrappleCdMult;
      this.lastAttack = now - Math.round(this.cooldown*(1-mult));
      this._jimmyNextGrappleCdMult=1;
    } else {
      this.lastAttack=now;
    }
    this.attacking=true;this.attackTime=now;

    if(this.type==='jimmy'&&!this.shieldBroken){this.shieldActive=true;}

    const assistTarget=this.findClosestEnemy();
    if(assistTarget){
      const dx=(assistTarget.x+assistTarget.width/2)-(this.x+this.width/2);
      this.facingRight=dx>=0;
      const dist=Math.hypot(dx,(assistTarget.y+assistTarget.height/2)-(this.y+this.height/2));
      if(dist>10){
        const nx=dx/dist;
        const ny=((assistTarget.y+assistTarget.height/2)-(this.y+this.height/2))/dist;
        this.vx+=nx*this.speed*this.aimAssistStrength;
        this.vy+=ny*this.speed*this.aimAssistStrength;
      }
    }

    if(this.attackType==='punch'){
      if(this.type==='rooney'){
        const multipliers=[1,1.15,1.25];
        for(let i=0;i<3;i++){
          setTimeout(((idx)=>{
            return ()=>{
              let closestEnemy=null;let closestDist=this.range+40;
              enemies.forEach(enemy=>{
                const dx=enemy.x-this.x;const dy=enemy.y-this.y;
                const dist=Math.hypot(dx,dy);
                if(dist<closestDist&&Math.abs(dy)<220){closestDist=dist;closestEnemy=enemy}
              });
              if(closestEnemy){
                const baseDmg=this.damage;
                const dmg=Math.round(baseDmg * multipliers[idx] * this.attackBuffMultiplier);
                const _dmg=dmg; const _final=applyEnemyDamage(closestEnemy,_dmg);
                createParticles(closestEnemy.x,closestEnemy.y,'#e67e22',12,5);
                showDamageNumber(closestEnemy.x,closestEnemy.y, _final);
                if(closestEnemy.hp<=0){
                  createParticles(closestEnemy.x,closestEnemy.y,'#fff176',30,6);
                  const idxEnemy=enemies.indexOf(closestEnemy);
                  if(idxEnemy>-1){enemies.splice(idxEnemy,1);applyScore(100*currentLevel);}
                }
              }
            };
          })(i), i*120);
        }
      } else {
        let closestEnemy=null;let closestDist=this.range;
        enemies.forEach(enemy=>{
          const dx=enemy.x-this.x;const dy=enemy.y-this.y;
          const dist=Math.hypot(dx,dy);
          if(dist<closestDist&&Math.abs(dy)<220){closestDist=dist;closestEnemy=enemy}
        });
        if(closestEnemy){
          const dmg=Math.round(this.damage*this.attackBuffMultiplier);
          const _dmg=dmg; const _final=applyEnemyDamage(closestEnemy,_dmg);
          createParticles(closestEnemy.x,closestEnemy.y,'#e67e22',12,5);
          showDamageNumber(closestEnemy.x,closestEnemy.y, _final);
          if(closestEnemy.hp<=0){
            createParticles(closestEnemy.x,closestEnemy.y,'#fff176',30,6);
            enemies.splice(enemies.indexOf(closestEnemy),1);
            applyScore(100*currentLevel);
          }
        } else if(assistTarget){
          const distA=Math.hypot((assistTarget.x-this.x),(assistTarget.y-this.y));
          if(distA<this.range+120){
            const dmg=Math.round(this.damage*0.9*this.attackBuffMultiplier);
            const _dmg=dmg; const _final=applyEnemyDamage(assistTarget,_dmg);
            createParticles(assistTarget.x,assistTarget.y,'#e67e22',12,5);
            showDamageNumber(assistTarget.x,assistTarget.y, _final);
            if(assistTarget.hp<=0){
              createParticles(assistTarget.x,assistTarget.y,'#fff176',30,6);
              enemies.splice(enemies.indexOf(assistTarget),1);
              applyScore(100*currentLevel);
            }
          }
        }
      }

    } else if(this.attackType==='grapple'){
      let closestEnemy=assistTarget;
      if(!closestEnemy){
        let closestDist=this.range;
        enemies.forEach(enemy=>{
          const dist=Math.hypot(enemy.x-this.x,enemy.y-this.y);
          if(dist<closestDist){closestDist=dist;closestEnemy=enemy}
        })
      }
      if(closestEnemy){
        this.grappleTarget=closestEnemy;this.isGrappling=true;this.grappleStartX=this.x;this.grappleStartY=this.y;this.grappleStartTime=Date.now()
      }

    } else if(this.attackType==='salsySword'){
      // Two consecutive fan slashes (25x2) at medium-close range
      const attackAngle=this.facingRight?0:Math.PI;
      const arcWidth=Math.PI*1.35;
      const doSwing = ()=>{
        enemies.forEach(enemy=>{
          const dx=enemy.x-this.x;const dy=enemy.y-this.y;const dist=Math.hypot(dx,dy);
          const angle=Math.atan2(dy,dx);
          let angleDiff=angle-attackAngle;
          while(angleDiff>Math.PI)angleDiff-=Math.PI*2;
          while(angleDiff<-Math.PI)angleDiff+=Math.PI*2;
          if(dist<this.range && Math.abs(angleDiff)<arcWidth/2+0.15){
            const base=37*this.attackBuffMultiplier;
            const dmg=applyEnemyDamage(enemy, base);
            createParticles(enemy.x,enemy.y,'#f1c40f',10,4);
            showDamageNumber(enemy.x,enemy.y,dmg);
            if(enemy.hp<=0){
  if(player && player.type==='jeff' && player.evolved){
    player.hp = Math.min(player.maxHp, player.hp + 5);
  }
              createParticles(enemy.x,enemy.y,'#fff176',30,6);
              enemies.splice(enemies.indexOf(enemy),1);
              applyScore(100*currentLevel);
            }
          }
        });
      };
      doSwing();
      setTimeout(doSwing, 120);

    } else if(this.attackType==='sword'){
      const attackAngle=this.facingRight?0:Math.PI;const arcWidth=Math.PI*1.6;
      let __jeffHitCount=0;
      enemies.forEach(enemy=>{
        const dx=enemy.x-this.x;const dy=enemy.y-this.y;const dist=Math.hypot(dx,dy);
        const angle=Math.atan2(dy,dx);
        let angleDiff=angle-attackAngle;
        while(angleDiff>Math.PI)angleDiff-=Math.PI*2;
        while(angleDiff<-Math.PI)angleDiff+=Math.PI*2;
        if(dist<this.range&&Math.abs(angleDiff)<arcWidth/2+0.2){
          const dmg=Math.round(this.damage*this.attackBuffMultiplier);
          const _dmg=dmg; const _final=applyEnemyDamage(enemy,_dmg);
          createParticles(enemy.x,enemy.y,'#9b59b6',10,4);
          showDamageNumber(enemy.x,enemy.y, _final);
          if(enemy.hp<=0){
  if(player && player.type==='jeff' && player.evolved){
    player.hp = Math.min(player.maxHp, player.hp + 5);
  }
            createParticles(enemy.x,enemy.y,'#fff176',30,6);
            enemies.splice(enemies.indexOf(enemy),1);
            applyScore(100*currentLevel);}
        }
      });
      // Jeff EVO passive: if a single attack hits 2+ enemies, heal 1% max HP
      if(this.type==='jeff' && this.evolved && __jeffHitCount>=2){
        const heal = Math.max(1, Math.round(this.maxHP*0.01));
        this.hp = Math.min(this.maxHP, this.hp + heal);
        createParticles(this.x+this.width/2,this.y+this.height/2,'#2ecc71',10,4);
      }
      if(assistTarget){
        const distAssist=Math.hypot((assistTarget.x-this.x),(assistTarget.y-this.y));
        if(distAssist<this.range+60){
          const dmg=Math.round(this.damage*0.7*this.attackBuffMultiplier);
          const _dmg=dmg; const _final=applyEnemyDamage(assistTarget,_dmg);
          createParticles(assistTarget.x,assistTarget.y,'#9b59b6',10,4);
          showDamageNumber(assistTarget.x,assistTarget.y, _final);
          if(assistTarget.hp<=0){
            createParticles(assistTarget.x,assistTarget.y,'#fff176',30,6);
            enemies.splice(enemies.indexOf(assistTarget),1);
            applyScore(100*currentLevel);}
        }
      }

    
    } else if(this.attackType==='kouvagia'){

      // Kouvagia: mini dash forward dealing damage during dash + small/medium AoE on stop
      this.isDashing=true;
      this.dashTime=Date.now();
      this._dashSpeedMult=5.2;
      this._dashDuration=260;
      this.dashCooldown=95;

      this._kouvagiaDashActive=true;
      this._kouvagiaDashHitCd=0;
      this._kouvagiaExplosionPending=true;

    } else if(this.attackType==='hybrid'){
      
      const target=assistTarget || this.findClosestEnemy(800);
      const dist = target ? Math.hypot((target.x+target.width/2)-(this.x+this.width/2),(target.y+target.height/2)-(this.y+this.height/2)) : Infinity;

      if(dist>150 && target){
        // Ranged: small energy sphere with small AoE
        const dx=(target.x+target.width/2)-(this.x+this.width/2);
        const dy=(target.y+target.height/2)-(this.y+this.height/2);
        const len=Math.hypot(dx,dy)||1;
        const speed=9;
        const vx=(dx/len)*speed;
        const vy=(dy/len)*speed;
        const baseAoeDmg = Math.round(45* this.attackBuffMultiplier);
        spawnProjectile({
          x:this.x+this.width/2, y:this.y+this.height/2,
          vx, vy, speed,
          damage:baseAoeDmg, ttl:2000, color:'#ffb74d',
          radius:9, friendly:true, aoeRadius:110, aoeFullDamage:true, homing:false,
          explodeOnExpire:true
        });
        createParticles(this.x+this.width/2,this.y+this.height/2,'#ffa726',8,3);
      } else {
        // Close: two quick punches, slightly less strong than Rooney
        const perPunchBase=50; // Rooney base ~60; Voltryx slightly less
        const punch = ()=>{
          let closest=null;let best=160;
          enemies.forEach(e=>{
            const d=Math.hypot(e.x-this.x,e.y-this.y);
            if(d<best && Math.abs(e.y-this.y)<220){best=d;closest=e}
          });
          if(closest){
            const dmg=Math.round(perPunchBase*this.attackBuffMultiplier);
            const _dmg=dmg; const _final=applyEnemyDamage(closest,_dmg);
            createParticles(closest.x,closest.y,'#e67e22',12,5);
            showDamageNumber(closest.x,closest.y, _final);
            if(closest.hp<=0){
              createParticles(closest.x,closest.y,'#fff176',30,6);
              enemies.splice(enemies.indexOf(closest),1);
              applyScore(100*currentLevel);
            }
          }
        };
        punch();
        setTimeout(punch, 120);
      }
    }

else if(this.attackType==='hecateBow'){
  // H√®cate: long range arrow that splits into 3 arrows hitting other enemies
  const target = assistTarget || this.findClosestEnemy(this.range);
  const sx=this.x+this.width/2;
  const sy=this.y+this.height/2;

  let dx,dy;
  if(target){
    dx=(target.x+target.width/2)-sx;
    dy=(target.y+target.height/2)-sy;
  } else {
    dx=this.facingRight?1:-1;
    dy=0;
  }
  const len=Math.hypot(dx,dy)||1;
  const speed=13;
  const vx=(dx/len)*speed;
  const vy=(dy/len)*speed;

  const mainDmg = Math.round(this.damage*1.25*this.attackBuffMultiplier);
  const splitDmg = Math.round(mainDmg * 0.5); // frecce minori: met√† del danno della freccia principale

  spawnProjectile({
    x:sx,y:sy,
    vx,vy,speed,
    damage:mainDmg,
    ttl:720,
    color:'#e0e0e0',
    radius:6,
    friendly:true,
    shape:'rect',
    w:22,
    h:5,
    angle:Math.atan2(vy,vx),
    meta:{type:'hecateMain', splitDamage: splitDmg}
  });
  createParticles(sx,sy,'#c5cae9',14,4);
}
else if(this.attackType==='tempostormLaser'){
  const assistTarget=this.findClosestEnemy(900);
  const sx=this.x+this.width/2;
  const sy=this.y+this.height/2;

  let dx,dy,len;
  if(assistTarget){
    dx=(assistTarget.x+assistTarget.width/2)-sx;
    dy=(assistTarget.y+assistTarget.height/2)-sy;
  }else{
    dx=this.facingRight?1:-1; dy=0;
  }
  len=Math.hypot(dx,dy)||1;
  const ex=sx+(dx/len)*this.range;
  const ey=sy+(dy/len)*this.range;

  spawnTempBeam({
    x1:sx,y1:sy,x2:ex,y2:ey,
    width:18,ttl:260,
    damage1:Math.round(40*this.attackBuffMultiplier),
    damageStay:Math.round(30*this.attackBuffMultiplier)
  });
  createParticles(sx,sy,'#4fc3f7',14,4);
}

else if(this.attackType==='magic'){
  const damages = (characterStats.marz && characterStats.marz.tripleDamage) ? characterStats.marz.tripleDamage : [40,50,60];
  const colors = ['#ff00ff','#00e5ff','#fff176'];

  // Choose up to 3 distinct targets; if fewer, stack on available targets
  const sorted=enemies.slice().sort((a,b)=>{
    const da=Math.hypot((a.x+a.width/2)-(this.x+this.width/2),(a.y+a.height/2)-(this.y+this.height/2));
    const db=Math.hypot((b.x+b.width/2)-(this.x+this.width/2),(b.y+b.height/2)-(this.y+this.height/2));
    return da-db;
  });
  const targets = sorted.slice(0,3);
  const fallback = targets[0] || this.findClosestEnemy(this.range);

  for(let i=0;i<3;i++){
    const t = targets[i] || fallback;
    if(!t) continue;

    const sx=this.x+this.width/2;
    const sy=this.y+this.height/2;
    const tx=t.x+t.width/2;
    const ty=t.y+t.height/2;
    const dx=tx-sx, dy=ty-sy;
    const len=Math.hypot(dx,dy)||1;

    const speed=11;
    const vx=(dx/len)*speed;
    const vy=(dy/len)*speed;

    spawnProjectile({
      x:sx,y:sy,
      vx,vy,speed,
      damage:Math.round(damages[i]*this.attackBuffMultiplier),
      ttl:520,
      color:colors[i%colors.length],
      radius:7,
      friendly:true,
      aoeRadius:0,
      homing:true,
      // IMPORTANT: lock each beam to its chosen target (3 different enemies if available)
      targetRef:t
    });
    createParticles(sx,sy,colors[i%colors.length],10,4);
  }
}



    return true;
  }

  superAttack(){
    const now=Date.now();
    if(now-this.lastSuper<this.superCooldown||this.isDoingSuper)return false;
    this.lastSuper=now;this.isDoingSuper=true;this.superStartTime=now;this._HitDone=false;

    if(this.type==='jimmy'){this.invulnerable=true;this.shieldActive=true}

    if(this.attackType==='grapple'){
      const sorted=enemies.slice().sort((a,b)=>{
        const da=Math.hypot(a.x-this.x,a.y-this.y);
        const db=Math.hypot(b.x-this.x,b.y-this.y);
        return da-db
      });
      this.superTargets=sorted.slice(0,6);

      // reset pass-through state
      this._superGrapplePassUntil=0;
      this._superGrappleDirX=this.facingRight?1:-1;
      this._superGrappleDirY=0;
    }
    else if(this.attackType==='punch'){
      createParticles(this.x+this.width/2,this.y+this.height/2,'#f39c12',20,6);
    }
    else if(this.attackType==='sword'){
      createParticles(this.x+this.width/2,this.y+this.height/2,'#9b59b6',20,6);
    }

    else if(this.attackType==='salsySword'){
      // Mark up to 3 enemies; marked enemies take double damage for a while
      const sorted=enemies.slice().sort((a,b)=>{
        const da=Math.hypot((a.x+a.width/2)-(this.x+this.width/2),(a.y+a.height/2)-(this.y+this.height/2));
        const db=Math.hypot((b.x+b.width/2)-(this.x+this.width/2),(b.y+b.height/2)-(this.y+this.height/2));
        return da-db;
      });
      const targets=sorted.slice(0,3);
      const until=now+7000;
      targets.forEach(t=>{
        t.salsyMarkUntil=until;
        createParticles(t.x,t.y,'#f1c40f',22,5);
      });
      createParticles(this.x+this.width/2,this.y+this.height/2,'#f1c40f',26,6);
    }

    else if(this.attackType==='kouvagia'){

      // Kouvagia super: full heal + large knockback + tiny damage + visual FX
      this.hp=this.maxHP;
      this._kouvagiaSuperFxStart=now;
      this._kouvagiaSuperFxUntil=now+900;
      createParticles(this.x+this.width/2,this.y+this.height/2,'#55efc4',60,6);

      const R=360;
      for(let i=0;i<enemies.length;i++){
        const e=enemies[i];
        const dx=(e.x+e.width/2)-(this.x+this.width/2);
        const dy=(e.y+e.height/2)-(this.y+this.height/2);
        const dist=Math.hypot(dx,dy)||1;
        if(dist<=R){
          // tiny damage
          const dmg=3;
          const _final=applyEnemyDamage(e,dmg);
          showDamageNumber(e.x,e.y,_final);
          createParticles(e.x,e.y,'#81ecec',8,4);
          // knockback
          const push=120;
          e.x += (dx/dist)*push;
          e.y += (dy/dist)*push;
        }
      }
      shakeScreen();
    }
else if(this.attackType==='hybrid'){
     
      const dmgPerPulse = Math.round(100 * this.attackBuffMultiplier);
      spawnProjectile({
        x:this.x+this.width/2,y:this.y+this.height/2,
        vx:(this.facingRight?1:-1)*4,vy:0,speed:6,
        damage:dmgPerPulse,ttl:this.superDuration,color:'#f39c12',
        radius:14,friendly:true,aoeRadius:120,homing:true,
        isVoltryxSuper:true,pulseInterval:260,lastPulse:0
      });
      createParticles(this.x+this.width/2,this.y+this.height/2,'#f39c12',26,6);
      shakeScreen();
    }

else if(this.attackType==='tempostormLaser'){
  const cx=canvas.width/2;
  const cy=(canvas.height-50)/2;
  let stolen=0;

  enemies.forEach(e=>{
    // group to exact center
    e.x = cx - e.width/2;
    e.y = cy - e.height/2;

    const removed = Math.max(0, Math.floor(e.hp/2));
    e.hp = Math.max(0, e.hp - removed);
    stolen += removed;

    if(removed>0){
      showDamageNumber(e.x,e.y, removed);
      createParticles(e.x+e.width/2,e.y+e.height/2,'#00b0ff',18,5);
    }
  });

  if(stolen>0){
    this.hp = Math.min(this.maxHP, this.hp + stolen);
    createParticles(this.x+this.width/2,this.y+this.height/2,'#00b0ff',30,6);
  }
  createParticles(cx,cy,'#4fc3f7',60,7);
  shakeScreen();
}



    else if(this.attackType==='hecateBow'){
      // Super: heal 5 HP for each enemy currently present
      const heal = Math.max(0, enemies.length) * 5;
      if(heal>0){
        this.hp = Math.min(this.maxHP, this.hp + heal);
        createParticles(this.x+this.width/2,this.y+this.height/2,'#c5cae9',28,6);
      } else {
        createParticles(this.x+this.width/2,this.y+this.height/2,'#c5cae9',16,5);
      }

      // NEW: spawn 3 friendly wolves near H√®cate (max 6 on field)
      spawnWolvesNearPlayer(this, 3);

      shakeScreen();
    }
    else if(this.attackType==='magic'){
      // Super: create a huge colorful magic zone at map center.
      // - Expands slowly for 10s
      // - Deals heavy periodic damage to enemies inside
      // - If Marz stays inside, he gains +50% movement speed
      const cx=canvas.width/2;
      const cy=(canvas.height-50)/2;

      magicZone = {
        x:cx,
        y:cy,
        startsAt:now,
        endsAt:now+10000,
        durationMs:10000,
        startRadius:90,
        maxRadius:560,
        radius:90,
        tickMs:180,
        damagePerTick:Math.round(16*this.attackBuffMultiplier),
        lastTick:0,
        colors:['#ff00ff','#00e5ff','#fff176','#7c4dff','#18ffff'],
        colorIdx:0
      };

      // burst FX
      createParticles(cx,cy,'#ff00ff',50,7);
      createParticles(cx,cy,'#00e5ff',50,7);
      createParticles(cx,cy,'#fff176',50,7);
      shakeScreen();
    }


    return true;
  }

  endSuper(){
    this.isDoingSuper=false;this._superHitDone=false;this._lastSwordTick=null;
    this.superTargets=[];this.grappleTarget=null;this.isGrappling=false;
    this.vx*=0.5;this.vy*=0.5;this.invulnerable=false;
    if(this.type==='jimmy')this.shieldActive=false
  }

  takeDamage(damage){
    if(this.invulnerable||(this.pickupShieldUntil&&Date.now()<this.pickupShieldUntil))return;
    if(this.shieldActive&&!this.shieldBroken){
      this.shieldDurability-=1;
      createParticles(this.x,this.y,'#3498db',12,5);
      if(this.shieldDurability<=0){this.shieldBroken=true;this.shieldBrokenTime=Date.now();this.shieldActive=false}
      return;
    }
    this.hp-=damage;
    if(!isFinite(this.hp)) this.hp = 0;
    this.hp = Math.max(0, this.hp);
    this.damageTaken++;
    this.combo=0;
    applyScore(-50);
    createParticles(this.x,this.y,'#c0392b',12,5);
    shakeScreen();
    if(this.hp<=0 && gameState==='playing') endGame(false);
  }

  draw(){
    const baseImg = images[this.type];
    const evoImg = (this.evolved && imagesEvo && imagesEvo[this.type]) ? imagesEvo[this.type] : null;
    const activeImg = (evoImg && evoImg.complete) ? evoImg : baseImg;

    if(activeImg && activeImg.complete){
      ctx.save();
      // evolution visual (brief glow + scale)
      const evoT = (this._evoFxUntil && Date.now() < this._evoFxUntil) ? (1 - ((this._evoFxUntil - Date.now())/650)) : 1;
      const evoScale = (this._evoFxUntil && Date.now() < this._evoFxUntil) ? (1 + 0.18*(1-evoT)) : 1;
      const evoAlpha = (this._evoFxUntil && Date.now() < this._evoFxUntil) ? (0.75 + 0.25*Math.sin(Date.now()/45)) : 1;
      ctx.globalAlpha = evoAlpha;
      const cx=this.x+this.width/2, cy=this.y+this.height/2;
      ctx.translate(cx,cy);
      ctx.scale(evoScale,evoScale);
      ctx.translate(-cx,-cy);
      if(!this.facingRight){
        ctx.scale(-1,1);
        ctx.drawImage(activeImg,-this.x-this.width,this.y,this.width,this.height)
      }else ctx.drawImage(activeImg,this.x,this.y,this.width,this.height);
      ctx.restore()
    } else {
      ctx.fillStyle='#3498db';ctx.fillRect(this.x,this.y,this.width,this.height)
    }


    // Salsy mark indicator
    if(this.salsyMarkUntil && Date.now() < this.salsyMarkUntil){
      ctx.save();
      ctx.font='22px "Press Start 2P", monospace';
      ctx.textAlign='center';
      ctx.fillStyle='#f1c40f';
      ctx.fillText('‚öúÔ∏è', this.x+this.width/2, this.y-10);
      ctx.restore();
    }

    if(this.shieldActive&&!this.shieldBroken){
      ctx.beginPath();ctx.strokeStyle='rgba(127,219,255,0.85)';ctx.lineWidth=6;
      ctx.arc(this.x+this.width/2,this.y+this.height/2,Math.max(this.width,this.height),0,Math.PI*2);ctx.stroke();
      ctx.fillStyle='#fff';ctx.fillRect(this.x,this.y-16,this.width,6);
      ctx.fillStyle='#7fdbff';ctx.fillRect(this.x,this.y-16,this.width*(this.shieldDurability/this.shieldMaxDurability),6)
    }

    if(this.attacking&&!this.isGrappling){
      ctx.save();
      if(this.attackType==='punch'){
        ctx.strokeStyle='rgba(230,126,34,0.7)';ctx.lineWidth=8;ctx.beginPath();
        const punchX=this.x+this.width/2+(this.facingRight?this.range:-this.range);
        ctx.moveTo(this.x+this.width/2,this.y+this.height/2);
        ctx.lineTo(punchX,this.y+this.height/2);ctx.stroke()
      }else if(this.attackType==='sword'){
        ctx.strokeStyle='rgba(155,89,182,0.6)';ctx.lineWidth=5;
        const angle=this.facingRight?0:Math.PI;const arcWidth=Math.PI*1.2;
        ctx.beginPath();ctx.arc(this.x+this.width/2,this.y+this.height/2,this.range,angle-arcWidth/2,angle+arcWidth/2);ctx.stroke()
      }else if(this.attackType==='salsySword'){
        // Visual telegraph: Salsy fan slash area
        const angle=this.facingRight?0:Math.PI;const arcWidth=Math.PI*1.35;
        ctx.fillStyle='rgba(241,196,15,0.12)';
        ctx.strokeStyle='rgba(241,196,15,0.75)';
        ctx.lineWidth=6;
        ctx.beginPath();
        ctx.moveTo(this.x+this.width/2,this.y+this.height/2);
        ctx.arc(this.x+this.width/2,this.y+this.height/2,this.range,angle-arcWidth/2,angle+arcWidth/2);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
      }else if(this.attackType==='hybrid'){
        ctx.strokeStyle='rgba(243,156,18,0.6)';ctx.lineWidth=6;
        ctx.beginPath();
        ctx.arc(this.x+this.width/2,this.y+this.height/2,110,0,Math.PI*2);
        ctx.stroke();
      }
      else if(this.attackType==='tempostormLaser'){
        const sx=this.x+this.width/2, sy=this.y+this.height/2;
        const tx = sx + (this.facingRight?1:-1)*this.range;
        const ty = sy;
        ctx.strokeStyle='rgba(79,195,247,0.75)';ctx.lineWidth=7;
        ctx.beginPath();ctx.moveTo(sx,sy);ctx.lineTo(tx,ty);ctx.stroke();
      }
      ctx.restore()
    }

    if(this.isDoingSuper){
      if(this.attackType==='punch'){
        ctx.save();ctx.strokeStyle='rgba(243,156,18,0.45)';ctx.lineWidth=12;ctx.beginPath();
        const arcRadius=350;ctx.arc(this.x+this.width/2,this.y+this.height/2,arcRadius,0,Math.PI*2);ctx.stroke();ctx.restore()
      }
      else if(this.attackType==='sword'){
        ctx.save();ctx.strokeStyle='rgba(155,89,182,0.45)';ctx.lineWidth=10;ctx.beginPath();
        const swordRadius=JEFF_SUPER_RADIUS;ctx.arc(this.x+this.width/2,this.y+this.height/2,swordRadius,0,Math.PI*2);ctx.stroke();ctx.restore()
      }
      else if(this.attackType==='grapple'){
        ctx.save();ctx.strokeStyle='rgba(231,76,60,0.45)';ctx.lineWidth=6;
        this.superTargets.forEach(t=>{ctx.beginPath();ctx.arc(t.x+t.width/2,t.y+t.height/2,40,0,Math.PI*2);ctx.stroke()});
        ctx.restore()
      }
      else if(this.attackType==='hybrid'){
        // aura while super is active
        ctx.save();ctx.strokeStyle='rgba(243,156,18,0.35)';ctx.lineWidth=8;
        ctx.beginPath();ctx.arc(this.x+this.width/2,this.y+this.height/2,140,0,Math.PI*2);ctx.stroke();ctx.restore()
      }
            else if(this.attackType==='tempostormLaser'){
        ctx.save();
        ctx.strokeStyle='rgba(0,176,255,0.45)';
        ctx.lineWidth=10;
        ctx.beginPath();
        ctx.arc(canvas.width/2,(canvas.height-50)/2,180,0,Math.PI*2);
        ctx.stroke();
        ctx.restore();
      }
else if(this.attackType==='salsySword'){
        // Show 1-3 target reticles + launch lines during Salsy super
        ctx.save();
        ctx.strokeStyle='rgba(241,196,15,0.75)';
        ctx.fillStyle='rgba(241,196,15,0.10)';
        ctx.lineWidth=5;
        const px=this.x+this.width/2, py=this.y+this.height/2;
        const list=(this.superTargets||[]).slice(0,3);
        list.forEach((t,i)=>{
          const tx=t.x+t.width/2, ty=t.y+t.height/2;
          // dashed aim line
          ctx.setLineDash([10,6]);
          ctx.beginPath();ctx.moveTo(px,py);ctx.lineTo(tx,ty);ctx.stroke();
          ctx.setLineDash([]);
          // reticle
          ctx.beginPath();ctx.arc(tx,ty,26,0,Math.PI*2);ctx.stroke();
          ctx.beginPath();ctx.arc(tx,ty,10,0,Math.PI*2);ctx.fill();ctx.stroke();
        });
        ctx.restore();
      }
    }

    if(this.isGrappling&&this.grappleTarget){
      ctx.strokeStyle='rgba(231,76,60,0.8)';ctx.lineWidth=3;ctx.setLineDash([10,5]);
      ctx.beginPath();ctx.moveTo(this.x+this.width/2,this.y+this.height/2);
      ctx.lineTo(this.grappleTarget.x+this.grappleTarget.width/2,this.grappleTarget.y+this.grappleTarget.height/2);
      ctx.stroke();ctx.setLineDash([])
    }

    if(this.isJetpacking){
      ctx.save();
      ctx.fillStyle='rgba(255,215,0,0.9)';
      ctx.beginPath();
      ctx.ellipse(this.x+this.width/2,this.y+this.height+12,18,8,0,0,Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    // === KOUVAGIA: visualizzazione aree attacco + effetto super ===
    if(this.type==='kouvagia'){
      // Area danno durante dash-attacco
      if(this.isDashing && this._kouvagiaDashActive){
        ctx.save();
        ctx.strokeStyle='rgba(232,67,147,0.55)';
        ctx.lineWidth=6;
        ctx.beginPath();
        ctx.arc(this.x+this.width/2,this.y+this.height/2,110,0,Math.PI*2);
        ctx.stroke();
        ctx.restore();
      }

      // Area esplosione finale (breve telegraph)
      if(this._kouvagiaExplosionPending && this.isDashing){
        ctx.save();
        ctx.strokeStyle='rgba(253,121,168,0.45)';
        ctx.lineWidth=6;
        ctx.beginPath();
        ctx.arc(this.x+this.width/2,this.y+this.height/2,165,0,Math.PI*2);
        ctx.stroke();
        ctx.restore();
      }

      // Effetto super: onda espansiva + flash
      const nowFx=Date.now();
      if(this._kouvagiaSuperFxUntil && nowFx < this._kouvagiaSuperFxUntil){
        const t=(nowFx-(this._kouvagiaSuperFxStart||nowFx)) / (this._kouvagiaSuperFxUntil-(this._kouvagiaSuperFxStart||nowFx)+1);
        const r=60 + t*360;
        ctx.save();
        ctx.strokeStyle='rgba(85,239,196,'+(0.9 - t*0.8)+')';
        ctx.lineWidth=12;
        ctx.beginPath();
        ctx.arc(this.x+this.width/2,this.y+this.height/2,r,0,Math.PI*2);
        ctx.stroke();
        // flash leggero
        ctx.fillStyle='rgba(85,239,196,'+(0.12*(1-t))+')';
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.restore();
      }
    }

  }
}

class Enemy{
  constructor(type,level){
    const cfg=levelConfigs[Math.max(0,Math.min(levelConfigs.length-1,level-1))];
    const mult=1+0.15*level;
    this.type=type;
    this.x=Math.random()*(canvas.width-100)+50;
    this.y=Math.random()*(canvas.height-150)+50;
    this.width=Math.round(56*1.2);
    this.height=Math.round(56*1.2);
    this.vx=(Math.random()-0.5)*cfg.enemySpeed*mult;
    this.vy=(Math.random()-0.5)*cfg.enemySpeed*mult;
    this.maxHP=Math.round(cfg.enemyHP*(1+0.25*level));
    this.hp=this.maxHP;
    const baseDamage=Math.round(cfg.enemyDamage*(1+0.10*level));
    this.damage=(level>=7)?Math.round(baseDamage*0.8):baseDamage;
    this.speed=cfg.enemySpeed*mult;
    if(level===8)this.speed*=0.925;
    this.lastAttack=0;this.attackCooldown=2000;this.spawnFreezeUntil=Date.now()+500;
    // Special enemies
    if(this.type==='veleno'){
      this.attackCooldown=1400;
      this.poisonDuration=6000;
      this.poisonTickDamage=2;
    }
    if(this.type==='oneyes'){
      this.attackCooldown=1600;
      this.keepAway=300;
      this.preferRange=520;
    }
    if(this.type==='boss4'){
      this.width=Math.round(225*1.2);
      this.height=Math.round(230*1.2);
      this.attackCooldown=950;
      this.beamCooldown=12000;
      this.lastBeam=Date.now()-this.beamCooldown;
      this.isChargingBeam=false;
    }

  }
  update(player){
    if(Date.now()<this.spawnFreezeUntil)return;
    player = getPreferredTarget(this, player);
    const now=Date.now();

    const cx=this.x+this.width/2;
    const cy=this.y+this.height/2;
    const px=player.x+player.width/2;
    const py=player.y+player.height/2;

    let dx=px-cx;
    let dy=py-cy;
    let dist=Math.hypot(dx,dy)||1;

    // Default: chase
    let nx=dx/dist;
    let ny=dy/dist;

    // OneEyes: keep distance + shoot lasers
    if(this.type==='oneyes'){
      // keep away if too close
      if(dist < (this.keepAway||300)){
        nx = -nx; ny = -ny;
      } else if(dist > (this.preferRange||520)){
        // slightly approach if too far
        // nx,ny already towards player
      } else {
        // strafe / small drift
        const t = nx; nx = -ny*0.7; ny = t*0.7;
      }

      this.vx = nx*this.speed;
      this.vy = ny*this.speed;

      // shoot laser (1s duration), with higher cooldown
      if(dist>220 && (now-this.lastAttack)>this.attackCooldown){
        const angle=Math.atan2(dy,dx);
        spawnLaser({
          x:cx, y:cy,
          angle,
          length:650,
          width:18,
          ttl:1000,
          damage:15,
          kind:'oneyes',
          chargeMs:0
        });
        createParticles(cx,cy,'#74b9ff',16,4);
        this.lastAttack=now;
      }
    }

    // Boss4: slow melee + photon beam every 12s
    else if(this.type==='boss4'){
      // During charge, slow down a lot
      if(this.isChargingBeam){
        this.vx *= 0.8;
        this.vy *= 0.8;
      } else {
        // chase slowly
        this.vx = nx*this.speed*0.92;
        this.vy = ny*this.speed*0.92;
      }

      // melee hit
      if(dist<70 && (now-this.lastAttack)>this.attackCooldown && !player.isDashing){
        player.takeDamage(this.damage);
        this.lastAttack=now;
        createParticles(player.x,player.y,'#e17055',14,4);
      }

      // photon beam
      if((now-this.lastBeam) >= (this.beamCooldown||12000) && !this.isChargingBeam){
        this.isChargingBeam=true;
        this.lastBeam=now;
        const angle=Math.atan2(dy,dx);
        // charge + beam
        spawnLaser({
          x:cx, y:cy,
          angle,
          length:760,
          width:75,
          ttl:1000,
          damage:70,
          kind:'photon',
          chargeMs:500
        });
        // visual charge
        createParticles(cx,cy,'#f1c40f',40,6);
        shakeScreen();
        setTimeout(()=>{ this.isChargingBeam=false; }, 900);
      }
    }

    // Veleno: melee + non-stack poison
    else {
      this.vx = nx*this.speed;
      this.vy = ny*this.speed;

      // melee attack
      if(dist<60 && (now-this.lastAttack)>this.attackCooldown && !player.isDashing){
        if(this.type==='veleno'){
          player.takeDamage(15);
          // apply poison only if not already poisoned (non-stackable)
          if(!player.poisonUntil || now >= player.poisonUntil){
            player.poisonUntil = now + (this.poisonDuration||6000);
            player.poisonTickLast = now;
            player.poisonTickDamage = this.poisonTickDamage||2;
            createParticles(player.x,player.y,'#00b894',26,4);
          } else {
            // hit without re-applying poison
            createParticles(player.x,player.y,'#00b894',10,3);
          }
        } else {
          player.takeDamage(this.damage);
        }
        this.lastAttack=now;
      }
    }

    this.x+=this.vx;this.y+=this.vy;
    if(this.x<0)this.x=0;if(this.x+this.width>canvas.width)this.x=canvas.width-this.width;
    if(this.y<0)this.y=0;if(this.y+this.height>canvas.height-50)this.y=canvas.height-50-this.height;
  }
draw(){
    const imgKey = (this.type==='boss' || this.type==='boss1') ? 'boss1' : this.type;
    const img = enemyImages[imgKey];
    if(img && img.complete){
      ctx.drawImage(img,this.x,this.y,this.width,this.height);
    } else {
      const colors={slime:'#2ecc71',drone:'#95a5a6',mech:'#e67e22',shadow:'#9b59b6',boss:'#e74c3c',shooter:'#95a5a6',attacker:'#e67e22',boss2:'#e74c3c',boss3:'#e74c3c'};
      ctx.fillStyle=colors[this.type]||'#e74c3c';
      ctx.fillRect(this.x,this.y,this.width,this.height);
    }
    const hpPercent=this.hp/this.maxHP;
    ctx.fillStyle='#333';ctx.fillRect(this.x,this.y-10,this.width,5);
    ctx.fillStyle=hpPercent>0.5?'#2ecc71':hpPercent>0.25?'#f39c12':'#e74c3c';
    ctx.fillRect(this.x,this.y-10,this.width*hpPercent,5);
  }
}

class ShooterEnemy extends Enemy{
  constructor(type,level){super(type,level);this.shootCooldown=Math.max(600,1800-level*40);this.lastShoot=0;this.bulletSpeed=5+level*0.15}
  update(player){
    if(Date.now()<this.spawnFreezeUntil)return;
    player = getPreferredTarget(this, player);
    const dx=(player.x+player.width/2)-(this.x+this.width/2);
    const dy=(player.y+player.height/2)-(this.y+this.height/2);
    const dist=Math.hypot(dx,dy);
    if(dist<220){const nx=dx/(dist||1);const ny=dy/(dist||1);this.vx=-nx*this.speed;this.vy=-ny*this.speed}
    else if(dist>360){const nx=dx/(dist||1);const ny=dy/(dist||1);this.vx=nx*this.speed;this.vy=ny*this.speed}
    else{this.vx*=0.9;this.vy*=0.9}
    this.x+=this.vx;this.y+=this.vy;
    if(this.x<0)this.x=0;if(this.x+this.width>canvas.width)this.x=canvas.width-this.width;
    if(this.y<0)this.y=0;if(this.y+this.height>canvas.height-50)this.y=canvas.height-50-this.height;
    if(Date.now()-this.lastShoot>this.shootCooldown){
      this.lastShoot=Date.now();
      const len=Math.hypot(dx,dy)||1;
      const vx=(dx/len)*this.bulletSpeed;const vy=(dy/len)*this.bulletSpeed;
      spawnProjectile({
        x:this.x+this.width/2,y:this.y+this.height/2,
        vx,vy,damage:Math.max(1,Math.round(this.damage*0.6)),ttl:4000,
        color:'#ffd54f',radius:6,friendly:false
      })
    }
  }
  draw(){
    const img = enemyImages['shooter'];
    if(img && img.complete) ctx.drawImage(img,this.x,this.y,this.width,this.height);
    else super.draw();
    const hpPercent=this.hp/this.maxHP;
    ctx.fillStyle='#333';ctx.fillRect(this.x,this.y-10,this.width,5);
    ctx.fillStyle=hpPercent>0.5?'#2ecc71':hpPercent>0.25?'#f39c12':'#e74c3c';
    ctx.fillRect(this.x,this.y-10,this.width*hpPercent,5);
  }
}


class ArcherEnemy extends Enemy{
  constructor(type,level){
    super(type,level);
    this.shootCooldown=Math.max(650, 1250 - level*18);
    this.lastShoot=0;
    this.arrowSpeed=9.2 + level*0.10;
    this.keepMin=520; // very far
    this.keepMax=700;
  }
  update(player){
    if(Date.now()<this.spawnFreezeUntil)return;
    player = getPreferredTarget(this, player);
    const now=Date.now();
    const dx=(player.x+player.width/2)-(this.x+this.width/2);
    const dy=(player.y+player.height/2)-(this.y+this.height/2);
    const dist=Math.hypot(dx,dy)||1;

    // Keep far distance
    if(dist < this.keepMin){
      const nx=dx/dist, ny=dy/dist;
      this.vx = -nx*this.speed*1.05;
      this.vy = -ny*this.speed*1.05;
    } else if(dist > this.keepMax){
      const nx=dx/dist, ny=dy/dist;
      this.vx = nx*this.speed*0.95;
      this.vy = ny*this.speed*0.95;
    } else {
      this.vx*=0.90; this.vy*=0.90;
    }

    this.x+=this.vx; this.y+=this.vy;
    if(this.x<0)this.x=0;if(this.x+this.width>canvas.width)this.x=canvas.width-this.width;
    if(this.y<0)this.y=0;if(this.y+this.height>canvas.height-50)this.y=canvas.height-50-this.height;

    if(now-this.lastShoot>this.shootCooldown){
      this.lastShoot=now;
      const nx=dx/dist, ny=dy/dist;
      const vx=nx*this.arrowSpeed;
      const vy=ny*this.arrowSpeed;
      spawnProjectile({
        x:this.x+this.width/2,
        y:this.y+this.height/2,
        vx, vy,
        damage:Math.max(8, Math.round(this.damage*0.85)),
        ttl:3200,
        color:'#e0e0e0',
        radius:4,
        shape:'rect',
        w:18,
        h:4,
        angle:Math.atan2(vy,vx),
        onHitPlayer:(pl)=>{ if(pl && typeof pl.applySlow==='function') pl.applySlow(0.10, 2500); }
      });
    }
  }
  draw(){
    const img = enemyImages['archer'];
    if(img && img.complete) ctx.drawImage(img,this.x,this.y,this.width,this.height);
    else super.draw();
    const hpPercent=this.hp/this.maxHP;
    ctx.fillStyle='#333';ctx.fillRect(this.x,this.y-10,this.width,5);
    ctx.fillStyle=hpPercent>0.5?'#2ecc71':hpPercent>0.25?'#f39c12':'#e74c3c';
    ctx.fillRect(this.x,this.y-10,this.width*hpPercent,5);
  }
}

class GlacialEnemy extends Enemy{
  constructor(type,level){
    super(type,level);
    this.attackCooldown=Math.max(2100, 3400 - level*35);
    this.lastAttack=0;
    this.coneDuration=2000;
    this.coneRange=430;
    this.coneAngle=Math.PI/6; // 30¬∞ total
    this.coneActiveUntil=0;
    this.coneDir=0;
    this._coneInsideMs=0;
    this._coneLastCheck=0;
    this._coneLastTick=0;
    this._lastRegenAt=0;
    this.keepMin=280;
    this.keepMax=440;
  }
  update(player){
    if(Date.now()<this.spawnFreezeUntil)return;
    player = getPreferredTarget(this, player);
    const now=Date.now();

    // Regen: if not hit for 5s, heal 15 (can repeat every 5s)
    const lastHit=this._lastHitAt||0;
    if(now-lastHit>=5000 && now-(this._lastRegenAt||0)>=5000 && this.hp<this.maxHP){
      this.hp=Math.min(this.maxHP, this.hp+15);
      this._lastRegenAt=now;
      createParticles(this.x+this.width/2,this.y+this.height/2,'#74b9ff',12,4);
    }

    const dx=(player.x+player.width/2)-(this.x+this.width/2);
    const dy=(player.y+player.height/2)-(this.y+this.height/2);
    const dist=Math.hypot(dx,dy)||1;

    // Keep mid distance
    if(dist < this.keepMin){
      const nx=dx/dist, ny=dy/dist;
      this.vx = -nx*this.speed*1.08;
      this.vy = -ny*this.speed*1.08;
    } else if(dist > this.keepMax){
      const nx=dx/dist, ny=dy/dist;
      this.vx = nx*this.speed*0.92;
      this.vy = ny*this.speed*0.92;
    } else {
      this.vx*=0.92; this.vy*=0.92;
    }

    this.x+=this.vx; this.y+=this.vy;
    if(this.x<0)this.x=0;if(this.x+this.width>canvas.width)this.x=canvas.width-this.width;
    if(this.y<0)this.y=0;if(this.y+this.height>canvas.height-50)this.y=canvas.height-50-this.height;

    // Start cone attack
    if(now-this.lastAttack>this.attackCooldown){
      this.lastAttack=now;
      this.coneActiveUntil=now+this.coneDuration;
      this.coneDir=Math.atan2(dy,dx);
      this._coneInsideMs=0;
      this._coneLastCheck=now;
      this._coneLastTick=0;
    }

    // Cone damage while active
    if(this.coneActiveUntil && now < this.coneActiveUntil){
      const dt = now - (this._coneLastCheck || now);
      this._coneLastCheck = now;

      // check player inside cone
      const px=player.x+player.width/2, py=player.y+player.height/2;
      const ex=this.x+this.width/2, ey=this.y+this.height/2;
      const vx=px-ex, vy=py-ey;
      const pdist=Math.hypot(vx,vy)||1;
      const ang=Math.atan2(vy,vx);
      let diff=Math.abs(ang-this.coneDir);
      if(diff>Math.PI) diff=2*Math.PI-diff;

      const inside = (pdist<=this.coneRange) && (diff <= (this.coneAngle/2));

      if(inside){
        this._coneInsideMs += dt;
        // damage ticks every 250ms, increasing while inside
        if(!this._coneLastTick) this._coneLastTick = now;
        if(now - this._coneLastTick >= 250){
          this._coneLastTick = now;
          const insideSec = this._coneInsideMs/1000;
          const base = Math.max(3, Math.round(this.damage*0.20));
          const ramp = Math.round(insideSec * 2.2); // gradual increase
          const dmg = Math.min(22, base + ramp);
          player.takeDamage(dmg);
          createParticles(player.x,player.y,'#b2bec3',8,3);
        }
      } else {
        this._coneInsideMs = 0;
      }
    }
  }
  draw(){
    const img = enemyImages['glacial'];
    if(img && img.complete) ctx.drawImage(img,this.x,this.y,this.width*1.5,this.height*1.5);
    else super.draw();

    // Cone visual
    const now=Date.now();
    if(this.coneActiveUntil && now < this.coneActiveUntil){
      const cx=this.x+this.width/2, cy=this.y+this.height/2;
      const a0=this.coneDir - this.coneAngle/2;
      const a1=this.coneDir + this.coneAngle/2;
      ctx.save();
      ctx.globalAlpha=0.28;
      ctx.fillStyle='rgba(180,220,255,0.9)';
      ctx.beginPath();
      ctx.moveTo(cx,cy);
      ctx.arc(cx,cy,this.coneRange,a0,a1,false);
      ctx.closePath();
      ctx.fill();
      ctx.globalAlpha=0.12;
      ctx.strokeStyle='rgba(180,220,255,0.9)';
      ctx.lineWidth=4;
      ctx.beginPath();
      ctx.moveTo(cx,cy);
      ctx.arc(cx,cy,this.coneRange,a0,a1,false);
      ctx.closePath();
      ctx.stroke();
      ctx.restore();
    }

    const hpPercent=this.hp/this.maxHP;
    ctx.fillStyle='#333';ctx.fillRect(this.x,this.y-10,this.width,5);
    ctx.fillStyle=hpPercent>0.5?'#2ecc71':hpPercent>0.25?'#f39c12':'#e74c3c';
    ctx.fillRect(this.x,this.y-10,this.width*hpPercent,5);
  }
}


class AttackReturnEnemy extends Enemy{
  constructor(type,level){super(type,level);this.homeX=this.x;this.homeY=this.y;this.state='idle';this.attackRange=60;this.attackCooldown=2200;this.lastAttackTime=0;this.attackSpeed=this.speed*2.5}
  update(player){
    if(Date.now()<this.spawnFreezeUntil)return;
    player = getPreferredTarget(this, player);
    const dx=(player.x+player.width/2)-(this.x+this.width/2);
    const dy=(player.y+player.height/2)-(this.y+this.height/2);
    const distToPlayer=Math.hypot(dx,dy);
    if(this.state==='idle'){
      const wanderX=Math.sin(Date.now()/1000+this.homeX)*0.3;const wanderY=Math.cos(Date.now()/1000+this.homeY)*0.3;
      this.vx=wanderX*this.speed;this.vy=wanderY*this.speed;
      if(distToPlayer<220&&Date.now()-this.lastAttackTime>this.attackCooldown)this.state='attack'
    }
    else if(this.state==='attack'){
      const nx=dx/(distToPlayer||1);const ny=dy/(distToPlayer||1);
      this.vx=nx*this.attackSpeed;this.vy=ny*this.attackSpeed;
      if(distToPlayer<this.attackRange){player.takeDamage(this.damage);this.lastAttackTime=Date.now();this.state='returning'}
    }
    else if(this.state==='returning'){
      const hx=this.homeX-this.x;const hy=this.homeY-this.y;const distHome=Math.hypot(hx,hy);
      if(distHome>6){
        const nx=hx/(distHome||1);const ny=hy/(distHome||1);
        this.vx=nx*this.speed;this.vy=ny*this.speed
      }else{this.vx=0;this.vy=0;this.state='idle'}
    }
    this.x+=this.vx;this.y+=this.vy;
    if(this.x<0)this.x=0;if(this.x+this.width>canvas.width)this.x=canvas.width-this.width;
    if(this.y<0)this.y=0;if(this.y+this.height>canvas.height-50)this.y=canvas.height-50-this.height;
  }
  draw(){
    const img = enemyImages['attacker'];
    if(img && img.complete) ctx.drawImage(img,this.x,this.y,this.width,this.height);
    else super.draw();
    const hpPercent=this.hp/this.maxHP;
    ctx.fillStyle='#333';ctx.fillRect(this.x,this.y-10,this.width,5);
    ctx.fillStyle=hpPercent>0.5?'#2ecc71':hpPercent>0.25?'#f39c12':'#e74c3c';
    ctx.fillRect(this.x,this.y-10,this.width*hpPercent,5);
  }
}

class BossEnemy extends Enemy{
  constructor(type,level){
    super(type,level);
    this.phase=0;
    this.superCooldown=12000;
    this.lastSuper=0;
    this.superActive=false;
    this.superStart=0;
    this.superDuration=3000;
    this.bulletTimer=0;
    this.attackCooldown=1800;
    this.lastAttack=0;
    this.width=Math.round(200*1.2);
    this.height=Math.round(200*1.2);
  }
  update(player){
    if(Date.now()<this.spawnFreezeUntil)return;
    player = getPreferredTarget(this, player);
    const dx=player.x-this.x;const dy=player.y-this.y;const dist=Math.hypot(dx,dy);
    const attackRange=60;
    if(dist>attackRange){
      const nx=dx/(dist||1);const ny=dy/(dist||1);
      this.vx=nx*this.speed;this.vy=ny*this.speed;
    } else {
      this.vx*=0.9;this.vy*=0.9;
      if(Date.now()-this.lastAttack>this.attackCooldown&&!player.isDashing){
        player.takeDamage(this.damage);
        this.lastAttack=Date.now();
      }
    }
    this.x+=this.vx;this.y+=this.vy;
    if(this.x<0)this.x=0;if(this.x+this.width>canvas.width)this.x=canvas.width-this.width;
    if(this.y<0)this.y=0;if(this.y+this.height>canvas.height-50)this.y=canvas.height-50-this.height;
    if(Date.now()-this.lastSuper>this.superCooldown){
      this.lastSuper=Date.now();this.superActive=true;this.superStart=Date.now()
    }
    if(this.superActive&&Date.now()-this.superStart>this.superDuration)this.superActive=false;
  }
  draw(){
    const key = (this.type==='boss' || this.type==='boss1') ? 'boss1' : (this.type==='boss2' ? 'boss2' : (this.type==='boss3' ? 'boss3' : this.type));
    const img = enemyImages[key];
    if(img && img.complete) ctx.drawImage(img,this.x,this.y,this.width,this.height);
    else super.draw();
    const hpPercent=this.hp/this.maxHP;
    ctx.fillStyle='#333';ctx.fillRect(this.x,this.y-10,this.width,5);
    ctx.fillStyle=hpPercent>0.5?'#2ecc71':hpPercent>0.25?'#f39c12':'#e74c3c';
    ctx.fillRect(this.x,this.y-10,this.width*hpPercent,5);
  }
}
class Boss5Enemy extends Enemy{
  constructor(type,level){
    super(type,level);

    // Dimensioni boss
    this.width=Math.round(245*1.2);
    this.height=Math.round(245*1.2);

    // Stat fisse richieste
    this.maxHP=800;
    this.hp=800;

    // "Non troppo veloce"
    this.speed=2.99*0.75; // ~1.69 (leggermente pi√π veloce)

    // Danno base (usato solo per eventuale contatto)
    this.damage=50;

    // --- Attacco: colpo ad ascia a ventaglio 80¬∞ (sweep sinistra->destra) ---
    this.fanRange=470;                 // raggio del ventaglio
    this.fanAngleDeg=142;               // ampiezza ventaglio
    this.swingDuration=1000;           // sweep lento (ms)
    this.swingCooldown=1000;           // cooldown un po' pi√π corto
    this.lastSwing=Date.now()-1800;    // piccolo offset
    this.swingActive=false;
    this.swingStart=0;
    this.swingCenterAngle=0;
    this.swingStartAngle=0;
    this.swingEndAngle=0;
    this.lastSwingTick=0;

    // --- Passiva: ogni 28s respinge + cura 50 ---
    this.passiveInterval=20000;
    this.nextPassive=Date.now()+this.passiveInterval;
    this.passiveFxUntil=0;

    // Area della passiva/super (raggio)
    this.passiveRadius=750; // aumentata
  }

  startSwingTowards(player){
    const cx=this.x+this.width/2, cy=this.y+this.height/2;
    const px=player.x+player.width/2, py=player.y+player.height/2;
    const baseAng=Math.atan2(py-cy, px-cx);

    const half=(this.fanAngleDeg*Math.PI/180)/2;
    this.swingCenterAngle=baseAng;
    // parte dall'estremit√† sinistra del ventaglio e arriva a destra
    this.swingStartAngle=baseAng-half;
    this.swingEndAngle=baseAng+half;

    this.swingActive=true;
    this.swingStart=Date.now();
    this.lastSwingTick=0;

    // piccolo telegraph: particelle
    createParticles(cx,cy,'#e74c3c',26,6);
  }

  doPassive(player){
    const now=Date.now();
    this.nextPassive = now + this.passiveInterval;

    // FX visivo
    const cx=this.x+this.width/2, cy=this.y+this.height/2;
    this.passiveFxUntil = now + 650;
    createParticles(cx,cy,'#00e5ff',55,8);
    shakeScreen();

    // Cura boss
    this.hp = Math.min(this.maxHP, this.hp + 80);

    // Effetto sul player SOLO se dentro l'area della super/passiva
    const px=player.x+player.width/2, py=player.y+player.height/2;
    const dx=px-cx, dy=py-cy;
    const dist=Math.hypot(dx,dy)||1;

    if(dist <= (this.passiveRadius||420)){
      // Knockback player (senza danno)
      const nx=dx/dist, ny=dy/dist;
      const pushDist=240; // "tanti pixel"
      player.x += nx*pushDist;
      player.y += ny*pushDist;

      // Slow: -50% velocit√† per 2s
      if(player && typeof player.applySlow==='function'){
        player.applySlow(0.60, 3200);
      }

      // clamp in arena
      player.x=Math.max(0, Math.min(canvas.width-player.width, player.x));
      player.y=Math.max(0, Math.min(canvas.height-player.height, player.y));
    }
  }

  applySwingDamage(player, now){
    // tick damage durante lo sweep, senza colpire mentre il player √® in dash
    if(player.isDashing) return;
    if(this.lastSwingTick && (now-this.lastSwingTick)<120) return;

    const cx=this.x+this.width/2, cy=this.y+this.height/2;
    const px=player.x+player.width/2, py=player.y+player.height/2;
    const dx=px-cx, dy=py-cy;
    const dist=Math.hypot(dx,dy);

    if(dist>this.fanRange) return;

    // angolo player
    const ang=Math.atan2(dy,dx);

    // calcola dove siamo nello sweep
    const t=Math.max(0, Math.min(1, (now-this.swingStart)/this.swingDuration));
    const cur=this.swingStartAngle + (this.swingEndAngle-this.swingStartAngle)*t;

    // se lo sweep √® verso destra, consideriamo la parte gi√† "coperta" sinistra->cur
    const minA=Math.min(this.swingStartAngle, cur);
    const maxA=Math.max(this.swingStartAngle, cur);

    // normalizza per confronto (gestione wrap a -pi/pi)
    function norm(a){
      while(a<-Math.PI) a+=Math.PI*2;
      while(a> Math.PI) a-=Math.PI*2;
      return a;
    }
    const a=norm(ang);
    const aMin=norm(minA);
    const aMax=norm(maxA);

    let inside=false;
    if(aMin<=aMax){
      inside = (a>=aMin && a<=aMax);
    }else{
      // wrap-around
      inside = (a>=aMin || a<=aMax);
    }

    if(inside){
      this.lastSwingTick=now;
      player.takeDamage(18);
    }
  }

  update(player){
    if(Date.now()<this.spawnFreezeUntil)return;
    player = getPreferredTarget(this, player);

    const now=Date.now();
    const cx=this.x+this.width/2, cy=this.y+this.height/2;
    const px=player.x+player.width/2, py=player.y+player.height/2;
    const dx=px-cx, dy=py-cy;
    const dist=Math.hypot(dx,dy)||1;

    // Passiva (ogni 28s)
    if(now>=this.nextPassive){
      this.doPassive(player);
    }

    // Movimento: inseguimento leggero, ma non troppo aggressivo durante lo swing
    if(!this.swingActive){
      const nx=dx/dist, ny=dy/dist;
      const prefer=210; // distanza "comoda"
      if(dist>prefer){
        this.vx=nx*this.speed;
        this.vy=ny*this.speed;
      }else{
        // drift lento per non essere statico
        this.vx*=0.92;
        this.vy*=0.92;
      }
    }else{
      // durante lo swing resta pi√π "fermo"
      this.vx*=0.85;
      this.vy*=0.85;
    }

    this.x+=this.vx; this.y+=this.vy;

    // clamp arena
    this.x=Math.max(20, Math.min(canvas.width-this.width-20, this.x));
    this.y=Math.max(40, Math.min(canvas.height-this.height-20, this.y));

    // Avvia swing se pronto e player in range
    if(!this.swingActive && dist<=this.fanRange && (now-this.lastSwing)>=this.swingCooldown){
      this.lastSwing=now;
      this.startSwingTowards(player);
    }

    // gestione swing attivo
    if(this.swingActive){
      this.applySwingDamage(player, now);
      if(now-this.swingStart>=this.swingDuration){
        this.swingActive=false;
      }
    }

    // contatto ravvicinato (solo se non in dash) - leggero
    if(dist<55 && !player.isDashing && !this.swingActive){
      if(!this._lastTouch) this._lastTouch=0;
      if(now-this._lastTouch>900){
        player.takeDamage(14);
        this._lastTouch=now;
      }
    }
  }

  draw(){
    const img = enemyImages.boss5;
    if(img && img.complete) ctx.drawImage(img,this.x,this.y,this.width,this.height);
    else super.draw();

    // HP bar
    const hpPercent=this.hp/this.maxHP;
    ctx.fillStyle='#333';ctx.fillRect(this.x,this.y-10,this.width,5);
    ctx.fillStyle=hpPercent>0.5?'#2ecc71':hpPercent>0.25?'#f39c12':'#e74c3c';
    ctx.fillRect(this.x,this.y-10,this.width*hpPercent,5);

    const now=Date.now();
    const cx=this.x+this.width/2, cy=this.y+this.height/2;

    // FX passiva
    if(now<this.passiveFxUntil){
      ctx.save();
      ctx.globalAlpha=0.45;
      ctx.lineWidth=6;
      ctx.strokeStyle='rgba(0,229,255,0.85)';
      ctx.beginPath();
      ctx.arc(cx,cy, (this.passiveRadius||this.width*0.75), 0, Math.PI*2);
      ctx.stroke();
      ctx.restore();
    }

    // Disegna il ventaglio durante lo swing (telegraph)
    if(this.swingActive){
      const t=Math.max(0, Math.min(1, (now-this.swingStart)/this.swingDuration));
      const cur=this.swingStartAngle + (this.swingEndAngle-this.swingStartAngle)*t;

      ctx.save();
      ctx.globalAlpha=0.18;
      ctx.fillStyle='#e74c3c';
      ctx.beginPath();
      ctx.moveTo(cx,cy);
      ctx.arc(cx,cy, this.fanRange, this.swingStartAngle, cur, false);
      ctx.closePath();
      ctx.fill();

      ctx.globalAlpha=0.65;
      ctx.lineWidth=4;
      ctx.strokeStyle='rgba(231,76,60,0.9)';
      ctx.beginPath();
      ctx.arc(cx,cy, this.fanRange, this.swingStartAngle, this.swingEndAngle, false);
      ctx.stroke();
      ctx.restore();
    }
  }
}


function spawnEnemiesForLevel(level){
  enemies.length=0;
  const lvl = Math.max(1, Math.min(level, levelConfigs.length));
  const cfg=levelConfigs[lvl-1];
  // Bestiario: segna il tipo di nemico/boss come gi√† sfidato (sblocco globale)
  markEnemySeen(cfg.enemyType);

  const count=cfg.enemyCount;
  for(let i=0;i<count;i++){
    let e;
    if(cfg.enemyType==='shooter') e=new ShooterEnemy(cfg.enemyType,lvl);
    else if(cfg.enemyType==='attacker') e=new AttackReturnEnemy(cfg.enemyType,lvl);
    else if(cfg.enemyType==='archer') e=new ArcherEnemy(cfg.enemyType,lvl);
    else if(cfg.enemyType==='glacial') e=new GlacialEnemy(cfg.enemyType,lvl);
    else if(cfg.enemyType==='boss1' || cfg.enemyType==='boss2' || cfg.enemyType==='boss3') e=new BossEnemy(cfg.enemyType,lvl);
    else if(cfg.enemyType==='boss5') e=new Boss5Enemy(cfg.enemyType,lvl);
    else e=new Enemy(cfg.enemyType,lvl);
    enemies.push(e);
  }
  spawnPickupsForLevel(lvl);
}

function updateBackgroundForLevel(level){
  // Levels 1-6: default bg, Levels 7-15: dark bg, Levels 16-20: final bg, Levels 21+: ice bg
  let tier=0;
  if(level>=21) tier=3;
  else if(level>=16) tier=2;
  else if(level>=7) tier=1;

  const applyTier=()=>{
    if(tier===3){
      bgDark.style.backgroundImage=`url('${URL_ICE}')`;
      bgDefault.style.opacity='0';
      bgDark.style.opacity='1';
    }
    else if(tier===2){
      bgDark.style.backgroundImage=`url('${URL_FINAL}')`;
      bgDefault.style.opacity='0';
      bgDark.style.opacity='1';
    } else if(tier===1){
      bgDark.style.backgroundImage=`url('${URL_DARK}')`;
      bgDefault.style.opacity='0';
      bgDark.style.opacity='1';
    } else {
      bgDefault.style.opacity='1';
      bgDark.style.opacity='0';
    }
    _bgTier=tier;
  };

  // Dissolvenza: quando si entra nella "fase finale" (dal 15 -> 16) o cambia tier
  if(fadeOverlay && tier!==_bgTier){
    fadeOverlay.style.opacity='1';
    setTimeout(()=>{
      applyTier();
      setTimeout(()=>{ fadeOverlay.style.opacity='0'; }, 80);
    }, 380);
  } else {
    applyTier();
  }
}

function startGame(){
  currentLevel=1;score=0;timer=levelConfigs[0].time;
  player=new Player(selectedCharacter||'jimmy');
  enemies=[];particles=[];projectiles=[];lasers=[];tempBeams=[];pickups=[];wolves=[];
  spawnEnemiesForLevel(currentLevel);
  updateBackgroundForLevel(currentLevel);
  document.getElementById('mainMenu').style.display='none';
  const ss=document.getElementById('startScreen');
  if(ss) ss.style.display='none';
  document.getElementById('uiOverlay').style.display='block';
  document.getElementById('scoreDisplay').style.display='block';
  document.getElementById('timerDisplay').style.display='block';
  document.getElementById('levelDisplay').style.display='block';
  document.getElementById('superCooldown').style.display='block';
  gameState='playing';
}

function endGame(won){
  if(gameState!=='playing') return;
  gameState='ended';
  document.getElementById('endScreen').style.display='block';
  document.getElementById('endTitle').textContent=won?'VICTORY':'GAME OVER';
  document.getElementById('endMessage').textContent=`Score Finale: ${score}`;
  document.getElementById('endSub').textContent=`Hai raggiunto il Livello ${currentLevel}`;
  const rec=records[selectedCharacter]||0;
  if(score>rec){records[selectedCharacter]=score;saveRecords();}
  document.getElementById('recordMessage').textContent=`Record Personaggio: ${records[selectedCharacter]||0}`;
}

function nextLevel(){

// Easy mode sustain: after clearing a level, heal between levels
const clearedLevel = currentLevel;
if(difficultyMode==='easy' && player){
  const healAmt = (clearedLevel % 5 === 0) ? (player.maxHP) : (player.maxHP * 0.25);
  player.hp = Math.min(player.maxHP, (clearedLevel % 5 === 0) ? player.maxHP : (player.hp + healAmt));
}
  if(currentLevel < levelConfigs.length){
    currentLevel++;
    spawnEnemiesForLevel(currentLevel);
    timer=levelConfigs[Math.max(0,currentLevel-1)].time;
    updateBackgroundForLevel(currentLevel);
  } else {
    endGame(true);
  }
}

function gameLoop(){
  requestAnimationFrame(gameLoop);
  if(gameState!=='playing')return;
  const now=Date.now();

  if(now-lastSecondTick>1000){
    lastSecondTick=now;
    timer--;
    if(timer<=0){
      timer=0;
      endGame(false);
return;
    }
  }

  if(player) player.update();
  enemies.forEach(e=>{e.update(player)});
  updateWolves();
  // Marz Super zone tick damage/expansion
  updateMagicZone(now);
  updateParticles();
  updateProjectiles();
  updateLasers();
  updateTempBeams();
  updateFuriaWaves();
  if(player) updatePickups(player);

  for(let i=enemies.length-1;i>=0;i--){
    if(enemies[i].hp<=0){
      const dead=enemies.splice(i,1)[0];
      applyScore(100*currentLevel);
      createParticles(dead.x,dead.y,'#fff176',30,6);
    }
  }

  if(enemies.length===0){
    if(!levelAdvanceLock){
      levelAdvanceLock=true;

      // Evolution trigger: after defeating Boss at Level 15 (boss3), only Jimmy/Rooney/Jeff evolve permanently from Level 16 onward
      const canEvolve = player && (player.type==='jimmy' || player.type==='rooney' || player.type==='jeff');
      if(gameState==='playing' && currentLevel===15 && canEvolve && !player.evolved){
        triggerEvolutionThenNextLevel(player.type);
      } else {
        setTimeout(()=>{
          if(gameState==='playing') nextLevel();
          levelAdvanceLock=false;
        }, 200);
      }
    }
  }

  ctx.clearRect(0,0,canvas.width,canvas.height);
  if(shakeAmount>0){
    const sx=(Math.random()-0.5)*shakeAmount;const sy=(Math.random()-0.5)*shakeAmount;
    ctx.save();ctx.translate(sx,sy);shakeAmount*=0.9
  } else ctx.save();

  // draw Marz Super zone behind entities
  drawMagicZone(now);
  enemies.forEach(e=>e.draw());
  drawWolves();
  if(player) player.draw();
  drawProjectiles();
  drawLasers();
  drawTempBeams();
  drawFuriaWaves();
  drawParticles();
  drawPickups();

  ctx.restore();

  if(player){
    document.getElementById('hpText').textContent=Math.max(0,Math.round(player.hp));
    document.getElementById('hpFill').style.width=Math.max(0,Math.round((player.hp/player.maxHP)*100))+'%';
  } else {
    document.getElementById('hpText').textContent='0';
    document.getElementById('hpFill').style.width='0%';
  }

  document.getElementById('scoreDisplay').textContent=`Score: ${score}`;
  document.getElementById('timerDisplay').textContent=timer;
  document.getElementById('levelDisplay').textContent=`Level ${currentLevel}`;
  const superReady=(Date.now()-player.lastSuper>=player.superCooldown)?'Ready':Math.ceil((player.superCooldown-(Date.now()-player.lastSuper))/1000)+'s';
  document.getElementById('superCooldown').textContent=`Super: ${superReady}`;
  if(player.attackBuffUntil) document.getElementById('atkBuffDisplay').textContent=Math.max(0,Math.ceil((player.attackBuffUntil-Date.now())/1000))+'s';
  else document.getElementById('atkBuffDisplay').textContent='0s';
}


function showEvoBanner(name){
  const el=document.getElementById('evoBanner');
  const txt=document.getElementById('evoBannerText');
  if(!el||!txt) return;
  txt.textContent = `${name.toUpperCase()} EVOLUTO!`;
  el.classList.remove('show');
  // force reflow to restart animation
  void el.offsetWidth;
  el.style.display='block';
  el.classList.add('show');
  setTimeout(()=>{ el.classList.remove('show'); el.style.display='none'; }, 980);
}

function triggerEvolutionThenNextLevel(charType){
  if(!player) return;
  // evolve + FX
  player.evolve();
  showEvoBanner(player.type);
  createParticles(player.x+player.width/2, player.y+player.height/2, '#fff176', 50, 6);
  shakeScreen();

  // delay a bit so the player sees the evolution, then go to next level
  setTimeout(()=>{
    if(gameState==='playing') nextLevel();
    levelAdvanceLock=false;
  }, 620);
}

window.addEventListener('keydown',e=>{
  const k=e.key.toLowerCase();
  keys[k]=true;
  if(k==='j'&&gameState==='playing'){player.attack()}
  if(k==='k'&&gameState==='playing'){player.superAttack()}
  if(k===' '&&gameState==='playing'){player.dodge()}
});
window.addEventListener('keyup',e=>{keys[e.key.toLowerCase()]=false;});

document.querySelectorAll('.character-card').forEach(card=>{
  card.addEventListener('click',()=>{
    const char=card.getAttribute('data-char');
    if(char==='tempostorm' && !allPrevAbove85k()){
      updateTempostormUnlockUI();
      return;
    }
    if(char==='voltryx' && !allThreeAbove50k()){
      // keep disabled
      updateVoltryxUnlockUI();
      return;
    }
    if(char==='kouvagia' && !voltryxAbove51k()){
      updateKouvagiaUnlockUI();
      return;
    }
    if(char==='salsy' && !allPrevAbove70k()){
      updateSalsyUnlockUI();
      return;
    }
    if(char==='marz' && !allPrevAboveMarz80k()){
      updateMarzUnlockUI();
      return;
    }
    if(char==='hecate' && !allPrevAboveHecate85k()){
      updateHecateUnlockUI();
      return;
    }
    document.querySelectorAll('.character-card').forEach(c=>c.classList.remove('selected'));
    card.classList.add('selected');
    selectedCharacter=char;
    updateMenuStatsDisplay(selectedCharacter);
  });
});

function updateMenuStatsDisplay(char){
  const s=characterStats[char];
  if(!s)return;
  document.getElementById(`menu-hp-${char}`).textContent=s.hp;
  document.getElementById(`menu-dmg-${char}`).textContent=
    char==='voltryx' ? `${Math.round(34*SUPER_DAMAGE_MULT)} (ranged AoE), ${50}x2 (melee)` :
    (char==='salsy' ? '33x2' :
     (char==='tempostorm' ? '40 (+30 se resta nel laser)' : (char==='marz' ? '40 / 50 / 60' : (char==='hecate' ? 'Freccia: colpo forte + 3 frecce' : s.damage))));

}

/* === Start screen: choose difficulty mode === */
(function(){
  const startScreen=document.getElementById('startScreen');
  const mainMenu=document.getElementById('mainMenu');
  const hardBtn=document.getElementById('modeHardBtn');
  const easyBtn=document.getElementById('modeEasyBtn');
  if(startScreen && mainMenu){
    // default view
    startScreen.style.display='block';
    mainMenu.style.display='none';
    gameState='start';
  }
  function goToMenu(mode){
    setDifficulty(mode);
    if(startScreen) startScreen.style.display='none';
    if(mainMenu) mainMenu.style.display='block';
    gameState='menu';
    updateMenuRecordsDisplay();
  }
  if(hardBtn) hardBtn.addEventListener('click', ()=>goToMenu('hard'));
  if(easyBtn) easyBtn.addEventListener('click', ()=>goToMenu('easy'));
})();

document.getElementById('startBtn').addEventListener('click',()=>{
  if(!selectedCharacter)selectedCharacter='jimmy';
  updateMenuRecordsDisplay();
  startGame();
});

const extraCharsBtn=document.getElementById('extraCharsBtn');
const extraCharacterSelect=document.getElementById('extraCharacterSelect');
if(extraCharsBtn && extraCharacterSelect){
  extraCharsBtn.addEventListener('click', ()=>{
    const isOpen = extraCharacterSelect.style.display !== 'none';
    extraCharacterSelect.style.display = isOpen ? 'none' : 'block';
  });
}


document.getElementById('restartBtn').addEventListener('click',()=>{
  document.getElementById('endScreen').style.display='none';
  startGame();
});
document.getElementById('menuBtn').addEventListener('click',()=>{
  document.getElementById('endScreen').style.display='none';
  document.getElementById('mainMenu').style.display='block';
  gameState='menu';
  updateMenuRecordsDisplay();
});

function populateMenuStatsAll(){
  updateMenuStatsDisplay('jimmy');
  updateMenuStatsDisplay('rooney');
  updateMenuStatsDisplay('jeff');
  updateMenuStatsDisplay('voltryx');
updateMenuStatsDisplay('kouvagia');
  updateMenuStatsDisplay('salsy');
  updateMenuStatsDisplay('tempostorm');
  updateMenuStatsDisplay('marz');
}
populateMenuStatsAll();
updateMenuRecordsDisplay();
updateVoltryxUnlockUI();

gameLoop();
// --- Guida: apertura/chiusura e gestione stato di gioco ---
(function(){
  const guideImgBtn = document.getElementById('guideImgBtn');
  const guideModal = document.getElementById('guideModal');
  const guideClose = document.getElementById('guideClose');
  if(!guideImgBtn || !guideModal || !guideClose) return;
  let gameStateBeforeGuide = undefined;
  function showGuide(){
    guideModal.style.display = 'flex';
  updateGuideUnlockUI();
    guideModal.setAttribute('aria-hidden','false');
    if(typeof gameState !== 'undefined') gameStateBeforeGuide = gameState;
    gameState = 'menu';
    guideClose.focus();
    window._guideOpen = true;
  }
  function hideGuide(){
    guideModal.style.display = 'none';
    guideModal.setAttribute('aria-hidden','true');
    if(typeof gameStateBeforeGuide !== 'undefined') gameState = gameStateBeforeGuide;
    guideImgBtn.focus();
    window._guideOpen = false;
  }
  guideImgBtn.addEventListener('click', function(e){ e.preventDefault(); showGuide(); });
  guideClose.addEventListener('click', function(e){ e.preventDefault(); hideGuide(); });
  guideModal.addEventListener('click', function(e){ if(e.target === guideModal) hideGuide(); });
  document.addEventListener('keydown', function(e){
    if(e.key === 'Escape' && guideModal.style.display === 'flex') hideGuide();
  });
  const guideImg = document.getElementById('guideImg');
  if(guideImg) guideImg.addEventListener('dragstart', function(ev){ ev.preventDefault(); });
})();

// --- Bestiario: apertura/chiusura e gestione stato di gioco ---
(function(){
  const btn = document.getElementById('enemyGuideImgBtn');
  const modal = document.getElementById('enemyGuideModal');
  const close = document.getElementById('enemyGuideClose');
  if(!btn || !modal || !close) return;

  let gameStateBefore = undefined;

  function show(){
    // aggiorna sbloccati e costruisci UI
    try{ enemySeen = loadEnemySeen(); }catch(e){}
    buildEnemyGuideUI();

    modal.style.display='flex';
    modal.setAttribute('aria-hidden','false');
    if(typeof gameState !== 'undefined') gameStateBefore = gameState;
    gameState='menu';
    close.focus();
    window._enemyGuideOpen = true;
  }
  function hide(){
    modal.style.display='none';
    modal.setAttribute('aria-hidden','true');
    if(typeof gameStateBefore !== 'undefined') gameState = gameStateBefore;
    btn.focus();
    window._enemyGuideOpen = false;
  }

  btn.addEventListener('click', function(e){ e.preventDefault(); show(); });
  close.addEventListener('click', function(e){ e.preventDefault(); hide(); });
  modal.addEventListener('click', function(e){ if(e.target === modal) hide(); });
  document.addEventListener('keydown', function(e){
    if(e.key === 'Escape' && modal.style.display === 'flex') hide();
  });

  const img = document.getElementById('enemyGuideImg');
  if(img) img.addEventListener('dragstart', function(ev){ ev.preventDefault(); });
})();


// ===== FURIA WAVES (visual + damage) =====
let furiaWaves=[];
// A wave is: {x,y,start,delay,duration,maxR,damage,doneDamage}
function spawnFuriaWaves(x,y){
  const waves=[
    {delay:0,   maxR:190, duration:620, damage:20},
    {delay:420, maxR:300, duration:760, damage:20},
    {delay:880, maxR:430, duration:920, damage:20},
  ];
  const now=Date.now();
  for(const w of waves){
    furiaWaves.push({
      x,y,
      start: now + w.delay,
      delay:w.delay,
      duration:w.duration,
      maxR:w.maxR,
      damage:w.damage,
      doneDamage:false
    });
  }
  // extra punch
  shakeAmount = Math.max(shakeAmount, 10);
  for(let i=0;i<3;i++) createParticles(x+(Math.random()-0.5)*30,y+(Math.random()-0.5)*30,'#ff00ff',22,5);
}

function updateFuriaWaves(){
  const now=Date.now();
  furiaWaves = furiaWaves.filter(w=>{
    // not started yet
    if(now < w.start) return true;

    const t = (now - w.start);
    const prog = Math.max(0, Math.min(1, t / w.duration));
    const r = w.maxR * prog;

    // Apply damage once, early in the wave (so it feels immediate)
    if(!w.doneDamage && prog >= 0.15){
      w.doneDamage=true;

      // strong particles ring
      for(let i=0;i<26;i++){
        const a = (Math.PI*2)*(i/26);
        createParticles(w.x + Math.cos(a)*Math.min(r+18, w.maxR), w.y + Math.sin(a)*Math.min(r+18, w.maxR), '#ff00ff', 2, 4);
      }

      for(let i=enemies.length-1;i>=0;i--){
        const e=enemies[i];
        const d=Math.hypot((e.x+e.width/2)-w.x,(e.y+e.height/2)-w.y);
        if(d<=w.maxR){
          const _final=applyEnemyDamage(e, w.damage);
          showDamageNumber(e.x,e.y,_final);
          createParticles(e.x,e.y,'#ff4dff',14,5);
          if(e.hp<=0){
            createParticles(e.x,e.y,'#fff176',30,6);
            enemies.splice(i,1);
            applyScore(100*currentLevel);
          }
        }
      }
    }

    // keep until finished
    return t <= w.duration;
  });
}

function drawFuriaWaves(){
  const now=Date.now();
  for(const w of furiaWaves){
    if(now < w.start) continue;
    const t = (now - w.start);
    const prog = Math.max(0, Math.min(1, t / w.duration));
    const r = w.maxR * prog;

    // fade out near end
    const fade = (prog < 0.75) ? 1 : Math.max(0, 1 - ((prog-0.75)/0.25));
    const alpha = 0.55 * fade;

    // Outer ring
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.lineWidth = 10;
    ctx.strokeStyle = 'rgba(255,0,255,0.95)';
    ctx.beginPath();
    ctx.arc(w.x, w.y, r, 0, Math.PI*2);
    ctx.stroke();

    // Glow ring
    ctx.globalAlpha = alpha*0.35;
    ctx.lineWidth = 22;
    ctx.beginPath();
    ctx.arc(w.x, w.y, r, 0, Math.PI*2);
    ctx.stroke();

    // Core ripple
    ctx.globalAlpha = alpha*0.25;
    ctx.lineWidth = 6;
    ctx.strokeStyle = 'rgba(255,180,255,0.9)';
    ctx.beginPath();
    ctx.arc(w.x, w.y, Math.max(0, r*0.65), 0, Math.PI*2);
    ctx.stroke();
    ctx.restore();
  }
}

</script>
</div>
<script>
/* ================================
   KEYBOARD INPUT (WASD + ARROWS)
   ================================ */
function normalizeKey(key) {
  switch (key) {
    case 'ArrowUp': return 'w';
    case 'ArrowDown': return 's';
    case 'ArrowLeft': return 'a';
    case 'ArrowRight': return 'd';
    default: return key.toLowerCase();
  }
}

window.addEventListener('keydown', e => {
  const k = normalizeKey(e.key);
  keys[k] = true;
});

window.addEventListener('keyup', e => {
  const k = normalizeKey(e.key);
  keys[k] = false;
});
</script>

</body>
</html>
