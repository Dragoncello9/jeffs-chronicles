<!DOCTYPE html>

<html lang="it">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<title>Platform Fighter - Complete</title>
<!-- Link ai font da Google Fonts -->
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&amp;family=VT323&amp;display=swap" rel="stylesheet"/>
<style>
    *{margin:0;padding:0;box-sizing:border-box}
    html,body{height:100%}
    body{
      font-family:'VT323', monospace; /* Font di gioco */
      background:#000;
      color:#fff;
      display:flex;
      justify-content:center;
      align-items:center;
      height:100vh;
      overflow:hidden;
      position:relative;
    }

    #bgDefault,#bgDark{
      position:absolute;left:0;top:0;width:100%;height:100%;
      background-size:cover;background-position:center;
      transition:opacity 900ms ease;z-index:0;pointer-events:none
    }
    #bgDefault{opacity:1}
    #bgDark{opacity:0}

    #fadeOverlay{position:absolute;left:0;top:0;width:100%;height:100%;background:#000;opacity:0;transition:opacity 650ms ease;z-index:3;pointer-events:none}

    #gameContainer{
      position:relative;width:1200px;height:700px;
      max-width:calc(100vw - 40px);max-height:calc(100vh - 40px);
      z-index:2;display:flex;justify-content:center;align-items:center
    }

    #gameCanvas{
      background:transparent;border:4px solid #fff;
      box-shadow:0 0 30px rgba(255,255,255,0.5);
      image-rendering:pixelated;display:block
    }

    .ui-overlay{position:absolute;top:18px;left:18px;z-index:10;text-shadow:2px 2px 4px #000}

    .hp-bar{width:200px;height:30px;background:#333;border:3px solid #fff;margin-top:8px;position:relative}
    .hp-fill{height:100%;background:linear-gradient(90deg,#e74c3c,#c0392b);transition:width 0.25s}

    .score{position:absolute;top:18px;right:18px;color:#f39c12;font-size:22px;text-shadow:2px 2px 4px #000;z-index:10}
    .timer{position:absolute;top:18px;left:50%;transform:translateX(-50%);font-size:32px;color:#f39c12;text-shadow:2px 2px 4px #000;z-index:10}
    .level-indicator{position:absolute;top:60px;left:50%;transform:translateX(-50%);font-size:18px;z-index:10}
    .super-cooldown{position:absolute;top:100px;left:18px;font-size:14px;color:#f39c12;z-index:10}

    .evo-banner{
      position:absolute;left:50%;top:45%;
      transform:translate(-50%,-50%);
      z-index:50;
      padding:18px 24px;
      border:4px solid #fff;
      background:rgba(0,0,0,0.85);
      font-family:'Press Start 2P', cursive;
      text-align:center;
      pointer-events:none;
      box-shadow:0 0 28px rgba(255,255,255,0.35);
      opacity:0;
    }
    .evo-banner.show{
      display:block !important;
      animation:evoPop 520ms ease forwards;
    }
    @keyframes evoPop{
      0%{opacity:0;transform:translate(-50%,-50%) scale(0.85)}
      25%{opacity:1;transform:translate(-50%,-50%) scale(1.08)}
      100%{opacity:0;transform:translate(-50%,-50%) scale(1.00)}
    }


    .menu,.end-screen{
      position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);
      background:rgba(0,0,0,0.9);padding:30px;border:4px solid #fff;
      text-align:center;z-index:20;width:calc(100% - 80px);max-width:760px;
      font-family:'Press Start 2P', cursive; /* Font menu */
    }

    .menu h1,.end-screen h1{
      font-size:38;color:#e74c3c;text-shadow:3px 3px 6px #000;margin-bottom:12px
    }

    .character-select{
      display:block;
      margin:18px 0;
      max-height:420px;
      overflow-y:auto;
      overflow-x:hidden;
      padding:6px;
      box-sizing:border-box;
    }
    .character-select::-webkit-scrollbar{width:10px}
    .character-select::-webkit-scrollbar-thumb{background:#555;border:2px solid #111;border-radius:10px}
    .character-select::-webkit-scrollbar-track{background:#111}

    .character-select::-webkit-scrollbar{width:10px}
    .character-select::-webkit-scrollbar-thumb{background:#555;border:2px solid #111;border-radius:10px}
    .character-select::-webkit-scrollbar-track{background:#111}

    /* Ridotte leggermente le card personaggio per evitare sovrapposizioni */
    .character-card{
      background:#222;border:3px solid #555;padding:9px 10px;
      width:100%;
      cursor:pointer;transition:all .12s;position:relative;
      display:flex;flex-direction:row;align-items:center;gap:12px;
      min-height:64px;box-sizing:border-box;
    }
    .character-card:hover{transform:translateY(-3px);border-color:#e74c3c;background:#222}
    .character-card.selected{border-left:6px solid #f39c12;background:#2b2b2b}
    .character-card.disabled{ filter:grayscale(1); opacity:0.55; cursor:not-allowed; transform:none; }
    .character-card img{
      width:56px;
      height:56px;
      display:block;
      image-rendering:pixelated;
      margin:0;
      flex:0 0 auto;
    }
    .character-card h3{
      flex:0 0 160px;
      text-align:left;
      margin:0;
      font-size:16px;
      color:#fff;
    }
    .character-card .menu-stats{font-size:13px;color:#ddd;margin-left:8px}
    .record-badge{position:static;margin-left:12px;font-size:12px}
    .lock-badge{position:absolute;right:10px;top:10px;font-size:12px;color:#f39c12;background:#000;padding:3px 6px;border:1px solid #f39c12}
    /* nascondi i vecchi pulsanti interni delle card se presenti */
    .character-card .select-btn{display:none!important}

    .character-card:hover{transform:scale(1.03);border-color:#e74c3c}
    .character-card.selected{border-color:#f39c12;background:#333}
    .character-card.disabled{ filter:grayscale(1); opacity:0.55; cursor:not-allowed; }
.character-card.disabled:hover{ transform:none; border-color:#555; }

/* Coming soon (grey, not clickable) */
.character-card.coming-soon{
  background:#3a3a3a;
  border-color:#777;
}
.character-card.coming-soon .menu-stats{color:#cfcfcf}

    /* Immagine personaggio pi√π piccola per evitare sovrapposizioni */
    .character-card img{
      width:110px; /* dimensione immagine ridotta */
      height:auto;
      display:block;
      image-rendering:pixelated;
      margin-bottom:8px;
    }

    /* Riquadro attorno al "tasto" per selezionare il personaggio */
    .character-card .select-btn{
      display:inline-block;
      border:3px solid #fff; /* riquadro visibile */
      padding:8px 10px;
      margin-top:10px;
      background:transparent;
      color:#fff;
      font-family:'Press Start 2P', cursive;
      font-size:12px;
      text-decoration:none;
      cursor:pointer;
    }
    .character-card .select-btn:active{transform:translateY(1px)}

    /* Riquadro leggermente pi√π grande per il nome (evita sovrapposizione con record) */
    .character-card .name-box{
      min-height:34px; /* ingrandito per non sovrapporre il record */
      padding:6px 8px;
      width:100%;
      text-align:center;
      font-size:13px;
      color:#fff;
      background:rgba(0,0,0,0.15);
      border:2px solid rgba(255,255,255,0.06);
      margin-bottom:6px;
      box-sizing:border-box;
    }

    /* Posizionamento del record: sotto il nome del personaggio, non assoluto */
    .record-badge{
      position:static; /* rimosso absolute per evitare sovrapposizioni */
      margin-top:6px;
      font-size:11px;
      color:#ccc;
      background:transparent;
      z-index:2;
    }

    .lock-badge{
      position:absolute;top:8px;right:8px;
      font-size:12px;color:#f39c12;background:#000;padding:3px 6px;border:1px solid #f39c12
    }

    .btn{ background:#e74c3c;color:#fff;border:none;padding:10px 22px; font-size:16px;cursor:pointer;margin:8px; font-family:'Press Start 2P', cursive; /* Bottoni in stile menu */ }
    .btn.btn-mini{padding:6px 12px;font-size:14px;margin:6px;}


    /* Extra character button + layout */
    .start-row{display:flex;gap:10px;align-items:center;justify-content:center;margin-top:10px;}
    .mini-btn{padding:8px 14px;font-size:22px;line-height:1;min-width:46px;max-width:60px;}
    .extra-characters{margin-top:14px;}


    .damage-number{position:absolute;font-size:20px;font-weight:bold;color:#e74c3c;text-shadow:2px 2px 4px #000;pointer-events:none;animation:floatUp 1s ease-out forwards;z-index:200}
    @keyframes floatUp{to{transform:translateY(-50px);opacity:0}}

    .pickup-label{position:absolute;font-size:14px;color:#fff;text-shadow:2px 2px 4px #000}
    .menu-stats{font-size:13px;color:#ddd;margin-top:8px}

    @media (max-width:900px){
      #gameContainer{width:900px;height:525px}
      .menu,.end-screen{width:calc(100% - 40px);max-width:680px}
    }
/* Pulsante immagine stile */
.img-btn{
  background:transparent;border:0;padding:6px;cursor:pointer;display:inline-flex;
  align-items:center;justify-content:center;transition:transform 160ms ease, box-shadow 160ms ease;
}
.img-btn img{
  width:72px;height:72px;display:block;image-rendering:pixelated;
  border:3px solid #fff;border-radius:8px;transition:transform 160ms ease, box-shadow 160ms ease;
}
.img-btn:hover img{transform:scale(1.08);box-shadow:0 6px 18px rgba(0,0,0,0.6);}

/* Modale guida */
.guide-modal{
  position:fixed;left:0;top:0;width:100%;height:100%;
  background:rgba(0,0,0,0.75);display:flex;justify-content:center;align-items:center;
  z-index:60;padding:20px;
}
.guide-modal-content{
  background:rgba(10,10,10,0.98);border:4px solid #fff;max-width:980px;width:100%;max-height:90vh;
  overflow:auto;padding:22px;font-family:'VT323', monospace;color:#fff;position:relative;
  box-shadow:0 0 30px rgba(0,0,0,0.8);
}
.guide-close{
  position:absolute;right:12px;top:12px;background:transparent;border:2px solid #fff;color:#fff;
  width:36px;height:36px;border-radius:4px;cursor:pointer;font-size:18px;
}
.guide-body h3{color:#f39c12;margin-top:12px}
.guide-body p, .guide-body ul{font-size:14px;line-height:1.45;color:#ddd}

/* === Bestiario (nemici + boss) === */
.enemy-guide-content{max-width:1020px;}
.enemy-guide-body{margin-top:10px}
.enemy-guide-wrap{
  display:flex;gap:16px;align-items:stretch;
  min-height:420px;
}
.enemy-guide-list{
  width:260px;flex:0 0 260px;
  border:2px solid rgba(255,255,255,0.18);
  background:rgba(255,255,255,0.03);
  padding:10px;overflow:auto;max-height:62vh;
}
.enemy-guide-list button{
  width:100%;
  background:rgba(0,0,0,0.35);
  border:2px solid rgba(255,255,255,0.18);
  color:#fff;
  padding:10px 10px;
  margin:0 0 10px 0;
  cursor:pointer;
  font-family:'Press Start 2P', cursive;
  font-size:11px;
  text-align:left;
  display:flex;gap:10px;align-items:center;
}
.enemy-guide-list button:hover{border-color:#f39c12;transform:translateY(-1px)}
.enemy-guide-list button.active{border-color:#e74c3c;background:rgba(231,76,60,0.12)}
.enemy-guide-list .enemy-mini{
  width:44px;height:44px;image-rendering:pixelated;
  border:2px solid rgba(255,255,255,0.7);
  border-radius:6px;flex:0 0 auto;background:#000;
}
.enemy-guide-detail{
  flex:1;
  border:2px solid rgba(255,255,255,0.18);
  background:rgba(255,255,255,0.03);
  padding:14px;
  display:flex;
  align-items:center;
  justify-content:center;
}
.enemy-guide-detail-inner{
  width:100%;
  display:flex;
  gap:16px;
  align-items:flex-start;
}
.enemy-guide-detail-inner img{
  width:240px;height:240px;object-fit:contain;
  image-rendering:pixelated;
  border:3px solid #fff;border-radius:10px;
  background:rgba(0,0,0,0.35);
  flex:0 0 auto;
}
.enemy-guide-detail-inner h3{
  margin:0 0 10px 0;
  color:#f39c12;
  font-family:'Press Start 2P', cursive;
  font-size:14px;
  line-height:1.35;
}
.enemy-guide-detail-inner p{
  margin:0;
  font-size:15px;
  color:#ddd;
  line-height:1.55;
  font-family:'VT323', monospace;
}
.enemy-guide-hint{
  margin:14px 0 0 0;
  font-size:13px;
  color:#cfcfcf;
  font-family:'VT323', monospace;
}
@media (max-width:900px){
  .enemy-guide-wrap{flex-direction:column}
  .enemy-guide-list{width:100%;flex:0 0 auto;max-height:30vh}
  .enemy-guide-detail-inner{flex-direction:column;align-items:center}
  .enemy-guide-detail-inner img{width:220px;height:220px}
}


.guide-body ul{margin-left:18px}
@media (max-width:900px){
  .guide-modal-content{max-width:calc(100% - 20px);padding:14px}
  .guide-body p{font-size:13px}
}
  
    /* menu stat numbers: only numbers, no labels */
    .menu-stats{display:flex;gap:12px;align-items:center;justify-content:center;font-size:14px}
    .menu-stats .stat{min-width:40px;text-align:center;font-weight:bold;color:#f1f1f1}
    .menu-stats .spacer{width:8px}
    

.compact-selector{margin:16px 0}
.char-grid{
  display:grid;
  grid-template-columns:repeat(4,1fr);
  gap:10px;
}
.char-grid button{
  background:#111;
  border:2px solid #555;
  color:#fff;
  font-family:'Press Start 2P', cursive;
  font-size:10px;
  padding:10px 6px;
  cursor:pointer;
}
.char-grid button:hover{border-color:#f39c12}
.char-grid button.empty{
  background:#222;
  border-style:dashed;
  cursor:not-allowed;
  color:#777;
}


/* ==== COMPACT CHARACTER SELECT PATCH ==== */
.characterCard, .charCard, .character-card {
  display:none !important; /* hide big cards */
}

.charBtn, .characterBtn, .selectCharBtn, .char-button {
  padding:10px 14px;
  margin:6px;
  font-size:18px;
  border-radius:12px;
  border:3px solid #555;
  background:#1e1e1e;
  color:#fff;
  cursor:pointer;
}

.charBtn.selected, .characterBtn.selected, .selectCharBtn.selected, .char-button.selected{
  border-color:#ff9800 !important;
  box-shadow:0 0 12px #ff9800;
}

/* collapse container */
#charactersContainerCompact{
  max-height:70vh;
  overflow:auto;
  padding:6px;
}

#moreCharsToggle{
  width:100%;
  margin-top:8px;
  padding:10px;
  border-radius:12px;
  border:3px solid #ff9800;
  background:#2c2c2c;
  color:#ff9800;
  font-size:18px;
  cursor:pointer;
}


/* ==== STRONG SELECT GLOW ==== */
.charBtn.selected, .characterBtn.selected, .selectCharBtn.selected, .char-button.selected{
  border-color:#ff9800 !important;
  box-shadow:
    0 0 8px #ff9800,
    0 0 16px #ff9800,
    0 0 28px rgba(255,152,0,0.9),
    inset 0 0 12px rgba(255,152,0,0.6);
  background: linear-gradient(180deg,#2b1a00,#3a2200);
  transform: scale(1.05);
  transition: all 0.12s ease;
}

.charBtn:hover, .characterBtn:hover, .selectCharBtn:hover, .char-button:hover{
  box-shadow: 0 0 10px rgba(255,152,0,0.6);
}


.ira-glow{
  color:#7a0019;
  border:2px solid #7a0019;
  padding:4px 8px;
  border-radius:6px;
  box-shadow:0 0 10px rgba(122,0,25,0.8), 0 0 20px rgba(122,0,25,0.6);
  font-weight:bold;
}


/* ===== Account Level UI ===== */

/* --- Account Level Road mini button + layout --- */
.xpbar-row{
  display:flex;
  align-items:center;
  gap:10px;
}
.btn-road-mini{width:34px;height:34px;font-size:18px;
  width:28px;
  height:28px;
  border-radius:8px;
  border:2px solid rgba(255,255,255,0.60);
  background:linear-gradient(180deg, rgba(210,210,210,0.95), rgba(140,140,140,0.95));
  box-shadow:0 0 10px rgba(255,255,255,0.18), inset 0 0 10px rgba(0,0,0,0.35);
  color:#141414;
  font-weight:bold;
  cursor:pointer;
  user-select:none;
  line-height:1;
  display:flex;
  align-items:center;
  justify-content:center;
}
.btn-road-mini:hover{transform:scale(1.12);
  transform:scale(1.05);
}


/* ===== ROAD BUTTON CLICK BOOST ===== */
.btn-road-mini{
  width:42px !important;
  height:42px !important;
  font-size:22px !important;
  border-radius:12px !important;
}

@keyframes claimPulse{
  0%{transform:scale(1); box-shadow:0 0 12px rgba(46,204,113,0.25);}
  50%{transform:scale(1.15); box-shadow:0 0 28px rgba(46,204,113,0.55);}
  100%{transform:scale(1); box-shadow:0 0 12px rgba(46,204,113,0.25);}
}

.btn-road-mini.ready-claim{
  animation:claimPulse 1.1s ease-in-out infinite;
}
/* ===== ROAD BUTTON: claimable glow ===== */
.btn-road-mini.ready-claim{
  border-color: rgba(46,204,113,0.95) !important;
  background: linear-gradient(180deg, rgba(46,204,113,0.98), rgba(30,160,85,0.98)) !important;
  color:#06110a !important;
  box-shadow: 0 0 18px rgba(46,204,113,0.35), inset 0 0 10px rgba(0,0,0,0.25) !important;
}
.btn-road-mini.ready-claim:hover{
  transform:scale(1.08);
  box-shadow: 0 0 26px rgba(46,204,113,0.40), inset 0 0 10px rgba(0,0,0,0.22) !important;
}
.account-road-wrap{
  margin-top:10px;
  border:2px solid rgba(255,255,255,0.14);
  border-radius:16px;
  background:rgba(0,0,0,0.20);
  padding:12px 10px;
  box-shadow: inset 0 0 18px rgba(0,0,0,0.45);
}
.account-road-scroll{
  overflow-x:auto;
  overflow-y:hidden;
  white-space:nowrap;
  padding:10px 6px 14px;
  -webkit-overflow-scrolling:touch;
}
.account-road-track{
  position:relative;
  display:inline-flex;
  align-items:center;
  gap:14px;
  padding:6px 10px;
}
.account-road-line{
  position:absolute;
  left:0;
  right:0;
  top:50%;
  transform:translateY(-50%);
  height:6px;
  border-radius:6px;
  background:rgba(255,255,255,0.14);
  box-shadow: inset 0 0 10px rgba(0,0,0,0.55);
  z-index:0;
}
.road-node{
  position:relative;
  width:86px;
  height:86px;
  border-radius:18px;
  border:2px solid rgba(255,255,255,0.18);
  background:linear-gradient(180deg, rgba(30,30,45,0.92), rgba(18,18,28,0.92));
  box-shadow:0 0 14px rgba(0,0,0,0.35), inset 0 0 12px rgba(0,0,0,0.55);
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  gap:6px;
  z-index:1;
  flex:0 0 auto;
}
.road-node .rn-lv{
  font-size:14px;
  color:#fff;
  text-shadow:0 2px 0 rgba(0,0,0,0.5);
}
.road-node .rn-reward{
  font-size:10px;
  opacity:0.85;
}
.road-node.done{
  border-color: rgba(255, 212, 108, 0.50);
  box-shadow:0 0 18px rgba(255, 212, 108, 0.18), inset 0 0 12px rgba(0,0,0,0.55);
}
.road-node.current{
  border-color: rgba(120, 220, 255, 0.65);
  box-shadow:0 0 22px rgba(120, 220, 255, 0.22), inset 0 0 12px rgba(0,0,0,0.55);
}
.road-node.locked{
  opacity:0.55;
  filter:grayscale(0.35);
}

/* ===== ETERE CLAIM (Road) ===== */
.road-node[title*="riscattare"]{
  box-shadow:0 0 18px rgba(127,255,212,0.14), inset 0 0 12px rgba(0,0,0,0.55);
}
.road-node[title*="riscattare"]:hover{
  transform:translateY(-2px) scale(1.02);
  border-color: rgba(127,255,212,0.60);
  box-shadow:0 0 22px rgba(127,255,212,0.22), inset 0 0 12px rgba(0,0,0,0.55);
}
.road-subline{
  margin-top:10px;
  font-size:13px;
  color:#ddd;
  opacity:0.92;
}


.account-level-btn{
  position:absolute;
  left:14px;
  bottom:14px;
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  gap:2px;
  width:110px;
  height:92px;
  border:2px solid rgba(255,255,255,0.75);
  border-radius:14px;
  background:linear-gradient(180deg, rgba(40,40,60,0.95), rgba(20,20,30,0.95));
  box-shadow:0 0 18px rgba(255,255,255,0.20), inset 0 0 14px rgba(0,0,0,0.55);
  cursor:pointer;
  user-select:none;
  transform:translateZ(0);
}

.skin-btn{
  position:absolute;
  right:14px;
  bottom:14px;
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  gap:6px;
  width:110px;
  height:92px;
  border:2px solid rgba(255,255,255,0.70);
  border-radius:14px;
  background:linear-gradient(180deg, rgba(210,210,220,0.92), rgba(140,140,155,0.92));
  box-shadow:0 0 18px rgba(255,255,255,0.18), inset 0 0 14px rgba(0,0,0,0.35);
  cursor:pointer;
  user-select:none;
}
.skin-btn:hover{filter:brightness(1.06);}
.skin-btn:active{transform:translateY(1px);}

.skin-btn-img{
  width:42px;
  height:42px;
  image-rendering:pixelated;
  filter:drop-shadow(0 2px 3px rgba(0,0,0,0.55));
}
.skin-btn-label{
  font-family:'Press Start 2P', cursive;
  font-size:12px;
  letter-spacing:0.6px;
  color:#14151a;
  text-shadow:0 1px 0 rgba(255,255,255,0.45);
}

.skin-scroller-wrap{
  width:100%;
  max-width:740px;
  margin:0 auto;
  padding:10px 8px;
  border:2px solid rgba(255,255,255,0.16);
  border-radius:14px;
  background:rgba(0,0,0,0.18);
  box-shadow:inset 0 0 18px rgba(0,0,0,0.45);
}
.skin-scroller{
  display:flex;
  gap:12px;
  overflow-x:auto;
  overflow-y:hidden;
  padding:8px 6px;
  scroll-snap-type:x mandatory;
  -webkit-overflow-scrolling:touch;
}
.skin-scroller::-webkit-scrollbar{height:10px;}
.skin-scroller::-webkit-scrollbar-thumb{background:rgba(255,255,255,0.22);border-radius:999px;}
.skin-scroller::-webkit-scrollbar-track{background:rgba(0,0,0,0.18);border-radius:999px;}

.skin-card{
  flex:0 0 auto;
  width:170px;
  border:2px solid rgba(255,255,255,0.22);
  border-radius:16px;
  background:linear-gradient(180deg, rgba(40,40,55,0.92), rgba(20,20,30,0.92));
  box-shadow:0 0 16px rgba(255,255,255,0.10), inset 0 0 16px rgba(0,0,0,0.55);
  padding:12px 10px 10px;
  text-align:center;
  scroll-snap-align:start;
}
.skin-card img{
  width:120px;
  height:120px;
  object-fit:contain;
  image-rendering:pixelated;
  filter:drop-shadow(0 4px 6px rgba(0,0,0,0.55));
}
.skin-img-missing{
  width:120px;
  height:120px;
  display:flex;
  align-items:center;
  justify-content:center;
  border-radius:14px;
  background:rgba(255,255,255,0.08);
  border:1px solid rgba(255,255,255,0.18);
  color:rgba(255,255,255,0.6);
  font-size:54px;
  font-weight:900;
  margin:0 auto;
}

.skin-card .skin-name{
  margin-top:8px;
  font-family:'Press Start 2P', cursive;
  font-size:12px;
  color:#fff;
  opacity:0.95;
}
.skin-card .skin-sub{
  margin-top:4px;
  font-size:14px;
  color:#cfcfe6;
  opacity:0.9;
}

.account-level-btn:hover{ transform:scale(1.03); box-shadow:0 0 22px rgba(255,255,255,0.28), inset 0 0 14px rgba(0,0,0,0.55); }
.account-level-btn:active{ transform:scale(0.98); }
.alb-badge{
  font-family: 'Press Start 2P', monospace;
  font-size:10px;
  padding:3px 8px;
  border-radius:999px;
  background:rgba(255,215,64,0.18);
  border:1px solid rgba(255,215,64,0.55);
  color:#ffd54f;
  letter-spacing:1px;
}
.alb-level{
  font-family: 'Press Start 2P', monospace;
  font-size:22px;
  color:#fff;
  text-shadow:0 0 10px rgba(255,255,255,0.35);
}
.alb-xp{
  font-family: 'Press Start 2P', monospace;
  font-size:9px;
  color:#cfd8dc;
  opacity:0.95;
}

.account-panel{
  width:min(720px, 92vw);
  margin:0 auto;
  padding:12px 14px;
  border-radius:16px;
  border:1px solid rgba(255,255,255,0.35);
  background:rgba(0,0,0,0.25);
  box-shadow:0 0 18px rgba(255,255,255,0.12);
}
.account-top{display:flex;justify-content:space-between;align-items:baseline;gap:10px;flex-wrap:wrap;}
.account-lv{
  font-family:'Press Start 2P', monospace;
  font-size:16px;
  color:#fff;
}
.account-xptext{font-family:'Press Start 2P', monospace;font-size:11px;color:#cfd8dc;}
.xpbar-wrap{
  position:relative;
  height:16px;
  border-radius:999px;
  overflow:hidden;
  margin-top:10px;
  border:1px solid rgba(255,255,255,0.35);
  background:rgba(0,0,0,0.35);
}
.xpbar{
  height:100%;
  width:0%;
  background:linear-gradient(90deg, rgba(76,175,80,0.95), rgba(255,235,59,0.95));
  transition:width 380ms ease;
}
.xpbar-glow{
  position:absolute; inset:0;
  box-shadow: inset 0 0 12px rgba(255,255,255,0.20);
  pointer-events:none;
}

.missions-list{
  width:min(720px, 92vw);
  margin:0 auto;
  display:flex;
  flex-direction:column;
  gap:8px;
}

/* ===== Missioni: header + pulsante ordinamento (pi√π piccolo, argento) ===== */
.missions-header{
  width:min(720px, 92vw);
  margin:10px auto 6px !important;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:8px;
  flex-wrap:wrap;
}
.missions-header h3{
  margin:0 !important;
  font-family:'Press Start 2P', monospace;
  font-size:13px;
  line-height:1.2;
}
#missionsSortBtn{
  padding:4px 8px !important;
  font-size:10px !important;
  margin:0 !important;
  border-radius:10px;
  border:1px solid rgba(255,255,255,0.75);
  background:linear-gradient(180deg, rgba(230,230,230,0.95), rgba(150,150,150,0.95));
  color:#111;
  box-shadow:0 0 12px rgba(192,192,192,0.18);
}
#missionsSortBtn:hover{filter:brightness(1.06);transform:translateY(-1px);}
#missionsSortBtn:active{filter:brightness(0.98);transform:translateY(0px);}

.mission{
  display:flex;
  justify-content:space-between;
  gap:10px;
  align-items:center;
  padding:9px 10px;
  border-radius:14px;
  border:1px solid rgba(255,255,255,0.30);
  background:rgba(0,0,0,0.22);
}
.mission .m-left{display:flex;flex-direction:column;gap:6px;}
.mission .m-title{font-family:'Press Start 2P', monospace;font-size:10px;color:#fff;line-height:1.35;}
.mission .m-progress{font-family:'Press Start 2P', monospace;font-size:9px;color:#cfd8dc;}
.mission .m-barwrap{
  width:260px; max-width:40vw;
  height:10px; border-radius:999px;
  overflow:hidden;
  border:1px solid rgba(255,255,255,0.25);
  background:rgba(0,0,0,0.35);
}
.mission .m-bar{
  height:100%;
  width:0%;
  background:linear-gradient(90deg, rgba(120,144,156,0.95), rgba(0,188,212,0.95));
  transition:width 260ms ease;
}
.mission .claim-btn{
  font-family:'Press Start 2P', monospace;
  font-size:9px;
  padding:8px 9px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,0.35);
  background:rgba(255,255,255,0.08);
  color:#b0bec5;
  cursor:not-allowed;
  min-width:124px;
}
.mission .claim-btn.ready{
  cursor:pointer;
  background:linear-gradient(180deg, rgba(46,204,113,0.95), rgba(39,174,96,0.95));
  border:1px solid rgba(46,204,113,0.90);
  color:#06110a;
  box-shadow:0 0 18px rgba(46,204,113,0.25);
}
.mission .claim-btn.claimed{
  cursor:default;
  background:rgba(76,175,80,0.18);
  border:1px solid rgba(76,175,80,0.45);
  color:#a5d6a7;
}

.xp-fly{
  position:fixed;
  z-index:99999;
  padding:10px 14px;
  border-radius:12px;
  background:rgba(0,0,0,0.75);
  border:1px solid rgba(255,255,255,0.25);
  color:#fff;
  font-family:'Press Start 2P', monospace;
  font-size:12px;
  pointer-events:none;
  will-change:transform,left,top,opacity;
  transition: left 520ms ease-in, top 520ms ease-in, transform 520ms ease-in, opacity 520ms ease-in;
  box-shadow:0 10px 25px rgba(0,0,0,0.35);
}
.xp-fly.go{
  opacity:0.1;
  transform:translate(-50%,-50%) scale(0.35);
}

.xp-float{
  position:fixed;
  left:50%;
  top:18%;
  transform:translateX(-50%);
  font-family:'Press Start 2P', monospace;
  font-size:14px;
  color:#ffd54f;
  text-shadow:0 0 12px rgba(255,213,79,0.45);
  pointer-events:none;
  animation:xpPop 650ms ease forwards;
  z-index:9999;
}
@keyframes xpPop{
  0%{opacity:0; transform:translateX(-50%) translateY(10px) scale(0.96);}
  15%{opacity:1;}
  100%{opacity:0; transform:translateX(-50%) translateY(-24px) scale(1.06);}
}


/* ===== LEVEL UP ANIMATION ===== */
#levelUpOverlay{
  position:fixed;
  inset:0;
  display:none;
  align-items:center;
  justify-content:center;
  background:rgba(0,0,0,0.55);
  z-index:99999;
}
#levelUpOverlay.show{
  display:flex;
  animation:luFade 900ms ease forwards;
}
#levelUpOverlay .lu-card{
  width:min(520px, 92vw);
  padding:22px 18px;
  border-radius:18px;
  border:2px solid rgba(255,255,255,0.65);
  background:radial-gradient(circle at 30% 20%, rgba(255,235,59,0.22), rgba(0,0,0,0.65));
  box-shadow:0 0 28px rgba(255,235,59,0.22), 0 0 60px rgba(0,188,212,0.12);
  text-align:center;
  transform:scale(0.86);
  animation:luPop 900ms ease forwards;
}
#levelUpOverlay .lu-title{
  font-family:'Press Start 2P', monospace;
  font-size:24px;
  letter-spacing:2px;
  color:#fff;
  text-shadow:0 0 18px rgba(255,255,255,0.35);
  margin-bottom:10px;
}
#levelUpOverlay .lu-sub{
  font-family:'Press Start 2P', monospace;
  font-size:11px;
  color:#cfd8dc;
}
#levelUpOverlay .lu-level{
  margin-top:14px;
  font-family:'Press Start 2P', monospace;
  font-size:44px;
  color:#ffd54f;
  text-shadow:0 0 22px rgba(255,213,79,0.45);
}
#levelUpOverlay::before{
  content:"";
  position:absolute;
  inset:-20%;
  background:conic-gradient(from 90deg, rgba(255,235,59,0.0), rgba(255,235,59,0.35), rgba(0,188,212,0.25), rgba(255,235,59,0.0));
  filter:blur(10px);
  animation:luSpin 900ms linear forwards;
  opacity:0.9;
}
@keyframes luPop{
  0%{transform:scale(0.70) translateY(10px); opacity:0;}
  20%{opacity:1;}
  60%{transform:scale(1.05) translateY(-6px);}
  100%{transform:scale(0.98) translateY(-10px); opacity:1;}
}
@keyframes luFade{
  0%{opacity:0;}
  12%{opacity:1;}
  100%{opacity:0;}
}
@keyframes luSpin{
  0%{transform:rotate(0deg) scale(1.0);}
  100%{transform:rotate(320deg) scale(1.15);}
}


/* ===== Account Menu Compact + Scroll ===== */
#accountMenu{
  max-width: 760px;
  padding-top: 14px !important;
  padding-bottom: 14px !important;
}
#accountMenu h2{
  font-size: 20px !important;
  margin-bottom: 4px !important;
}
#accountMenu p{
  font-size: 13px !important;
}
#accountMenu h3{
  font-size: 15px !important;
  margin: 10px 0 6px !important;
}
#accountMenu .account-panel{
  width: min(560px, 90vw) !important;
  padding: 10px 12px !important;
}
#accountMenu .account-lv{ font-size: 14px !important; }
#accountMenu .account-xptext{ font-size: 10px !important; }
#accountMenu .xpbar-wrap{ height: 14px !important; margin-top: 8px !important; }

#accountMenu .missions-list{
  width: min(560px, 90vw) !important;
  max-height: 320px;
  overflow-y: auto;
  padding-right: 6px; /* spazio scrollbar */
}
#accountMenu .missions-list::-webkit-scrollbar{ width: 8px; }
#accountMenu .missions-list::-webkit-scrollbar-thumb{
  background: rgba(255,255,255,0.22);
  border-radius: 999px;
}
#accountMenu .missions-list::-webkit-scrollbar-track{
  background: rgba(0,0,0,0.18);
  border-radius: 999px;
}
#accountMenu .mission{
  padding: 8px 10px !important;
}
#accountMenu .mission .m-title{ font-size: 10px !important; }
#accountMenu .mission .m-progress{ font-size: 9px !important; }
#accountMenu .mission .m-barwrap{ height: 10px !important; }
#accountMenu .mission .claim-btn{
  font-size: 9px !important;
  padding: 9px 9px !important;
  min-width: 128px !important;
}


/* ===== Mission Difficulty Badge ===== */
.mission-mid{
  margin-left:6px;
  padding:2px 6px;
  border-radius:999px;
  font-family:'Press Start 2P', monospace;
  font-size:8px;
  background:rgba(255,235,59,0.18);
  border:1px solid rgba(255,235,59,0.7);
  color:#ffeb3b;
  text-shadow:0 0 6px rgba(255,235,59,0.4);
}


/* ===== Mission Easy Badge ===== */
.mission-easy{
  margin-left:6px;
  padding:2px 6px;
  border-radius:999px;
  font-family:'Press Start 2P', monospace;
  font-size:8px;
  background:rgba(46,204,113,0.18);
  border:1px solid rgba(46,204,113,0.75);
  color:#2ecc71;
  text-shadow:0 0 6px rgba(46,204,113,0.35);
}


/* ===== Mission Difficulty Badge (HARD) ===== */
.mission-hard{
  margin-left:6px;
  padding:2px 6px;
  border-radius:999px;
  font-family:'Press Start 2P', monospace;
  font-size:8px;
  background:rgba(244,67,54,0.18);
  border:1px solid rgba(244,67,54,0.75);
  color:#ff5252;
  text-shadow:0 0 6px rgba(244,67,54,0.35);
}



/* ===== Mission Base Badge ===== */
.mission-base{
  margin-left:6px;
  padding:2px 6px;
  border-radius:999px;
  font-family:'Press Start 2P', monospace;
  font-size:8px;
  background:rgba(189,189,189,0.16);
  border:1px solid rgba(189,189,189,0.70);
  color:#bdbdbd;
  text-shadow:0 0 6px rgba(189,189,189,0.25);
}

/* ===== TOTAL SCORE HIGHLIGHT ===== */
.total-score,
#totalScore,
.score-total{
  font-size: 28px !important;
  font-weight: bold;
  letter-spacing: 1px;
  color: #00e5ff;
  text-shadow: 0 0 10px rgba(0,229,255,0.7), 0 0 18px rgba(0,229,255,0.5);
  margin-bottom: 10px;
  z-index: 5;
  position: relative;
}


/* ===== TOTAL SCORE FOREGROUND LAYER ===== */
.total-score,
#totalScore,
.score-total{
  position: fixed !important;
  bottom: 12px;
  right: 14px;
  z-index: 9999;
  font-size: 26px !important;
  font-weight: bold;
  color:#00e5ff;
  text-shadow:0 0 10px rgba(0,229,255,.8),0 0 18px rgba(0,229,255,.6);
  pointer-events:none;
}


/* ===== TOTAL SCORE REALLY FOREGROUND (HUD) ===== */
#totalScoreDisplay{
  position:fixed !important;
  bottom:10px !important;
  right:12px !important;
  z-index:999999 !important;
  font-size:16px !important;
  opacity:1 !important;
  color:#ffd54f !important;
  text-shadow:0 0 10px rgba(255,213,79,0.75), 1px 1px 2px #000 !important;
  pointer-events:none !important;
}


/* ===== MENU COMPACT HEIGHT ===== */
.menu-container,
#mainMenu,
.menu{
  max-height: 75vh !important;
  padding-top: 20px !important;
  padding-bottom: 20px !important;
  overflow: hidden !important;
}


/* ===== TOTAL SCORE BOTTOM CENTER ===== */
#totalScoreDisplay{
  position: fixed !important;
  bottom: 12px !important;
  left: 50% !important;
  transform: translateX(-50%) !important;
  right: auto !important;
  z-index: 999999 !important;
  font-size: 18px !important;
  opacity: 1 !important;
  color:#ffd54f !important;
  text-shadow:0 0 12px rgba(255,213,79,0.8), 1px 1px 2px #000 !important;
  pointer-events:none !important;
}


/* ===== MENU SLIGHTLY EXPANDED ===== */
.menu-container,
#mainMenu,
.menu{
  max-height: 85vh !important;
  padding-top: 26px !important;
  padding-bottom: 26px !important;
}


/* ===== MENU REPROPORTION + LIFT BOTTOM BUTTONS ===== */
#mainMenu.menu,
#mainMenu,
.menu{
  max-height: 88vh !important;
  padding-top: 24px !important;
  padding-bottom: 18px !important;
  overflow: visible !important; /* evita tagli sui bottoni */
}

/* Alza INIZIA BATTAGLIA */
.start-row{
  margin-top: 6px !important;
  position: relative;
  top: -10px;
}

/* Alza i pulsanti Guida e Bestiario */
#guideImgBtn,
#enemyGuideImgBtn{
  position: relative;
  top: -10px;
}

/* Riduci un filo lo spazio sotto la selezione personaggi */
.character-select{ margin-bottom: 6px !important; }


/* ===== Mission Difficulty Badge (MYTHIC) ===== */
.mission-mythic{
  margin-left:6px;
  padding:2px 7px;
  border-radius:999px;
  font-family:'Press Start 2P', monospace;
  font-size:8px;
  background:linear-gradient(135deg,#e5f7ff,#b9f2ff,#e5f7ff);
  border:1px solid #b9f2ff;
  color:#eafcff;
  text-shadow:0 0 10px rgba(185,242,255,0.9),0 0 18px rgba(185,242,255,0.6);
  box-shadow:0 0 12px rgba(185,242,255,0.6);
}


    
    .timer-wrap{position:absolute;top:18px;left:50%;transform:translateX(-50%);display:none;align-items:center;gap:10px;z-index:10}
    .timer-wrap .timer{position:static;top:auto;left:auto;transform:none}

    /* Pausa (coerente con UI pixel/menu) */
    .pause-btn{
      padding:6px 10px;
      border:3px solid #fff;
      border-radius:10px;
      background:rgba(0,0,0,0.20);
      color:#fff;
      font-family:'Press Start 2P', cursive;
      font-size:12px;
      line-height:1;
      cursor:pointer;
      box-shadow:0 4px 0 rgba(0,0,0,0.55);
    }
    .pause-btn:active{transform:translateY(2px);box-shadow:0 2px 0 rgba(0,0,0,0.55)}

    #pauseOverlay{
      position:absolute;inset:0;
      display:none;
      align-items:center;justify-content:center;
      background:rgba(0,0,0,0.55);
      z-index:9999;
      font-family:'Press Start 2P', cursive;
    }
    #pauseBox{
      min-width:260px;
      max-width:360px;
      padding:18px 20px 16px;
      border:4px solid #fff;
      background:rgba(0,0,0,0.85);
      text-align:center;
      box-shadow:0 10px 30px rgba(0,0,0,0.55);
    }
    #pauseBox .pause-title{
      font-size:16px;
      margin-bottom:14px;
      color:#fff;
      letter-spacing:1px;
    }
    #pauseBox .pause-actions{display:flex;gap:12px;justify-content:center}
    #pauseBox button{
      flex:1;
      padding:10px 10px;
      border:3px solid #fff;
      background:rgba(0,0,0,0.20);
      color:#fff;
      font-family:'Press Start 2P', cursive;
      font-size:10px;
      cursor:pointer;
      box-shadow:0 4px 0 rgba(0,0,0,0.55);
    }
    #pauseBox button:active{transform:translateY(2px);box-shadow:0 2px 0 rgba(0,0,0,0.55)}



.character-btn.bronze{border:4px solid #cd7f32 !important;box-shadow:0 0 12px #cd7f32aa;}

.bronzeBorder{border:4px solid #cd7f32 !important;box-shadow:0 0 12px #cd7f32aa !important;}

.silverBorder{border:4px solid #c0c0c0 !important;box-shadow:0 0 14px #c0c0c0aa !important;}

.goldBorder{border:4px solid #ffd700 !important;box-shadow:0 0 16px #ffd700aa !important;}
</style>

<!-- Injected CSS: compact grid selected state -->
<style id="injected-compact-select-style">
.char-grid button.selected{
  border-color:#ff9800 !important;
  box-shadow:
    0 0 8px #ff9800,
    0 0 16px #ff9800,
    0 0 28px rgba(255,152,0,0.9),
    inset 0 0 12px rgba(255,152,0,0.35);
  background: linear-gradient(180deg,#2b1a00,#3a2200);
  color:#fff;
  transform: scale(1.03);
  transition: all 0.12s ease;
}
.char-grid button.selected:focus{
  outline: 3px solid rgba(255,152,0,0.18);
}

.character-btn.bronze{border:4px solid #cd7f32 !important;box-shadow:0 0 12px #cd7f32aa;}

.bronzeBorder{border:4px solid #cd7f32 !important;box-shadow:0 0 12px #cd7f32aa !important;}

.silverBorder{border:4px solid #c0c0c0 !important;box-shadow:0 0 14px #c0c0c0aa !important;}

.goldBorder{border:4px solid #ffd700 !important;box-shadow:0 0 16px #ffd700aa !important;}
</style>


<!-- === LOCKED COMPACT BUTTON STYLE PATCH (added) === -->
<style id="locked-compact-style">
/* locked/disabled compact buttons */
.char-grid button.locked{
  background:#2a2a2a !important;
  border-color:#444 !important;
  color:#888 !important;
  opacity:0.45;
  cursor:not-allowed;
  box-shadow:none !important;
  transform:none !important;
}

/* no hover glow */
.char-grid button.locked:hover{
  border-color:#444 !important;
  box-shadow:none !important;
}

/* prevent orange glow even if .selected accidentally added */
.char-grid button.locked.selected{
  border-color:#444 !important;
  background:#2a2a2a !important;
  box-shadow:none !important;
  transform:none !important;
}

.character-btn.bronze{border:4px solid #cd7f32 !important;box-shadow:0 0 12px #cd7f32aa;}

.bronzeBorder{border:4px solid #cd7f32 !important;box-shadow:0 0 12px #cd7f32aa !important;}

.silverBorder{border:4px solid #c0c0c0 !important;box-shadow:0 0 14px #c0c0c0aa !important;}

.goldBorder{border:4px solid #ffd700 !important;box-shadow:0 0 16px #ffd700aa !important;}
</style>


<style>
/* AUTO-SELECTED HIGHLIGHT */
.char-grid button.selected, .character-card.selected {
  outline: 3px solid transparent;
  box-shadow: 0 0 0 3px rgba(255,165,0,0.15), 0 0 8px rgba(255,165,0,0.2);
  background: linear-gradient(180deg, rgba(255,200,120,0.12), rgba(255,165,0,0.04));
  border-color: #ff8c00;
}
.char-grid button.selected {
  background-color: #fff7ef;
}

.character-btn.bronze{border:4px solid #cd7f32 !important;box-shadow:0 0 12px #cd7f32aa;}

.bronzeBorder{border:4px solid #cd7f32 !important;box-shadow:0 0 12px #cd7f32aa !important;}

.silverBorder{border:4px solid #c0c0c0 !important;box-shadow:0 0 14px #c0c0c0aa !important;}

.goldBorder{border:4px solid #ffd700 !important;box-shadow:0 0 16px #ffd700aa !important;}
</style>


<style id="ether-info-style">
/* ===== Etere Info Popup ===== */
#etherInfoModal{ display:none; }
#etherInfoModal.show{ display:flex; }
#etherInfoModal .guide-modal-content{
  max-width:560px;
  width: min(560px, 92vw);
  border-radius:16px;
}
#etherInfoModal .ether-title{
  font-family:'Press Start 2P', cursive;
  font-size:16px;
  color:#7fffd4;
  text-shadow:1px 1px 2px #000;
  margin-bottom:10px;
}
#etherInfoModal .ether-body{
  font-family:'VT323', monospace;
  font-size:18px;
  line-height:1.5;
  color:#ddd;
}
#etherInfoModal .ether-body ul{ margin:10px 0 0 18px; }
#etherInfoModal .ether-body li{ margin:6px 0; }
</style>

<style id="total-score-info-style">
#totalScoreDisplay{
  pointer-events:auto !important;
  cursor:pointer !important;
}
#totalScoreDisplay:hover{ filter:brightness(1.08); }

#totalScoreInfoModal{ display:none; }
#totalScoreInfoModal.show{ display:flex; }
#totalScoreInfoModal .guide-modal-content{
  max-width:560px;
  width: min(560px, 92vw);
  border-radius:16px;
}
#totalScoreInfoModal .ts-title{
  font-family:'Press Start 2P', cursive;
  font-size:14px;
  color:#ffd54f;
  text-shadow:1px 1px 2px #000;
  margin-bottom:10px;
}
#totalScoreInfoModal .ts-body{
  font-family:'VT323', monospace;
  font-size:18px;
  line-height:1.5;
  color:#ddd;
}
#totalScoreInfoModal .ts-body ul{ margin:10px 0 0 18px; }
#totalScoreInfoModal .ts-body li{ margin:6px 0; }
</style>

<style id="cosmo-buy-style-patch">
#cosmoShopBuyBtn{
  background:linear-gradient(180deg,#2ecc71,#27ae60);
  border:2px solid #2ecc71;
  color:#06110a;
}
#cosmoShopBuyBtn.disabled{
  background:#555 !important;
  border:2px solid #777 !important;
  color:#ccc !important;
  cursor:not-allowed !important;
  box-shadow:none !important;
  filter:grayscale(0.4);
}
</style>




<style id="account-menu-layout-fix">
/* === ACCOUNT MENU: keep "Torna al Menu" always inside, without breaking open/close === */
#accountMenu{
  max-height: 82vh !important;
  overflow: hidden !important;
  padding-bottom: 14px !important;
}

/* Only when JS sets display to block, apply flex layout */
#accountMenu[style*="display:block"], 
#accountMenu[style*="display: block"]{
  display:flex !important;
  flex-direction:column !important;
}

/* allow the internal content to scroll instead of pushing the back button out */
#accountMenu .missions-list{
  flex: 1 1 auto !important;
  max-height: none !important;
  overflow-y: auto !important;
  padding-bottom: 84px !important; /* room for sticky button */
}

/* keep the back button visible inside the panel */
#accountMenu #accountBackBtn{
  position: sticky !important;
  bottom: 12px !important;
  z-index: 30 !important;
}

/* slightly re-proportion typography inside account menu for small screens */
@media (max-width: 900px){
  #accountMenu{ max-height: 84vh !important; padding-top: 12px !important; }
  #accountMenu h2{ font-size: 18px !important; }
  #accountMenu .account-panel{ width: min(520px, 92vw) !important; }
  #accountMenu .mission .m-barwrap{ max-width: 52vw !important; }
}
</style>




<style id="platinum-border-style">
/* ===== PLATINUM BORDER (record >= 150.000) ===== */
.platinumBorder{
  border:4px solid #e5f7ff !important;
  box-shadow:
    0 0 10px rgba(229,247,255,0.75),
    0 0 18px rgba(185,242,255,0.70),
    0 0 28px rgba(120,220,255,0.55),
    inset 0 0 12px rgba(255,255,255,0.18) !important;
  background:linear-gradient(180deg, rgba(255,255,255,0.10), rgba(0,0,0,0.05));
}
.char-grid button.platinumBorder:hover{
  filter:brightness(1.05);
}
</style>

<style id="menu-top-left-buttons-style">
/* ===== MAIN MENU: top-left back + settings ===== */
#mainMenu{ position:absolute; } /* ensure absolute children anchor correctly */

.menu-top-left{
  position:absolute;
  top:18px;   /* allineato all'HUD dei Frammenti d'Etere */
  left:18px;
  display:none; /* appare solo quando il menu √® attivo */
  gap:10px;
  z-index:25;
}

.menu-top-left .menu-icon-btn{
  width:48px;
  height:48px;
  border-radius:12px;
  border:3px solid rgba(255,255,255,0.85);
  font-family:'Press Start 2P', cursive;
  font-size:20px;
  line-height:1;
  display:flex;
  align-items:center;
  justify-content:center;
  cursor:pointer;
  user-select:none;
  box-shadow:0 6px 0 rgba(0,0,0,0.55), 0 0 16px rgba(255,255,255,0.10);
}

#menuBackBtn{
  background:linear-gradient(180deg, rgba(231,76,60,0.98), rgba(192,57,43,0.98));
  border-color:rgba(231,76,60,0.95);
  color:#130202;
}

#menuSettingsBtn{
  background:linear-gradient(180deg, rgba(220,220,220,0.96), rgba(140,140,140,0.96));
  border-color:rgba(255,255,255,0.85);
  color:#111;
}

.menu-top-left .menu-icon-btn:hover{
  transform:translateY(-1px);
  filter:brightness(1.04);
}
.menu-top-left .menu-icon-btn:active{
  transform:translateY(3px);
  box-shadow:0 3px 0 rgba(0,0,0,0.55), 0 0 14px rgba(255,255,255,0.08);
}

/* Settings modal (small) */
#menuSettingsModal{ display:none; }
#menuSettingsModal.show{ display:flex; }
#menuSettingsModal .guide-modal-content{
  max-width:560px;
  width:min(560px,92vw);
  border-radius:16px;
}
#menuSettingsModal .ms-title{
  font-family:'Press Start 2P', cursive;
  font-size:14px;
  color:#cfd8dc;
  text-shadow:1px 1px 2px #000;
  margin-bottom:10px;
}
#menuSettingsModal .ms-body{
  font-family:'VT323', monospace;
  font-size:18px;
  line-height:1.55;
  color:#ddd;
}
#menuSettingsModal .ms-body ul{ margin:10px 0 0 18px; }
#menuSettingsModal .ms-body li{ margin:6px 0; }
#menuSettingsModal .ms-k{
  display:inline-block;
  min-width:86px;
  padding:2px 8px;
  border-radius:10px;
  border:1px solid rgba(255,255,255,0.28);
  background:rgba(0,0,0,0.28);
  color:#fff;
  font-family:'Press Start 2P', monospace;
  font-size:10px;
  margin-right:8px;
}
</style>

</head>


<body>
<div id="bgDefault"></div>
<div id="bgDark"></div>
<div id="fadeOverlay"></div>
<div id="gameContainer">
<canvas height="780" id="gameCanvas" width="1320"></canvas>

<div id="totalScoreDisplay" style="
  position:absolute;
  bottom:10px;
  right:12px;
  z-index:15;
  font-size:12px;
  opacity:0.85;
  color:#f1c40f;
  text-shadow:1px 1px 2px #000;
  font-family:'Press Start 2P', cursive;
  pointer-events:none;
">
PUNTEGGIO TOTALE: 0
</div>
<!-- Total Score Info Modal -->
<div class="guide-modal" id="totalScoreInfoModal" aria-hidden="true">
  <div class="guide-modal-content" role="dialog" aria-modal="true" aria-labelledby="totalScoreInfoTitle">
    <button class="guide-close" id="totalScoreInfoCloseBtn" type="button" aria-label="Chiudi">‚úï</button>
    <div class="ts-title" id="totalScoreInfoTitle">PUNTEGGIO TOTALE</div>
    <div class="ts-body">
      <div>Il <b>Punteggio Totale</b> √® la somma dei tuoi <b>record</b> ottenuti con tutti i personaggi.</div>
      <ul>
        <li>Aumenta quando migliori i record personali dei personaggi.</li>
        <li>Rappresenta la <b>forza</b> e la <b>bravura</b> complessiva del tuo account.</li>
      </ul>
    </div>
  </div>
</div>


<div class="ui-overlay" id="uiOverlay" style="display:none;">
<div>HP: <span id="hpText">100</span></div>
<div class="hp-bar"><div class="hp-fill" id="hpFill" style="width:100%"></div></div>
<div id="superCooldown" style="margin-top:6px;font-size:12px;color:#fff;font-family:'Press Start 2P', cursive;;color:#ff9800;">Super: Ready</div>
<div id="bonusTimers" style="margin-top:4px;font-size:11px;line-height:1.4;color:#fff;font-family:'Press Start 2P', cursive;display:none;"></div>




</div>


<div id="etherHud" style="position:absolute;top:18px;right:18px;z-index:20;display:flex;align-items:center;gap:10px;
font-family:'Press Start 2P', cursive;color:#7fffd4;text-shadow:1px 1px 2px #000;">
<img id="etherHudIcon" src="https://i.postimg.cc/Ss8ZVQGy/9728424b-a5a4-42fd-84d0-b644c6a22ae4.png"
style="width:56px;height:56px;image-rendering:pixelated;display:block;">
<span id="etherCount" style="font-size:28px;">0</span>
</div>

<div class="menu-top-left" id="menuTopLeft" aria-hidden="true">
  <button class="menu-icon-btn" id="menuBackBtn" type="button" title="Torna alla selezione difficolt√†">
<svg width="18" height="18" viewBox="0 0 24 24" fill="#000000" xmlns="http://www.w3.org/2000/svg">
  <path d="M15 6L9 12L15 18" stroke="#000000" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
</button>
  <button class="menu-icon-btn" id="menuSettingsBtn" type="button" title="Impostazioni / Comandi">‚öôÔ∏è</button>
</div>


<!-- Etere Info Modal -->
<div class="guide-modal" id="etherInfoModal" aria-hidden="true">
  <div class="guide-modal-content" role="dialog" aria-modal="true" aria-labelledby="etherInfoTitle">
    <button class="guide-close" id="etherInfoCloseBtn" type="button" aria-label="Chiudi">‚úï</button>
    <div class="ether-title" id="etherInfoTitle">FRAMMENTI D'ETERE</div>
    <div class="ether-body">
      <div>I Frammenti d'Etere si ottengono e si riscattano in due modi:</div>
      <ul>
        <li><b>Salendo di livello</b>: alcune tappe della Road danno Frammenti d'Etere riscattabili.</li>
        <li><b>Record dei personaggi</b>: quando superi certe soglie di record (es. 50k / 75k / 100k) ricevi un bonus di Frammenti d'Etere <b>una sola volta per personaggio</b>.</li>
      </ul>
      <div style="margin-top:10px; opacity:0.95;">Apri il menu Account/Road per riscattare le ricompense quando disponibili.</div>
    </div>
  </div>
</div>

<!-- Cosmo Shop Modal -->
<div class="guide-modal" id="cosmoShopModal" aria-hidden="true" style="display:none;">
  <div class="guide-modal-content" role="dialog" aria-modal="true" aria-labelledby="cosmoShopTitle" style="max-width:560px;width:min(560px,92vw);border-radius:16px;">
    <button class="guide-close" id="cosmoShopCloseBtn" type="button" aria-label="Chiudi">‚úï</button>
    <div class="ether-title" id="cosmoShopTitle" style="color:#7fffd4;">COSMO üåÄ</div>
    <div class="ether-body" style="font-size:18px;">
      <div style="margin-bottom:10px;">Acquista <b>Cosmo</b> per <b>1000</b> Frammenti d'Etere.</div>
      <div style="display:flex;gap:10px;justify-content:center;flex-wrap:wrap;margin-top:14px;">
        <button class="btn btn-mini" id="cosmoShopBuyBtn" type="button">COMPRA (1000)</button>
        <button class="btn btn-mini" id="cosmoShopOkBtn" type="button" style="background:#555;">OK</button>
      </div>
      <div id="cosmoShopHint" style="margin-top:12px;opacity:0.9;color:#ddd;"></div>
    </div>
  </div>
</div>




<!-- Menu Settings Modal -->
<div class="guide-modal" id="menuSettingsModal" aria-hidden="true" style="display:none;">
  <div class="guide-modal-content" role="dialog" aria-modal="true" aria-labelledby="menuSettingsTitle">
    <button class="guide-close" id="menuSettingsCloseBtn" type="button" aria-label="Chiudi">‚úï</button>
    <div class="ms-title" id="menuSettingsTitle">IMPOSTAZIONI ‚Ä¢ COMANDI</div>
    <div class="ms-body">
      <div style="opacity:0.95;">Tasti principali:</div>
      <ul>
        <li><span class="ms-k">W A S D</span>Muoversi</li>
        <li><span class="ms-k">J</span>Attacco base</li>
        <li><span class="ms-k">K</span>Super</li>
        <li><span class="ms-k">SPAZIO</span>Dash / Schivata</li>
        <li><span class="ms-k">ESC</span>Metti in pausa / Riprendi</li>
        <li><span class="ms-k">H</span>Metti in pausa / Riprendi (alternativo)</li>
      </ul>
      <div style="margin-top:10px;opacity:0.9;">In partita puoi anche usare il pulsante ‚è∏ accanto al timer.</div>
    </div>
  </div>
</div>

<div class="score" id="scoreDisplay" style="display:none;">Score: 0</div>
<div class="score" id="killsDisplay" style="display:none; top:52px;">Kill: 0</div>
<div class="timer-wrap" id="timerWrap" style="display:none;"><div class="timer" id="timerDisplay">45</div><button class="pause-btn" id="pauseBtn" title="Pausa">‚è∏</button></div>
<div class="level-indicator" id="levelDisplay" style="display:none;">Level 1</div>

<div class="evo-banner" id="evoBanner" style="display:none;">
<div id="evoBannerText">EVOLUTO!</div>
</div>
<div class="menu" id="startScreen">
  <h1>
<span style="
display:inline-flex;
align-items:center;
gap:14px;
white-space:nowrap;
">
<img src="https://i.postimg.cc/prCMGdLH/unnamed-(1).png"
style="height:1.9em;display:block;image-rendering:pixelated;">
<span style="display:inline-block;">JEFF‚ÄôS CHRONICLES</span>
<img src="https://i.postimg.cc/prCMGdLH/unnamed-(1).png"
style="height:1.9em;display:block;image-rendering:pixelated;">
</span>
</h1>
  <h2>Scegli la modalit√†</h2>
  <p style="margin-top:10px;font-size:15px;color:#ddd;line-height:1.4;">
    <strong>Difficile</strong>: gioco originale.<br>
    <strong>Facile</strong>: cure tra i livelli (+25% ogni livello, <em>cura totale</em> ogni 5¬∞ livello), nemici pi√π lenti e danni inflitti dai nemici ridotti ma <em>punteggio dimezzato</em>.
  </p>
  <div class="start-row" style="margin-top:18px;flex-wrap:wrap;">
    <button class="btn" id="modeHardBtn" type="button">MODALIT√Ä DIFFICILE</button>
    <button class="btn" id="modeEasyBtn" type="button">MODALIT√Ä FACILE</button>
  </div>
</div>

<div class="menu" id="mainMenu" style="display:none;">
<h1>
<span style="
display:inline-flex;
align-items:center;
gap:14px;
white-space:nowrap;
">
<img src="https://i.postimg.cc/prCMGdLH/unnamed-(1).png"
style="height:1.9em;display:block;image-rendering:pixelated;">
<span style="display:inline-block;">JEFF‚ÄôS CHRONICLES</span>
<img src="https://i.postimg.cc/prCMGdLH/unnamed-(1).png"
style="height:1.9em;display:block;image-rendering:pixelated;">
</span>
</h1>
<h2>Seleziona il tuo combattente</h2>

<div class="compact-selector">
  <div class="char-grid"><button data-target="jimmy">JIMMY üî´<br><small class="btn-record" id="btnrec-jimmy">R: 0</small></button>
    <button data-target="rooney">ROONEY üê±<br><small class="btn-record" id="btnrec-rooney">R: 0</small></button>
    <button data-target="jeff">JEFF üó°Ô∏è<br><small class="btn-record" id="btnrec-jeff">R: 0</small></button>
    <button data-target="voltryx">VOLTRYX ü¶ä<br><small class="btn-record" id="btnrec-voltryx">R: 0</small></button>
    <button data-target="kouvagia">KOUVAGIA ü¶â<br><small class="btn-record" id="btnrec-kouvagia">R: 0</small></button>
    <button data-target="salsy">SALSY ‚öúÔ∏è<br><small class="btn-record" id="btnrec-salsy">R: 0</small></button>
    <button data-target="tempostorm">TEMPOSTORM üîã<br><small class="btn-record" id="btnrec-tempostorm">R: 0</small></button>
    <button data-target="marz">MARZ ü™Ñ<br><small class="btn-record" id="btnrec-marz">R: 0</small></button>
    <button data-target="hecate">H√àCATE üåò<br><small class="btn-record" id="btnrec-hecate">R: 0</small></button>
    <button data-target="marcus">MARCUS üé∂<br><small class="btn-record" id="btnrec-marcus">R: 0</small></button>
    <button data-target="lucien">LUCIEN üó∫Ô∏è<br><small class="btn-record" id="btnrec-lucien">R: 0</small></button>
    <button data-target="pdor">PDOR ‚ù§Ô∏è‚Äçüî•<br><small class="btn-record" id="btnrec-pdor">R: 0</small></button>
<button data-target="bane">BANE ü™ì<br><small class="btn-record" id="btnrec-bane">R: 0</small></button>
<button data-target="hendel">HENDEL ü™®<br><small class="btn-record" id="btnrec-hendel">R: 0</small></button>
<button data-target="kaerith">KAERITH üêâ<br><small class="btn-record" id="btnrec-kaerith">R: 0</small></button>
<button data-target="cosmo">COSMO üåÄ<br><small class="btn-record" id="btnrec-cosmo">R: 0</small></button> </div>
</div>
<div class="character-select">
<div class="character-card" data-char="jimmy" id="card-jimmy">
<h3>JIMMY</h3>
<p>"üî´"</p>
<div class="menu-stats"><span class="stat" id="menu-hp-jimmy">100 XP</span><span class="spacer"> </span><span class="stat" id="menu-dmg-jimmy">100 XP</span></div>
<div class="record-badge" id="record-jimmy">Record: 0</div>
</div>
<div class="character-card" data-char="rooney" id="card-rooney">
<h3>ROONEY</h3>
<p>"üê±"</p>
<div class="menu-stats"><span class="stat" id="menu-hp-rooney">100 XP</span><span class="spacer"> </span><span class="stat" id="menu-dmg-rooney">100 XP</span></div>
<div class="record-badge" id="record-rooney">Record: 0</div>
</div>
<div class="character-card" data-char="jeff" id="card-jeff">
<h3>JEFF</h3>
<p>"üó°Ô∏è"</p>
<div class="menu-stats"><span class="stat" id="menu-hp-jeff">100 XP</span><span class="spacer"> </span><span class="stat" id="menu-dmg-jeff">100 XP</span></div>
<div class="record-badge" id="record-jeff">Record: 0</div>
</div>
<!-- Voltryx card (locked until all three records > 50000) -->
<div class="character-card disabled" data-char="voltryx" id="card-voltryx" title="Sblocca completando 45.000 punti con ogni personaggio">
<h3>VOLTRYX</h3>
<p>"ü¶ä"</p>
<div class="menu-stats"><span class="stat" id="menu-hp-voltryx">100 XP</span><span class="spacer"> </span><span class="stat" id="menu-dmg-voltryx">100 XP</span></div>
<div class="record-badge" id="record-voltryx">Record: 0</div>
<div class="lock-badge" id="voltryxLockBadge">LOCKED</div>
</div>
<!-- Kouvagia card (locked until 51.000 score with Voltryx) -->
<div class="character-card disabled" data-char="kouvagia" id="card-kouvagia" title="Sblocca facendo 51.000 punti con Voltryx">
<h3>KOUVAGIA</h3>
<p>"ü¶â"</p>
<div class="menu-stats"><span class="stat" id="menu-hp-kouvagia">100 XP</span><span class="spacer"> </span><span class="stat" id="menu-dmg-kouvagia">100 XP</span></div>
<div class="record-badge" id="record-kouvagia">Record: 0</div>
<div class="lock-badge" id="kouvagiaLockBadge">LOCKED</div>
</div>
<!-- Salsy card (locked until 60.000 score with Jimmy, Rooney, Jeff, Voltryx and Kouvagia) -->
<div class="character-card disabled" data-char="salsy" id="card-salsy" title="Sblocca facendo 60.000 punti con Jimmy, Rooney, Jeff, Voltryx e Kouvagia">
<h3>SALSY</h3>
<p>"‚öúÔ∏è"</p>
<div class="menu-stats"><span class="stat" id="menu-hp-salsy">100 XP</span><span class="spacer"> </span><span class="stat" id="menu-dmg-salsy">100 XP</span></div>
<div class="record-badge" id="record-salsy">Record: 0</div>
<div class="lock-badge" id="salsyLockBadge">LOCKED</div>
</div>
<!-- Altri personaggi (aperti con +) -->
<div class="character-select extra-characters" id="extraCharacterSelect" style="display:none;">
<!-- Tempostorm card (moved here as FIRST extra character) -->
<div class="character-card disabled" data-char="tempostorm" id="card-tempostorm" style="margin-right:8px;" title="Sblocca facendo 65.000 punti con tutti i personaggi precedenti (Jimmy, Rooney, Jeff, Voltryx, Kouvagia e Salsy)">
<h3>TEMPOSTORM</h3>
<p>"üîã"</p>
<div class="menu-stats"><span class="stat" id="menu-hp-tempostorm">100 XP</span><span class="spacer"> </span><span class="stat" id="menu-dmg-tempostorm">100 XP</span></div>
<div class="record-badge" id="record-tempostorm">Record: 0</div>
<div class="lock-badge" id="tempostormLockBadge">LOCKED</div>
</div>
<!-- Marz card (SECOND, to the right) -->
<div class="character-card disabled" data-char="marz" id="card-marz" title="Sblocca facendo 70.000 punti con tutti i personaggi precedenti (Jimmy, Rooney, Jeff, Voltryx, Kouvagia, Salsy e Tempostorm)">
<h3>MARZ</h3>
<p>"ü™Ñ"</p>
<div class="menu-stats"><span class="stat" id="menu-hp-marz">100 XP</span><span class="spacer"> </span><span class="stat" id="menu-dmg-marz">100 XP</span></div>
<div class="record-badge" id="record-marz">Record: 0</div>
<div class="lock-badge" id="marzLockBadge">LOCKED</div>
</div>
<!-- H√®cate card (locked until 75.000 score with all previous characters) -->
<div class="character-card disabled" data-char="hecate" id="card-hecate" title="Sblocca facendo 75.000 punti con tutti i personaggi precedenti (Jimmy, Rooney, Jeff, Voltryx, Kouvagia, Salsy, Tempostorm e Marz)">
<h3>H√àCATE</h3>
<p>"üåò"</p>
<div class="menu-stats"><span class="stat" id="menu-hp-hecate">100 XP</span><span class="spacer"> </span><span class="stat" id="menu-dmg-hecate">100 XP</span></div>
<div class="record-badge" id="record-hecate">Record: 0</div>
<div class="lock-badge" id="hecateLockBadge">LOCKED</div>
</div>



<!-- Marcus card (locked until at least one record >= 70.000) -->
<div class="character-card disabled" data-char="marcus" id="card-marcus" title="Sblocca facendo almeno 70.000 punti con QUALSIASI personaggio">
<h3>MARCUS</h3>
<p>"üé∂"</p>
<div class="menu-stats"><span class="stat" id="menu-hp-marcus">100 XP</span><span class="spacer"> </span><span class="stat" id="menu-dmg-marcus">100 XP</span></div>
<div class="record-badge" id="record-marcus">Record: 0</div>
<div class="lock-badge" id="marcusLockBadge">LOCKED</div>
</div>

<!-- Lucien card (locked until record Marcus > 25.000) -->
<div class="character-card disabled" data-char="lucien" id="card-lucien" title="Sblocca facendo pi√π di 25.000 punti con Marcus">
<h3>LUCIEN</h3>
<p>"üó∫Ô∏è"</p>
<div class="menu-stats"><span class="stat" id="menu-hp-lucien">100 XP</span><span class="spacer"> </span><span class="stat" id="menu-dmg-lucien">100 XP</span></div>

<!-- Pdor card (locked until record Marcus >= 50.000 AND Lucien >= 50.000) -->
<div class="character-card disabled" data-char="pdor" id="card-pdor" title="Sblocca facendo almeno 50.000 punti di record con Marcus e Lucien">
<h3>PDOR</h3>
<p>"‚ù§Ô∏è‚Äçüî•"</p>
<div class="menu-stats"><span class="stat" id="menu-hp-pdor">100 XP</span><span class="spacer"> </span><span class="stat" id="menu-dmg-pdor">100 XP</span></div>
<div class="record-badge" id="record-pdor">Record: 0</div>
<div class="lock-badge" id="pdorLockBadge">LOCKED</div>
</div>
<!-- Bane card (locked until record PDOR >= 50.000) -->
<div class="character-card disabled" data-char="bane" id="card-bane" title="Sblocca facendo almeno 50.000 punti di record con PDOR">
<h3>BANE</h3>
<p>"ü™ì"</p>
<div class="menu-stats"><span class="stat" id="menu-hp-bane">100 XP</span><span class="spacer"> </span><span class="stat" id="menu-dmg-bane">100 XP</span></div>
<div class="record-badge" id="record-bane">Record: 0</div>
<div class="lock-badge" id="baneLockBadge">LOCKED</div>
</div>
<div class="record-badge" id="record-lucien">Record: 0</div>
<div class="lock-badge" id="lucienLockBadge">LOCKED</div>
</div>

</div>
</div>
<div class="start-row">

<button class="btn" id="startBtn">INIZIA BATTAGLIA</button>
</div>
<!-- Hendel card (locked until record Bane >= 50.000) -->
<div class="character-card disabled" data-char="hendel" id="card-hendel" title="Sblocca facendo almeno 50.000 punti di record con Bane">
<h3>HENDEL</h3>
<p>"ü™®"</p>
<div class="menu-stats"><span class="stat" id="menu-hp-hendel">100 XP</span><span class="spacer"> </span><span class="stat" id="menu-dmg-hendel">100 XP</span></div>
<div class="record-badge" id="record-hendel">Record: 0</div>
<div class="lock-badge" id="hendelLockBadge">LOCKED</div>

<!-- Kaerith card (locked until record Hendel >= 40.000) -->
<div class="character-card disabled" data-char="kaerith" id="card-kaerith" title="Sblocca facendo 40.000 punti con Hendel">
<h3>KAERITH üêâ</h3>
<p>"üêâ"</p>
<div class="menu-stats"><span class="stat" id="menu-hp-kaerith">100 XP</span><span class="spacer"> </span><span class="stat" id="menu-dmg-kaerith">100 XP</span></div>
<div class="record-badge" id="record-kaerith">Record: 0</div>
<div class="lock-badge" id="kaerithLockBadge">LOCKED</div>

<!-- Cosmo card (locked: purchase with 1000 ether) -->
<div class="character-card disabled" data-char="cosmo" id="card-cosmo" title="Sblocca comprandolo con 1000 Frammenti d'Etere">
<h3>COSMO üåÄ</h3>
<p>"üåÄ"</p>
<div class="menu-stats"><span class="stat" id="menu-hp-cosmo">100 XP</span><span class="spacer"> </span><span class="stat" id="menu-dmg-cosmo">100 XP</span></div>
<div class="record-badge" id="record-cosmo">Record: 0</div>
<div class="lock-badge" id="cosmoLockBadge">LOCKED</div>
</div>

</div>

</div>

<!-- Pulsante immagine per aprire la guida -->
<button aria-label="Apri guida" class="img-btn" id="guideImgBtn" style="display:inline-block;" title="Apri guida" type="button">
<img alt="Guida" id="guideImg" src="https://i.postimg.cc/JztT9fJH/bea.png"/>
</button>
<!-- Pulsante immagine per aprire il bestiario (nemici + boss) -->
<button aria-label="Apri bestiario" class="img-btn" id="enemyGuideImgBtn" style="display:inline-block;" title="Bestiario (Nemici &amp; Boss)" type="button">
<img alt="Bestiario" id="enemyGuideImg" src="https://i.postimg.cc/NFVhJNLC/pixelcut-export-(2).png"/>
</button>

<!-- Account Level Button (bottom-left) -->
<button id="accountLevelBtn" type="button" class="account-level-btn" aria-label="Livello account" title="Livello account">
  <div class="alb-badge">LV</div>
  <div class="alb-level" id="accountLevelText">1</div>
  <div class="alb-xp" id="accountXpMini">0/100</div>
</button>

<!-- SKIN Button (bottom-right) -->
<button id="skinBtn" type="button" class="skin-btn" aria-label="Skin" title="Skin">
  <img class="skin-btn-img" alt="Skin" src="https://i.postimg.cc/3xZ4x8YB/285b2ef5-7936-474d-adf4-2a413673da6e.png"/>
  <div class="skin-btn-label">SKIN</div>
</button>




<p style="margin-top:-6px;font-size:14px;color:#ddd;text-align:center;max-width:420px;margin-left:auto;margin-right:auto;"><span style='display:block;text-align:center;line-height:1.4;'><span style='display:block;text-align:center;line-height:1.2;font-size:12px;letter-spacing:0.5px;'></span></span></p>
</div>

<!-- Account Level Screen -->
<div class="menu" id="accountMenu" style="display:none;">
  <h2 style="margin-bottom:6px;">üéñÔ∏è LIVELLO ACCOUNT</h2>
  <p style="margin-top:0;color:#ddd;font-size:14px;">Completa missioni per ottenere XP e salire di livello.</p>

  <div class="account-panel">
    <div class="account-top">
      <div class="account-lv">LV <span id="accountMenuLevel">1</span></div>
      <div class="account-xptext"><span id="accountMenuXp">0</span>/<span id="accountMenuXpNeed">100</span> XP</div>
    </div>
    <div class="xpbar-row">
      <button id="accountRoadBtn" class="btn-road-mini" type="button" title="Percorso livelli" aria-label="Percorso livelli">üèÜ</button>
      <div class="xpbar-wrap" style="flex:1;">
        <div class="xpbar" id="accountXpBar"></div>
        <div class="xpbar-glow"></div>
      </div>
    </div>
  </div>

  <div class="missions-header" style="margin:14px 0 8px;display:flex;align-items:center;justify-content:space-between;gap:8px;flex-wrap:wrap;">
    <h3 style="margin:0;">üìú Missioni</h3>
    <button id="missionsSortBtn" class="btn btn-mini" type="button">‚Üï Ordine: difficolt√†</button>
  </div>
  <div id="missionsList" class="missions-list"></div>

  <div style="margin-top:14px;display:flex;gap:10px;justify-content:center;flex-wrap:wrap;">
    <button id="accountBackBtn" class="btn" type="button">‚¨Ö Torna al Menu</button>
  </div>
</div>


</div>

<!-- Account Level Road Screen -->
<div class="menu" id="accountRoadMenu" style="display:none;">
  <h2 style="margin-bottom:6px;">üõ§Ô∏è PERCORSO LIVELLI</h2>
  <p style="margin-top:0;color:#ddd;font-size:14px;">Visuale livello per livello (stile cammino trofei). Qui potrai vedere cosa si sblocca.</p>

  <div class="account-panel">
    <div class="account-top">
      <div class="account-lv">LV <span id="roadMenuLevel">1</span></div>
      <div class="account-xptext"><span id="roadMenuXp">0</span>/<span id="roadMenuXpNeed">100</span> XP</div>
    </div>
    <div class="xpbar-wrap" style="margin-top:10px;">
      <div class="xpbar" id="roadXpBar"></div>
      <div class="xpbar-glow"></div>
    </div>
  </div>

  <div class="account-road-wrap">
    <div class="road-subline">Scorri ‚ûú per vedere i livelli. Il tuo livello attuale √® evidenziato.</div>
    <div class="account-road-scroll" id="accountRoadScroll">
      <div class="account-road-track" id="accountRoadTrack">
        <div class="account-road-line"></div>
        <!-- nodes injected -->
      </div>
    </div>
  </div>

  <div style="margin-top:14px;display:flex;gap:10px;justify-content:center;flex-wrap:wrap;">
    <button class="btn" type="button" onclick="closeAccountRoadMenu()">‚¨Ö Torna</button>
  </div>
</div>


<!-- SKIN Screen -->
<div class="menu" id="skinMenu" style="display:none;">
  <h2 style="margin-bottom:6px;">üß• SKIN</h2>
  <p style="margin:0 0 10px;font-size:16px;color:#ddd;">Personaggi sbloccati</p>

  <div class="skin-scroller-wrap">
    <div id="skinScroller" class="skin-scroller" aria-label="Lista skin a scorrimento orizzontale"></div>
  </div>

  <div style="margin-top:14px;display:flex;gap:10px;justify-content:center;flex-wrap:wrap;">
    <button id="skinBackBtn" class="btn" type="button">‚¨Ö Torna al Menu</button>
  </div>
</div>


<div class="end-screen" id="endScreen" style="display:none;">
<h1 id="endTitle">GAME OVER</h1>
<p id="endMessage">Score Finale: 0</p>
<p id="endSub">Hai raggiunto il Livello 1</p>
<p id="endXpEarned">XP Ottenuti: 0</p>
<p id="recordMessage">Record Personaggio: 0</p>
<button class="btn" id="restartBtn">RIPROVA</button>
<button class="btn" id="menuBtn">TORNA AL MENU</button>
</div>

<!-- Modale guida -->
<div aria-hidden="true" aria-labelledby="guideTitle" class="guide-modal" id="guideModal" role="dialog" style="display:none;">
<div class="guide-modal-content" role="document">
<button aria-label="Chiudi guida" class="guide-close" id="guideClose">‚úï</button>
<h2 id="guideTitle">Guida completa a Jeff‚Äôs Chronicles</h2>
<div class="guide-body">
<h3>1) PANORAMICA GENERALE</h3>
<p><strong>Jeff‚Äôs Chronicles</strong> √® un arena-fighter a schermo fisso. Il giocatore sceglie un combattente e affronta ondate di nemici e boss all‚Äôinterno di un‚Äôarena chiusa, cercando di ottenere il punteggio pi√π alto possibile prima della fine del tempo.</p>
<p>Il gioco combina: azione rapida, gestione dei cooldown, uso intelligente di dash, super e pickup, progressione tramite record personali. Ogni partita √® diversa grazie alla variet√† di nemici, livelli e potenziamenti.</p>
<h3>2) OBIETTIVO, LIVELLI E PUNTEGGIO</h3>
<p><strong>Obiettivo del livello</strong>: eliminare tutti i nemici presenti nell‚Äôarena e sopravvivere fino allo scadere del tempo.</p>
<p><strong>Livelli</strong>: cambiano per tipo di nemici, numero di avversari, tempo disponibile e presenza di boss. La difficolt√† aumenta progressivamente.</p>
<p><strong>Punteggio</strong>: ogni nemico ucciso fornisce <strong>+100 √ó livello corrente</strong>. Subire danno comporta <strong>‚àí50 punti</strong> (il punteggio non scende mai sotto zero). I livelli avanzati permettono di ottenere score molto pi√π elevati.</p>
<h3>3) CONTROLLI</h3>
<ul>
<li><strong>W A S D</strong> ‚Üí Movimento</li>
<li><strong>J</strong> ‚Üí Attacco base</li>
<li><strong>K</strong> ‚Üí Super mossa</li>
<li><strong>Spazio</strong> ‚Üí Dash / Schivata</li>
</ul>
<h3>4) INTERFACCIA (HUD)</h3>
<p>Durante la partita sono sempre visibili: HP e barra della vita, timer del livello, livello corrente, cooldown della super, punteggio totale e indicatori di buff attivi. Tenere d‚Äôocchio il timer e la super √® fondamentale per sopravvivere nei livelli avanzati.</p>
<h3>5) MOVIMENTO E DASH</h3>
<p>Il movimento √® libero in 8 direzioni.</p>
<p><strong>Dash / Schivata</strong>: √® uno scatto rapido che rende pi√π difficile essere colpiti. Ha un cooldown breve. Serve per evitare attacchi corpo a corpo, schivare proiettili e laser e riposizionarsi rapidamente. Alcuni personaggi hanno dash pi√π lunghi o pi√π veloci rispetto ad altri.</p>
<h3>6) ATTACCO BASE</h3>
<p>Ogni personaggio ha: un tipo di attacco unico, un range specifico e un cooldown personale. Il gioco utilizza un aim-assist leggero: quando attacchi, il personaggio tende a orientarsi verso il nemico pi√π vicino per rendere i colpi pi√π fluidi.</p>
<h3>7) SUPER MOSSA</h3>
<p>Ogni personaggio possiede una super unica. Le super hanno cooldown lunghi. Possono colpire pi√π nemici, marchiare bersagli o creare zone di danno. Usarle nel momento giusto √® la chiave per superare i livelli pi√π difficili.</p>
<h3>8) DIFESA, SCUDI E STATUS</h3>
<p><strong>Scudi</strong>: alcuni personaggi possiedono scudi con durabilit√†. Esistono pickup che forniscono invulnerabilit√† temporanea.</p>
<p><strong>Status negativi</strong>: <strong>Poison</strong> (perdita di HP nel tempo). I danni da status possono uccidere se non gestiti.</p>
<h3>9) PICKUP E POTENZIAMENTI</h3>
<p>I pickup iniziano a comparire nei livelli avanzati.</p>
<ul>
<li><strong>Heal</strong>: cura il 25% degli HP massimi.</li>
<li><strong>Atk</strong>: aumenta il danno per alcuni secondi.</li>
<li><strong>Super</strong>: ricarica immediatamente la super.</li>
<li><strong>Speed</strong>: aumenta la velocit√† di movimento.</li>
<li><strong>Shield</strong>: invulnerabilit√† temporanea.</li>
<li><strong>StellarBonus</strong>: <strong>+100 HP</strong> e <strong>+25% velocit√†</strong> per <strong>3s</strong>. Inoltre il personaggio emana un <strong>bagliore bianco luminoso e trasparente</strong> per <strong>1s</strong>. <em>Rilasciato solo dai boss.</em></li>
<li><strong>Gold</strong>: cura totale + grande aumento del danno + super pronta.</li>
<li><strong>Malus</strong>: applica poison.</li>
<li><strong>Furia</strong>: emana 3 grandi onde ad area (sempre pi√π grandi) che infliggono <strong>20 danni</strong> ciascuna; inoltre cura <strong>+10 HP/s</strong> per <strong>10s</strong>.</li>
<li><strong>Ice</strong>: rallenta drasticamente <strong>tutti i nemici presenti</strong> (effetto permanente fino alla loro morte) e infligge <strong>2 danni/s</strong> per <strong>17s</strong>.</li>
</ul>
<p>Usare correttamente i pickup pu√≤ ribaltare completamente una partita.</p>
<h3>10) PERSONAGGI ‚Äì FUNZIONALIT√Ä E MECCANICHE</h3>
<h4>üî´ JIMMY </h4>
<p><strong>Ruolo</strong>: inseguimento e eliminazione rapida di bersagli.</p>
<p><strong>Attacco base (Grapple)</strong>: Jimmy aggancia automaticamente un nemico vicino. Finch√© √® agganciato, lo insegue in modo automatico. Quando lo raggiunge, infligge danni elevati. Se il bersaglio muore o scompare, il grapple termina.</p>
<p><strong>Scudo a durabilit√†</strong>: durante gli attacchi Jimmy attiva uno scudo. Ogni colpo assorbito consuma 1 punto di durabilit√†. Quando la durabilit√† √® zero, lo scudo si rompe e smette di funzionare temporaneamente.</p>
<p><strong>Super</strong>: seleziona pi√π bersagli. Jimmy li insegue uno dopo l‚Äôaltro colpendoli con danni potenziati. Durante la super √® molto pi√π difficile da fermare.</p>
<p><strong>Passiva ‚Äì Jetpack</strong>: ogni tot secondi si attiva automaticamente. Fornisce aumento di velocit√† e garantisce maggiore sicurezza nei movimenti.</p>
<p><strong>Stile consigliato</strong>: aggressivo e mobile.</p>
<h4>üê± ROONEY</h4>
<p><strong>Ruolo</strong>: resistenza e danni ravvicinati.</p>
<p><strong>Attacco base</strong>: serie di pugni potenti a corto raggio. Ottimo contro nemici lenti o raggruppati.</p>
<p><strong>Super</strong>: colpo ad area che frantuma il terreno in una <strong>zona quadrata</strong> centrata su Rooney. Il <strong>danno totale massimo √® 300</strong> (senza buff) e viene distribuito tra tutti i nemici presenti nell‚Äôarea: chi √® pi√π vicino al centro subisce pi√π danno, chi √® verso i bordi ne subisce meno. Perfetta per ripulire ondate e per fare burst se resti vicino al bersaglio principale.</p>
<p><strong>Stile consigliato</strong>: restare vicino ai nemici e controllare lo spazio.</p>
<h4>üó°Ô∏è JEFF </h4>
<p><strong>Ruolo</strong>: controllo dell‚Äôarena.</p>
<p><strong>Attacco base</strong>: fendente ad arco con la spada. Buona velocit√† e affidabilit√†.</p>
<p><strong>Super</strong>: crea una grande area intorno a Jeff. Infligge danni periodici a tutti i nemici all‚Äôinterno. Molto efficace contro boss e gruppi.</p>
<p><strong>Stile consigliato</strong>: posizionamento intelligente.</p>
<div id="guide-voltryx-locked" style="margin-top:10px;padding:10px;border:2px dashed rgba(255,255,255,0.35);background:rgba(255,255,255,0.05);">
<h4>ü¶ä VOLTRYX </h4>
<p><em>Questo personaggio si sblocca facendo oltre 45.000 punti con Jimmy, Rooney e Jeff.. La descrizione apparir√† automaticamente appena lo sblocchi.</em></p>
</div>
<div id="guide-voltryx" style="display:none;">
<h4>ü¶ä VOLTRYX </h4>
<p><strong>Ruolo</strong>: versatilit√† totale.</p>
<p><strong>Attacco base</strong>: da lontano spara un proiettile energetico ad area; da vicino esegue due pugni rapidi.</p>
<p><strong>Super</strong>: genera una sfera energetica che rilascia impulsi di danno ad area, colpendo ripetutamente i nemici nel raggio.</p>
<p><strong>Stile consigliato</strong>: alternare distanza e mischia.</p>
<p><strong>Sblocco</strong>: oltre 45.000 punti con Jimmy, Rooney e Jeff.</p>
</div>
<div id="guide-kouvagia-locked" style="margin-top:10px;padding:10px;border:2px dashed rgba(255,255,255,0.35);background:rgba(255,255,255,0.05);">
<h4>ü¶â KOUVAGIA </h4>
<p><em>Questo personaggio si sblocca facendo 50.000 punti con Voltryx. La descrizione apparir√† automaticamente appena lo sblocchi.</em></p>
</div>
<div id="guide-kouvagia" style="display:none;">
<h4>ü¶â KOUVAGIA </h4>
<p><strong>Ruolo</strong>: sopravvivenza e danni da contatto.</p>
<p><strong>Attacco base</strong>: dash offensivo che infligge danni ai nemici attraversati. Al termine del dash esplode infliggendo danni ad area.</p>
<p><strong>Passiva ‚Äì Dash offensivo</strong>: ogni schivata infligge danni ai nemici vicini.</p>
<p><strong>Passiva ‚Äì Cura su uccisione</strong>: ogni nemico ucciso a distanza ravvicinata cura Kouvagia.</p>
<p><strong>Super</strong>: cura completa e genera un‚Äôonda che respinge i nemici.</p>
<p><strong>Stile consigliato</strong>: usare spesso il dash e restare nel caos.</p>
<p><strong>Sblocco</strong>: 50.000 punti con Voltryx.</p>
</div>
<div id="guide-salsy-locked" style="margin-top:10px;padding:10px;border:2px dashed rgba(255,255,255,0.35);background:rgba(255,255,255,0.05);">
<h4>‚öúÔ∏è SALSY </h4>
<p><em>Questo personaggio si sblocca facendo 60.000 punti con tutti gli altri personaggi.. La descrizione apparir√† automaticamente appena lo sblocchi.</em></p>
</div>
<div id="guide-salsy" style="display:none;">
<h4>‚öúÔ∏è SALSY </h4>
<p><strong>Ruolo</strong>: burst damage e controllo dei bersagli.</p>
<p><strong>Attacco base</strong>: doppio fendente consecutivo. Pu√≤ colpire lo stesso nemico due volte con un singolo attacco.</p>
<p><strong>Super ‚Äì Marchio</strong>: marchia fino a 3 nemici. I nemici marchiati subiscono danni raddoppiati per alcuni secondi.</p>
<p><strong>Passiva ‚Äì Boost velocit√†</strong>: periodicamente ottiene un aumento temporaneo di velocit√†, perfetto per entrare e uscire dai combattimenti.</p>
<p><strong>Stile consigliato</strong>: colpisci, marchia e ritirati.</p>
<p><strong>Sblocco</strong>: 60.000 punti con tutti gli altri personaggi.</p>
</div>
<div id="guide-tempostorm-locked" style="margin-top:10px;padding:10px;border:2px dashed rgba(255,255,255,0.35);background:rgba(255,255,255,0.05);">
<h4>üîã TEMPOSTORM</h4>
<p><em>Questo personaggio si sblocca facendo <strong>70.000 punti</strong> con tutti i personaggi precedenti (Jimmy, Rooney, Jeff, Voltryx, Kouvagia e Salsy). La descrizione completa apparir√† automaticamente appena lo sblocchi.</em></p>
</div>
<div id="guide-tempostorm" style="display:none;">
<h4>üîã TEMPOSTORM</h4>
<p><strong>Ruolo</strong>: controllo di zona + sustain tramite Super.</p>
<p><strong>Statistiche</strong>: 300 HP, velocit√† leggermente superiore a Rooney.</p>
<p><strong>Attacco base</strong>: fasci di energia blu (laser). Infligge <strong>40</strong> danni al primo impatto e altri <strong>30</strong> se il nemico resta dentro il fascio dopo essere stato colpito.</p>
<p><strong>Super ‚Äì Tempesta Centrale</strong>: raggruppa tutti i nemici esattamente al centro dell‚Äôarena, dimezza la loro vita e converte la somma della vita sottratta in una <strong>cura personale</strong> tramite un effetto speciale blu.</p>
<p><strong>Sblocco</strong>: 70.000 punti con tutti i personaggi precedenti.</p>
</div>
<div id="guide-marz-locked" style="margin-top:10px;padding:10px;border:2px dashed rgba(255,255,255,0.35);background:rgba(255,255,255,0.05);">
<h4>ü™Ñ MARZ</h4>
<p><em>Questo personaggio si sblocca facendo <strong>70.000 punti</strong> con tutti i personaggi precedenti (Jimmy, Rooney, Jeff, Voltryx, Kouvagia, Salsy e Tempostorm). La descrizione completa apparir√† automaticamente appena lo sblocchi.</em></p>
</div>
<div id="guide-marz" style="display:none;">
<h4>ü™Ñ MARZ</h4>
<p><strong>Ruolo</strong>: mago da controllo e danno a bersagli multipli.</p>
<p><strong>Statistiche</strong>: 320 HP, velocit√† 7.2.</p>
<p><strong>Attacco base</strong>: spara <strong>tre fasci magici</strong> (corti) con danni diversi: <strong>40</strong>, <strong>50</strong>, <strong>60</strong>. Se ci sono almeno 3 nemici, colpisce fino a 3 bersagli differenti; se i nemici sono meno, i fasci si concentrano sugli stessi bersagli disponibili.</p>
<p><strong>Super ‚Äì Sigillo Arcano</strong>: crea esattamentte al centro della mappa un <strong>cerchi arcano </strong> che si espande molto lentamente causando molti danni ai nemici presenti all'interno inoltre Marz all'interno dell'area del sigillo ottiene <strong>un aumento del 50% della velocit√†</strong> finche la super resta attiva quindi per <strong>10 secondi</strong>.</p>
<p><strong>Sblocco</strong>: 70.000 punti con tutti i personaggi precedenti.</p>
</div>

<div id="guide-hecate-locked" style="margin-top:10px;padding:10px;border:2px dashed rgba(255,255,255,0.35);background:rgba(255,255,255,0.05);">
<h4>üåò H√àCATE</h4>
<p><em>Questo personaggio si sblocca facendo <strong>75.000 punti</strong> con tutti i personaggi precedenti (Jimmy, Rooney, Jeff, Voltryx, Kouvagia, Salsy, Tempostorm e Marz). La descrizione completa apparir√† automaticamente appena lo sblocchi.</em></p>
</div>
<div id="guide-hecate" style="display:none;">
<h4>üåò H√àCATE</h4>
<p><strong>Ruolo</strong>: tiratrice a lunga distanza + sustain tramite Super.</p>
<p><strong>Statistiche</strong>: 325 HP, dash identico a Voltryx.</p>
<p><strong>Attacco base</strong>: scocca una <strong>freccia a lunghissima distanza</strong> che infligge il danno maggiore al <strong>primo nemico colpito</strong>. Nel punto d‚Äôimpatto la freccia si <strong>divide istantaneamente</strong> (effetto visivo) in <strong>tre frecce</strong> che cercano e colpiscono <strong>altri nemici</strong> (non quello gi√† colpito).</p>
<p><strong>Super ‚Äì Richiamo Lunare</strong>: si cura di <strong>5 HP per ogni nemico presente</strong> nell‚Äôarena al momento dell‚Äôattivazione. Inoltre richiama tre lupi che attaccano i nemici con morsi letali il richiamo puo essere attivato piu volte ma in campo ci possono essere massimo 3 lupi</p>
<p><strong>Sblocco</strong>: 75.000 punti con tutti i personaggi precedenti.</p>
</div>


<div id="guide-pdor-locked" style="margin-top:10px;padding:10px;border:2px dashed rgba(255,255,255,0.35);background:rgba(255,255,255,0.05);">
  <h4>ü™Ñ PDOR</h4>
  <p><em>Questo personaggio si sblocca facendo almeno <strong>50.000 punti</strong> di record con <strong>Marcus</strong> e <strong>Lucien</strong>. La descrizione completa apparir√† automaticamente appena lo sblocchi.</em></p>
</div>


<div id="guide-bane-locked" style="margin-top:10px;padding:10px;border:2px dashed rgba(255,255,255,0.35);background:rgba(255,255,255,0.05);">
  <h4>ü™ì BANE</h4>
  <p><em>Questo personaggio si sblocca facendo almeno <strong>50.000 punti</strong> di record con <strong>Pdor</strong>. La descrizione completa apparir√† automaticamente appena lo sblocchi.</em></p>
</div>


<div id="guide-marcus-locked" style="margin-top:10px;padding:10px;border:2px dashed rgba(255,255,255,0.35);background:rgba(255,255,255,0.05);">
  <h4>üé∂ MARCUS</h4>
  <p><em>Questo personaggio si sblocca facendo almeno <strong>70.000 punti</strong> con <strong>qualsiasi</strong> personaggio. La descrizione completa apparir√† automaticamente appena lo sblocchi.</em></p>
</div>
<div id="guide-marcus" style="display:none;">
  <h4>üé∂ MARCUS</h4>
  <p><strong>Ruolo</strong>: supporto offensivo a media distanza + controllo con la Super.</p>
  <p><strong>Statistiche</strong>: 400 HP, velocit√† 7.</p>
  <p><strong>Attacco base ‚Äì Banjo Notes</strong>: Marcus suona il banjo e lancia <strong>note musicali</strong> (proiettili ondulati) che infliggono danni a distanza. Ottimo per tenere i nemici lontani mentre ti riposizioni.</p>
  <p><strong>Super ‚Äì Danza Stordente</strong>: gli avversari vengono <strong>storditi/confusi</strong> e ‚Äúballano‚Äù perdendo controllo per alcuni secondi. In pi√π Marcus ottiene uno <strong>scudo</strong> temporaneo.</p>
  <p><strong>Stile consigliato</strong>: colpisci da media distanza e usa la Super per creare spazio nei momenti critici.</p>
  <p><strong>Sblocco</strong>: 70.000 punti con qualsiasi personaggio.</p>
</div>

<div id="guide-lucien-locked" style="margin-top:10px;padding:10px;border:2px dashed rgba(255,255,255,0.35);background:rgba(255,255,255,0.05);">
  <h4>üó∫Ô∏è LUCIEN</h4>
  <p><em>Questo personaggio si sblocca facendo un record con <strong>Marcus</strong> superiore a <strong>25.000 punti</strong>. La descrizione completa apparir√† automaticamente appena lo sblocchi.</em></p>
</div>
<div id="guide-lucien" style="display:none;">
  <h4>üó∫Ô∏è LUCIEN</h4>
  <p><strong>Ruolo</strong>: ladro furtivo da burst ravvicinato + utilit√† tramite bonus.</p>
  <p><strong>Statistiche</strong>: 380 HP, velocit√† leggermente superiore alla media (dash/scatto pi√π reattivo).</p>
  <p><strong>Attacco base ‚Äì Lama Rapida</strong>: 4 colpi <strong>molto ravvicinati</strong> da <strong>15</strong> danni ciascuno (stile Salsy ma pi√π ‚Äúa raffica‚Äù e a distanza pi√π corta).</p>
  <p><strong>Super ‚Äì Furto di Bonus</strong>: Lucien ‚Äúruba‚Äù <strong>5 bonus casuali</strong> e li rilascia attorno a s√©: sono <strong>prendibili</strong> dal personaggio. La Super <strong>non</strong> pu√≤ generare bonus che ricaricano la Super (quindi niente <strong>Gold</strong> e niente <strong>ricarica Super</strong>).</p>
  <p><strong>Stile consigliato</strong>: entra rapido, scarica i 4 colpi e usa la Super per trasformare il fight in vantaggio di buff.</p>
  <p><strong>Sblocco</strong>: record con Marcus &gt; 25.000.</p>
</div>
<div id="guide-pdor" style="display:none;">
  <h4>ü™Ñ PDOR</h4>
  <p><strong>Ruolo</strong>: mago a distanza con controllo e ‚Äúchain‚Äù sui bersagli.</p>
  <p><strong>Background</strong>: Pdor √® un <strong>tiefling stregone</strong> che canalizza la propria magia per colpire da lontano.</p>
  <p><strong>Attacco base ‚Äì Dardo Arcano</strong>: lancia un dardo magico <strong>auto-mirato</strong> verso il nemico pi√π vicino. Il dardo pu√≤ <strong>rimbalzare/agganciarsi</strong> fino a <strong>5 bersagli</strong> diversi: a ogni salto il <strong>danno si dimezza</strong>. Ottimo per ripulire ondate e punire gruppi.</p>
  <p><strong>Super ‚Äì Luci danzanti</strong>: per circa <strong>8 secondi</strong> compaiono <strong>7 sfere luminose</strong> in posizioni casuali dell‚Äôarena. Ogni sfera emette pulsazioni ad anello: chi viene toccato dall‚Äôanello subisce danno e viene <strong>rallentato</strong> per breve tempo. Perfetta per controllare spazio, spezzare l‚Äôinseguimento e fare DPS costante se ‚Äúchiudi‚Äù i nemici nelle zone.</p>
  <p><strong>Sblocco</strong>: record ‚â• 50.000 con Marcus e Lucien.</p>
</div>
<div id="guide-bane" style="display:none;">
  <h4>ü™ì BANE</h4>
  <p><strong>Ruolo</strong>: melee da ondate, danni pesanti e pressione ravvicinata.</p>
  <p><strong>Background</strong>: Bane √® un <strong>barbaro</strong> armato di <strong>ascia bipenne</strong>, costruito per spaccare gruppi a corto raggio.</p>
  <p><strong>Attacco base ‚Äì Fendente d‚ÄôAscia</strong>: un colpo ampio a ventaglio (quasi a 270¬∞ davanti a te) che pu√≤ colpire fino a <strong>2 nemici</strong> per swing. √à ideale per eliminare rapidamente i minion e tenere pulita la zona vicino al personaggio.</p>
  <p><strong>Super ‚Äì IRA</strong>: entra in uno stato di furia per <strong>10 secondi</strong>. Durante IRA ottieni <strong>+25% velocit√†</strong> e l‚Äôattacco base diventa molto pi√π rapido (cooldown ridotto). Inoltre l‚Äôattacco base riceve un <strong>moltiplicatore danni</strong> in base alle kill che hai al momento dell‚Äôattivazione, rendendo IRA devastante nelle fasi avanzate. Alla fine di IRA il ritmo dell‚Äôattacco torna verso il valore base (con l‚Äôattuale impostazione post-IRA).</p>
  <p><strong>Sblocco</strong>: record ‚â• 50.000 con Pdor.</p>
</div>


<div id="guide-hendel-locked" style="margin-top:10px;padding:10px;border:2px dashed rgba(255,255,255,0.35);background:rgba(255,255,255,0.05);">
  <h4>ü™® HENDEL</h4>
  <p><em>Questo personaggio si sblocca facendo almeno <strong>50.000 punti</strong> di record con <strong>Bane</strong>. La descrizione completa apparir√† automaticamente appena lo sblocchi.</em></p>
</div>

<div id="guide-hendel" style="display:none;">
  <h4>ü™® HENDEL</h4>
  <p><strong>Ruolo</strong>: bruiser difensivo da controllo ravvicinato (punisce chi prova a ingaggiarti).</p>
  <p><strong>Statistiche</strong>: alta resistenza e presenza in mischia.</p>
  <p><strong>Attacco base (J) ‚Äì Martello Rotante</strong>: Hendel esegue uno swing a ‚Äúmartello‚Äù con area composta da <strong>manico vicino</strong> e <strong>testa lontana</strong>. Durante l‚Äôattacco l‚Äôhitbox ruota in <strong>senso orario</strong> per circa <strong>75¬∞</strong> e pu√≤ colpire <strong>un solo avversario</strong> per swing. Infligge <strong>120 danni</strong> e applica <strong>stordimento per 0,5s</strong> al bersaglio colpito.</p>
  <p><strong>Passiva ‚Äì Ritorsione di Pietra</strong>: ogni nemico che colpisce Hendel viene <strong>respinto lontano</strong> (knockback aumentato) e subisce <strong>30 danni</strong>. √à perfetta per spezzare assalti melee e punire anche i ranged quando riesci a farli ‚Äúsporcare‚Äù su di te.</p>
  <p><strong>Super ‚Äì Stone Perimeter Crush</strong>: richiama un perimetro di pietra che si <strong>chiude progressivamente</strong> sull‚Äôarena, danneggiando i nemici e comprimendoli verso il centro. Ottima per ripulire ondate, controllare boss e forzare posizionamenti sfavorevoli.</p>
  <p><strong>Stile consigliato</strong>: gioca ‚Äúfrontline‚Äù. Entra nel gruppo, prendi un hit con la passiva per creare spazio, poi chiudi con J sul bersaglio pi√π pericoloso.</p>
  <p><strong>Sblocco</strong>: record ‚â• 50.000 con Bane.</p>

<div id="guide-kaerith-locked" style="display:block;padding:12px;border-radius:10px;border:1px dashed rgba(255,255,255,0.35);background:rgba(255,255,255,0.05);margin-top:10px;">
  <h4>üêâ KAERITH</h4>
  <p><em>Questo personaggio si sblocca facendo almeno <strong>40.000 punti</strong> di record con <strong>Hendel</strong>. La descrizione completa apparir√† automaticamente appena lo sblocchi.</em></p>
</div>

<div id="guide-kaerith" style="display:none;">
  <h4>üêâ KAERITH</h4>
  <p><strong>Specie</strong>: dragonide (dragonide da battaglia, controlla il campo con fiammate).</p>
  <p><strong>Statistiche</strong>: <strong>410 HP</strong> (molto resistente), mobilit√† media.</p>
  <p><strong>Attacco base (J) ‚Äì Fiammata Continua</strong>: Kaerith sprigiona una <strong>fiammata</strong> in cono davanti a s√© (stile i nemici dei livelli 23‚Äì24). Finch√© la fiammata √® attiva, il danno √® a <strong>tick ripetuti</strong> e <strong>aumenta progressivamente</strong> durante la stessa emissione: i primi istanti bruciano meno, poi la fiammata ‚Äúcarica‚Äù e diventa pi√π devastante.</p>
  <p><strong>Super (K) ‚Äì Inferno Totale</strong>: infuoca l‚Äôintero campo per <strong>9s</strong> con un overlay visivo di fiamme. Durante questo tempo tutti i nemici ottengono lo status <strong>Infuocato</strong>: ogni secondo subiscono danno progressivo che parte da <strong>5</strong> e sale fino a un massimo di <strong>25</strong> (cap). <strong>Ricarica: 21s</strong>.</p>
</div>

</div>

<h3>11) NEMICI E PERICOLI</h3>
<p>Nemici melee, veloci, resistenti e a distanza. Nemici con poison. Nemici con laser che richiedono schivata precisa. Boss con attacchi speciali e grandi quantit√† di HP.</p>
<h3>12) CONSIGLI FINALI</h3>
<ul>
<li>Usa il dash pi√π spesso di quanto pensi.</li>
<li>Le super vanno usate nei momenti critici.</li>
<li>Evitare danni √® importante anche per il punteggio.</li>
<li>Ogni personaggio √® forte se usato nel modo giusto.</li>
</ul>
<h3>‚ú¥Ô∏è EVOLUZIONI </h3>
<p>rappresentano una fase avanzata del combattimento e si attivano automaticamente durante la partita. Non sono potenziamenti temporanei, ma un vero e proprio cambiamento nello stile di gioco del personaggio.</p> <p><strong>Quando avvengono</strong>: dopo aver superato un boss avanzato (oltre met√† progressione), il personaggio entra nello stato <em>Evoluto</em>. L‚Äôevoluzione viene annunciata a schermo con un banner dedicato.</p> <p><strong>Filosofia delle evoluzioni</strong>: le evoluzioni <u>non aumentano direttamente HP, velocit√† o danno base</u>. Al contrario, sbloccano <strong>passive speciali</strong> che premiano l‚Äôuso intelligente delle meccaniche del personaggio. Questo mantiene il gioco bilanciato e strategico.</p> <h4>Effetti generali</h4> <ul> <li>L‚Äôevoluzione dura per il resto della partita.</li> <li>Ogni personaggio ottiene un <strong>vantaggio unico</strong>, coerente con il suo ruolo.</li> <li>Le evoluzioni premiano precisione, timing e gestione dei nemici.</li> </ul> <h4>‚öôÔ∏è Evoluzioni attuali</h4> <p><strong>üî´ Jimmy ‚Äì Predatore Evoluto</strong><br/> Jimmy carica la <strong>Super pi√π velocemente (+25%)</strong> e il <strong>cooldown dell‚Äôattacco base √® ridotto del 15%</strong>.</p>
<p><strong>üê± Rooney ‚Äì Impatto Brutale</strong><br/> Il <strong>primo colpo</strong> inflitto a ogni nemico infligge <strong>+50% danni</strong>.</p>
<p><strong>üó°Ô∏è Jeff ‚Äì Rigenerazione da Combattimento</strong><br/> Ogni nemico ucciso cura Jeff di <strong>5 HP</strong>.</p> <p><em>Nota:</em> i personaggi sbloccabili avanzati potrebbero ottenere evoluzioni dedicate in futuro.</p> <h4> Consigli strategici</h4> <ul> <li>Sfrutta l‚Äôevoluzione per cambiare approccio: da difensivo a aggressivo (o viceversa).</li> <li>Dopo l‚Äôevoluzione, eliminare i nemici velocemente diventa ancora pi√π importante per massimizzare punteggio e controllo.</li> <li>Le evoluzioni non rendono invincibili: il posizionamento resta fondamentale.</li> </ul> <p><strong>Le evoluzioni sono il momento in cui Jeff‚Äôs Chronicles premia davvero la padronanza del personaggio.</strong></p>
<h3>üèÅ CONCLUSIONE</h3>
<p><strong>Jeff‚Äôs Chronicles</strong> premia abilit√†, strategia e conoscenza dei personaggi. Impara i loro meccanismi, sfrutta i pickup e punta al record massimo.</p>
</div>
</div>
</div>
<!-- Modale bestiario (nemici e boss) -->
<div aria-hidden="true" aria-labelledby="enemyGuideTitle" class="guide-modal enemy-guide-modal" id="enemyGuideModal" role="dialog" style="display:none;">
<div class="guide-modal-content enemy-guide-content" role="document">
<button aria-label="Chiudi bestiario" class="guide-close" id="enemyGuideClose">‚úï</button>
<h2 id="enemyGuideTitle">Bestiario ‚Äì Nemici &amp; Boss</h2>
<div class="enemy-guide-body">
<div class="enemy-guide-wrap">
<div aria-label="Lista nemici sbloccati" class="enemy-guide-list" id="enemyGuideList"></div>
<div aria-live="polite" class="enemy-guide-detail" id="enemyGuideDetail">
<div class="enemy-guide-empty">
<h3 style="margin:0 0 8px 0;color:#f39c12;">Nessun nemico sbloccato</h3>
<p style="margin:0;color:#ddd;">Affronta un nemico o un boss almeno una volta per sbloccarlo qui.</p>
</div>
</div>
</div>
<p class="enemy-guide-hint">Nota: nel Bestiario compaiono solo i nemici/boss che hai gi√† sfidato almeno una volta (vale per tutti i personaggi).</p>
</div>
</div>
</div>
<script>
const HP_MULT=1.40;
const DAMAGE_MULT=0.85;
const SUPER_DAMAGE_MULT=0.8;
const JEFF_SUPER_RADIUS=Math.round(320*0.8);
const GOLD_PROB=0.05;
const JEFF_ATTACK_RANGE_MULT=0.8;
const JIMMY_SUPER_ADDITIONAL_MULT=0.85;
const JIMMY_BASE_ADDITIONAL_MULT=1.20;

const URL_DEFAULT='https://i.postimg.cc/8CBFTKs4/Progetto-senza-titolo.png';
const URL_DARK='https://i.postimg.cc/JhpWH3jJ/Copilot-20251209-232827.png';

// --- Hendel SUPER: Stone Perimeter Crush ---
let hendelCrush = null;
function startHendelCrush(duration=3000){
  hendelCrush = { start: Date.now(), duration, last: Date.now(), exploded:false };
}
function _hendelCrushBounds(){
  const now=Date.now();
  if(!hendelCrush) return null;
  const t=Math.max(0, Math.min(1, (now-hendelCrush.start)/hendelCrush.duration));
  const insetMax = Math.max(0, Math.min(canvas.width, canvas.height)/2 - 40);
  const inset = insetMax * t;
  return {t, left: inset, top: inset, right: canvas.width - inset, bottom: canvas.height - inset};
}
function updateHendelCrush(){
  if(!hendelCrush) return;
  const now=Date.now();
  const dt=Math.min(0.05, Math.max(0, (now-hendelCrush.last)/1000));
  hendelCrush.last = now;
  const b=_hendelCrushBounds();
  if(!b) return;

  // DoT while shrinking: 20 DPS to enemies; walls push enemies toward center
  if(enemies && enemies.length){
    for(let i=enemies.length-1;i>=0;i--){
      const e=enemies[i];
      const cx=e.x+e.width/2, cy=e.y+e.height/2;
      let pushed=false;
      if(cx < b.left){ e.x += (b.left - cx); pushed=true; }
      else if(cx > b.right){ e.x -= (cx - b.right); pushed=true; }
      if(cy < b.top){ e.y += (b.top - cy); pushed=true; }
      else if(cy > b.bottom){ e.y -= (cy - b.bottom); pushed=true; }

      // clamp
      e.x = Math.max(0, Math.min(canvas.width - e.width, e.x));
      e.y = Math.max(0, Math.min(canvas.height - e.height, e.y));

      // 20 damage per second during convergence
      const dmg = 20 * dt;
      if(dmg>0){
        applyEnemyDamage(e, dmg);
        if(pushed){
          createParticles(cx,cy,'#8b5a2b',2,2);
        }
        if(e.hp<=0){
          createParticles(e.x,e.y,'#fff176',22,6);
          dropStellarBonusAtIndexIfNeeded(i);
          enemies.splice(i,1);
          applyScore(100*currentLevel);
          addKill();
          if(player && player._baneSuperOnKill) player._baneSuperOnKill();
        }
      }
    }
  }

  // Final explosion at center
  if(b.t>=1 && !hendelCrush.exploded){
    hendelCrush.exploded=true;
    const cx=canvas.width/2, cy=canvas.height/2;
    createParticles(cx,cy,'#8b5a2b',160,8);
    createParticles(cx,cy,'#9e9e9e',160,8);
    shakeScreen();

    if(enemies && enemies.length){
      for(let i=enemies.length-1;i>=0;i--){
        const e=enemies[i];
        const final=applyEnemyDamage(e, 330);
        showDamageNumber(e.x,e.y,Math.round(final));
        createParticles(e.x+e.width/2,e.y+e.height/2,'#8b5a2b',26,6);
        createParticles(e.x+e.width/2,e.y+e.height/2,'#9e9e9e',18,6);
        if(e.hp<=0){
          createParticles(e.x,e.y,'#fff176',26,6);
          dropStellarBonusAtIndexIfNeeded(i);
          enemies.splice(i,1);
          applyScore(100*currentLevel);
          addKill();
          if(player && player._baneSuperOnKill) player._baneSuperOnKill();
        }
      }
    }
  }

  // cleanup shortly after explosion
  if(b.t>=1 && hendelCrush.exploded && (now-hendelCrush.start) > (hendelCrush.duration+350)){
    hendelCrush=null;
  }
}
function drawHendelCrush(){
  if(!hendelCrush) return;
  const b=_hendelCrushBounds();
  if(!b) return;
  const w=b.right-b.left, h=b.bottom-b.top;
  ctx.save();
  ctx.globalAlpha=0.9;
  ctx.lineWidth=6;
  ctx.strokeStyle='rgba(139,61,43,0.95)';
  ctx.strokeRect(b.left,b.top,w,h);
  ctx.globalAlpha=0.12;
  ctx.fillStyle='rgba(139,90,43,0.35)';
  ctx.fillRect(b.left,b.top,w,h);
  ctx.restore();
}



const URL_FINAL='https://i.postimg.cc/pTHFKHgz/Progetto-senza-titolo-(2).png';
const URL_ICE='https://i.postimg.cc/K8pgVhTx/icebiome1.png';
const canvas=document.getElementById('gameCanvas');
const ctx=canvas.getContext('2d');


function getPlayBounds(){
  // Limiti reali del campo giocabile (non per forza identici al canvas).
  // Rispetta il margine HUD in basso e, se attivo, lo shrink di Hendel Crush.
  const bottomLimit = canvas.height-30;
  let b = {left:0, top:0, right:canvas.width, bottom:bottomLimit};

  // Hendel Crush: NON restringere l'arena del player (evita che Hendel venga trascinato al centro)
  // La spinta verso il centro e il DoT sono gi√† applicati ai nemici in updateHendelCrush().

  return b;
}

const bgDefault=document.getElementById('bgDefault');
const bgDark=document.getElementById('bgDark');
const fadeOverlay=document.getElementById('fadeOverlay');
let _bgTier=0; // 0=default,1=dark,2=final,3=ice

bgDefault.style.backgroundImage=`url('${URL_DEFAULT}')`;
bgDark.style.backgroundImage=`url('${URL_DARK}')`;
bgDefault.style.backgroundSize=bgDark.style.backgroundSize='cover';
bgDefault.style.backgroundPosition=bgDark.style.backgroundPosition='center';

let gameState='start';
let selectedCharacter=null;
let lastSuperUseCountTs=0; // debounce conteggio super (ms)

let player=null;
let currentLevel=0;
let score=0;
let pendingBattleXp=0; // XP da assegnare al termine della battaglia (animato al menu)

let kills=0;
let timer=45;
let enemies=[];
let particles=[];
let pickups=[];
let difficultyMode='hard'; // 'hard' | 'easy'
let scoreMultiplier=1;     // easy => 0.5

function setDifficulty(mode){
  difficultyMode = (mode==='easy') ? 'easy' : 'hard';
  scoreMultiplier = (difficultyMode==='easy') ? 0.5 : 1;
}

  // --- Pausa in battaglia ---
  function openPauseMenu(){
    if(gameState!=='playing') return;
    gameState='paused';
    const po=document.getElementById('pauseOverlay');
    if(po) po.style.display='flex';
  }
  function resumeFromPause(){
    if(gameState!=='paused') return;
    const po=document.getElementById('pauseOverlay');
    if(po) po.style.display='none';
    lastSecondTick=Date.now(); // evita "salto" del timer al resume
    gameState='playing';
  }
  function exitToMenuFromPause(){
    const po=document.getElementById('pauseOverlay');
    if(po) po.style.display='none';
    // nascondi HUD gioco
    const ui=document.getElementById('uiOverlay'); if(ui) ui.style.display='none';
    const sd=document.getElementById('scoreDisplay'); if(sd) sd.style.display='none';
    const kd=document.getElementById('killsDisplay'); if(kd) kd.style.display='none';
    const tw=document.getElementById('timerWrap'); if(tw) tw.style.display='none';
    const ld=document.getElementById('levelDisplay'); if(ld) ld.style.display='none';
    const sc=document.getElementById('superCooldown'); if(sc) sc.style.display='none';
    enemies=[];particles=[];projectiles=[];lasers=[];tempBeams=[];pickups=[];wolves=[];
    player=null;
    // ripristina HUD frammenti d'etere (menu)
    const etherUI=document.getElementById('etherHud');
    if(etherUI) etherUI.style.display='flex';

    goToMenu(difficultyMode);
  }


function applyScore(delta){
  // In easy mode all score changes are halved (including penalties), and score never goes below 0.
  const scaled = delta * scoreMultiplier;
  // keep integers (same feeling as before)
  const d = (scaled>=0) ? Math.floor(scaled) : Math.ceil(scaled);
  score = Math.max(0, score + d);
}

function addKill(n=1){
  n = Math.max(1, Math.floor(n||1));
  kills = Math.max(0, (kills||0) + n);

  // per-match kill counter (for "75 kill in una partita")
  matchKills = Math.max(0, (matchKills||0) + n);
  if(accountState && accountState.stats){
    accountState.stats.bestMatchKills = Math.max(Math.floor(accountState.stats.bestMatchKills||0), matchKills);
  }

  // mission progress (account level)
  try{ accountOnKill((player && player.type) ? player.type : selectedCharacter, n); }catch(e){}

  // matchKills mission update (solo in UNA partita: non accumula tra run)
try{
  let shouldSave=false;
  for(const m of missionsSorted){
    if(m.claimed) continue;
    if(m.type==='matchKills'){
      if(matchKills >= m.target){
        m.progress = m.target;
        shouldSave=true; // salva solo quando completata
      }else{
        // progress temporaneo per UI (non persistente)
        m.progress = Math.max(0, Math.min(m.target, matchKills));
      }
    }
  }
  if(shouldSave) saveAccount();
}catch(e){}
}


// --- Pickup hitbox tuning ---
// Bigger pickup hitbox (bonuses easier to collect), malus stays tighter.
const BONUS_HIT_RADIUS = 26; // was ~18
const MALUS_HIT_RADIUS = 18;

// Lower malus probability (weighted pick)
function pickRandomPickupType(){
  const weighted = [
    ['heal', 1],
    ['atk', 1],
    ['super', 1],
    ['speed', 1],
    ['shieldPickup', 1],
    ['furia', 1],
    ['ice', 1],
    ['malus', 0.25], // nerfed
  ];
  let sum = 0;
  for (const [,w] of weighted) sum += w;
  let r = Math.random() * sum;
  for (const [t,w] of weighted){
    r -= w;
    if (r <= 0) return t;
  }
  return 'heal';
}
let projectiles=[];

// --- BOSS RINGS (Boss20) ---
let bossRings=[];

function spawnBossRing(opts){
  // opts: {x,y,damage,maxR,ttl,pull,owner}
  bossRings.push({
    x:opts.x,y:opts.y,
    created:Date.now(),
    ttl:opts.ttl||900,
    maxR:opts.maxR||300,
    damage:opts.damage||20,
    pull:opts.pull||3,
    owner:opts.owner||null,
    hit:false
  });
}

function updateBossRings(now){
  if(!player) return;
  bossRings = bossRings.filter(r=>{
    const t=(now-r.created)/(r.ttl||900);
    if(t>=1) return false;

    const cx=r.x, cy=r.y;
    const px=player.x+player.width/2;
    const py=player.y+player.height/2;
    const dist=Math.hypot(px-cx, py-cy);
    const radius=(r.maxR||300)*t;
    const band=16;

    // damage once when wave reaches player
    if(!r.hit && dist <= radius+band){
      r.hit=true;
      player.takeDamage(r.damage, r.owner||null);

      // pull towards center (instant + short acceleration)
      const dx=cx-px, dy=cy-py;
      const d=Math.hypot(dx,dy)||1;
      const nx=dx/d, ny=dy/d;
      player.vx += nx*(r.pull||3);
      player.vy += ny*(r.pull||3);
      createParticles(player.x,player.y,'#f1c40f',18,4);

      // EXTRA: small positional pull on hit (Lv 20 Boss ring)
      try{
        if((typeof currentLevel!=='undefined' && currentLevel===20) && (r.owner && r.owner.type==='boss20')){
          const nudge = 34; // "un po"
          player.x += nx*nudge;
          player.y += ny*nudge;
          // clamp into arena
          if(player.x<0) player.x=0;
          if(player.y<0) player.y=0;
          if(player.x+player.width>canvas.width) player.x=canvas.width-player.width;
          if(player.y+player.height>canvas.height-30) player.y=canvas.height-30-player.height;
        }
      }catch(e){}
    }

    // mild continuous pull while inside wave reach
    if(dist <= radius+60){
      const dx=cx-px, dy=cy-py;
      const d=Math.hypot(dx,dy)||1;
      player.vx += (dx/d)*0.12;
      player.vy += (dy/d)*0.12;
    }

    return true;
  });
}

function drawBossRings(now){
  for(const r of bossRings){
    const t=(now-r.created)/(r.ttl||900);
    if(t<0 || t>1) continue;
    const radius=(r.maxR||300)*t;
    ctx.save();
    ctx.globalAlpha = 0.55*(1-t);
    ctx.lineWidth = 8;
    ctx.shadowColor = '#000000'; ctx.shadowBlur = 25; ctx.strokeStyle = 'rgba(255,255,0,0.85)';
    ctx.beginPath();
    ctx.arc(r.x, r.y, radius, 0, Math.PI*2);
    ctx.stroke();
    ctx.restore();
  }
}



// --- MARZ SUPER: expanding magic zone ---
// Active only when Marz uses his Super.
let magicZone=null;
function updateMagicZone(now){
  if(!magicZone) return;
  if(now >= magicZone.endsAt){ magicZone = null; return; }

  // Expand slowly over the full duration
  const t = Math.max(0, Math.min(1, (now - magicZone.startsAt) / magicZone.durationMs));
  magicZone.radius = magicZone.startRadius + (magicZone.maxRadius - magicZone.startRadius) * t;

  // Periodic damage to enemies inside
  if(!magicZone.lastTick) magicZone.lastTick = now;
  if(now - magicZone.lastTick >= magicZone.tickMs){
    magicZone.lastTick = now;
    for(let i=enemies.length-1;i>=0;i--){
      const e=enemies[i];
      const ex=e.x+e.width/2, ey=e.y+e.height/2;
      const d=Math.hypot(ex-magicZone.x, ey-magicZone.y);
      if(d <= magicZone.radius){
        const dmg=Math.round(magicZone.damagePerTick);
        const _dmg=dmg; const _final=applyEnemyDamage(e,_dmg);
        showDamageNumber(e.x,e.y,_final);
        // colorful hit FX
        createParticles(ex,ey, magicZone.colors[(magicZone.colorIdx++)%magicZone.colors.length], 10, 4);
        if(e.hp<=0){
          createParticles(e.x,e.y,'#fff176',30,6);
          dropStellarBonusAtIndexIfNeeded(i);
          enemies.splice(i,1);
          applyScore(100*currentLevel);
        addKill(); }
      }
    }

    // ambient zone particles (center swirl)
    createParticles(magicZone.x, magicZone.y, magicZone.colors[(magicZone.colorIdx++)%magicZone.colors.length], 18, 4);
  }
}

function drawMagicZone(now){
  if(!magicZone) return;
  const t = Math.max(0, Math.min(1, (now - magicZone.startsAt) / magicZone.durationMs));
  const pulse = 0.5 + 0.5*Math.sin(now/240);

  ctx.save();
  ctx.globalAlpha = 0.18 + 0.18*(1-t);
  const grad = ctx.createRadialGradient(magicZone.x, magicZone.y, 10, magicZone.x, magicZone.y, magicZone.radius);
  grad.addColorStop(0, 'rgba(255,0,255,0.55)');
  grad.addColorStop(0.5, 'rgba(0,229,255,0.35)');
  grad.addColorStop(1, 'rgba(255,241,118,0.08)');
  ctx.shadowColor = '#000000'; ctx.shadowBlur = 25; ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.arc(magicZone.x, magicZone.y, magicZone.radius, 0, Math.PI*2);
  
ctx.shadowColor = '#000000';
ctx.shadowBlur = 25;

ctx.fill();

  // rings
  ctx.globalAlpha = 0.55;
  ctx.lineWidth = 6 + 6*pulse;
  ctx.shadowColor = '#000000'; ctx.shadowBlur = 25; ctx.strokeStyle = 'rgba(255,0,255,0.55)';
  ctx.beginPath(); ctx.arc(magicZone.x, magicZone.y, magicZone.radius*(0.35+0.05*pulse), 0, Math.PI*2); ctx.stroke();
  ctx.shadowColor = '#000000'; ctx.shadowBlur = 25; ctx.strokeStyle = 'rgba(0,229,255,0.55)';
  ctx.beginPath(); ctx.arc(magicZone.x, magicZone.y, magicZone.radius*(0.65+0.06*(1-pulse)), 0, Math.PI*2); ctx.stroke();
  ctx.shadowColor = '#000000'; ctx.shadowBlur = 25; ctx.strokeStyle = 'rgba(255,241,118,0.55)';
  ctx.beginPath(); ctx.arc(magicZone.x, magicZone.y, magicZone.radius, 0, Math.PI*2); ctx.stroke();

  ctx.restore();
}

function isPointInsideMagicZone(x,y){
  if(!magicZone) return false;
  const now=Date.now();
  if(now >= magicZone.endsAt) return false;
  return Math.hypot(x-magicZone.x, y-magicZone.y) <= magicZone.radius;
}


// --- PDOR SUPER: 7 luminous orbiting rings (slow + damage) ---
let pdorOrbs = null;
function startPdorOrbs(owner, now){
  const durationMs = 8000;
  const count = 7;

  pdorOrbs = {
    ownerType: owner && owner.type,
    startsAt: now,
    endsAt: now + durationMs,
    orbs: [],
    extraSpawnTimes: [ now + Math.floor(durationMs*(0.25 + Math.random()*0.35)), now + Math.floor(durationMs*(0.60 + Math.random()*0.30)) ],
    extraSpawned: 0
  };

  const margin = 70;
  for(let i=0;i<count;i++){
    const cx = margin + Math.random()*(canvas.width - margin*2);
    const cy = margin + Math.random()*((canvas.height-30) - margin*2);
    const orbitR = 26 + Math.random()*34;
    const ang0 = Math.random()*Math.PI*2;
    const angSpeed = (Math.random()<0.5?-1:1) * (0.036 + Math.random()*0.028); // rad/ms

    pdorOrbs.orbs.push({
      cx, cy,
      orbitR,
      ang: ang0,
      angSpeed,
      x: cx + Math.cos(ang0)*orbitR,
      y: cy + Math.sin(ang0)*orbitR,
      pulses: [],
      lastEmit: now - Math.random()*160,
      hitCd: new Map()
    });
  }

  // visual burst
  if(owner){
    createParticles(owner.x+owner.width/2, owner.y+owner.height/2, '#000000', 36, 6);
  }
}

function _applyEnemyTempSlow(enemy, factor, untilMs){
  const now = Date.now();
  const until = now + (untilMs||0);
  // store current speed once (so we restore properly even if the enemy was already slowed by other effects)
  if(enemy._pdorSlowUntil && now < enemy._pdorSlowUntil){
    // extend only
    enemy._pdorSlowUntil = Math.max(enemy._pdorSlowUntil, until);
    return;
  }
  enemy._pdorSpeedBefore = enemy.speed;
  enemy.speed = (enemy.speed||0) * (factor!=null?factor:0.5);
  enemy._pdorSlowUntil = until;
}

function updatePdorOrbs(now){
  if(!pdorOrbs) return;

  if(now >= pdorOrbs.endsAt){
    // restore any remaining pdor slow
    for(const e of enemies){
      if(e && e._pdorSlowUntil){
        if(typeof e._pdorSpeedBefore === 'number') e.speed = e._pdorSpeedBefore;
        e._pdorSpeedBefore = undefined;
        e._pdorSlowUntil = 0;
      }
    }
    pdorOrbs = null;
    return;
  }

  // restore expired slow effects
  for(const e of enemies){
    if(e && e._pdorSlowUntil && now >= e._pdorSlowUntil){
      if(typeof e._pdorSpeedBefore === 'number') e.speed = e._pdorSpeedBefore;
      e._pdorSpeedBefore = undefined;
      e._pdorSlowUntil = 0;
    }
  }

  const ringThickness = 7;      // "molto ristrette"
  const emitEvery = 180;        // ms
  const pulseSpeed = 0.24;      // px/ms
  const pulseMax = 56;          // px
  const pulseMin = 10;          // px
  const perTargetHitCd = 180;   // ms (per orb)

  for(const orb of pdorOrbs.orbs){
    orb.ang += orb.angSpeed;
    orb.x = orb.cx + Math.cos(orb.ang)*orb.orbitR;
    orb.y = orb.cy + Math.sin(orb.ang)*orb.orbitR;

    // emit pulses
    if(now - orb.lastEmit >= emitEvery){
      orb.lastEmit = now;
      orb.pulses.push({ r: pulseMin, born: now });
    }

    // advance pulses
    for(let p=orb.pulses.length-1;p>=0;p--){
      const pulse = orb.pulses[p];
      pulse.r += pulseSpeed * (now - (pulse._lastNow||now));
      pulse._lastNow = now;
      if(pulse.r > pulseMax){
        orb.pulses.splice(p,1);
        continue;
      }

      // collision with enemies on the ring band
      for(let i=enemies.length-1;i>=0;i--){
        const e=enemies[i];
        if(!e) continue;
        const ex=e.x+e.width/2, ey=e.y+e.height/2;
        const d=Math.hypot(ex-orb.x, ey-orb.y);
        if(Math.abs(d - pulse.r) <= ringThickness){
          const last = orb.hitCd.get(e) || 0;
          if(now - last < perTargetHitCd) continue;
          orb.hitCd.set(e, now);

          const dmg = 27;
          const _final = applyEnemyDamage(e, dmg);
          showDamageNumber(e.x, e.y, _final);
          createParticles(ex, ey, '#000000', 10, 4);

          _applyEnemyTempSlow(e, 0.5, 1000);

          if(e.hp<=0){
            createParticles(e.x,e.y,'#fff176',30,6);
            dropStellarBonusAtIndexIfNeeded(i);
            enemies.splice(i,1);
            applyScore(100*currentLevel);
          addKill(); }
        }
      }
    }

    // keep hit map small
    if(orb.hitCd.size>90){
      // prune old entries
      for(const [k,t] of orb.hitCd.entries()){
        if(!k || now-t>1500) orb.hitCd.delete(k);
      }
    }
  }
}

function drawPdorOrbs(now){
  if(!pdorOrbs) return;

  ctx.save();
  ctx.globalCompositeOperation='lighter';
  ctx.shadowColor = 'rgba(255,255,255,0.9)';
  ctx.shadowBlur = 25;


  for(const orb of pdorOrbs.orbs){
    // core glow
    const pulse = 0.55 + 0.45*Math.sin((now+orb.cx)/240);
    ctx.globalAlpha = 0.55 + 0.25*pulse;
    const grad = ctx.createRadialGradient(orb.x, orb.y, 0, orb.x, orb.y, 30);
    grad.addColorStop(0, 'rgba(255,255,255,1)');
    grad.addColorStop(0.4, 'rgba(255,255,255,0.8)');
    grad.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.shadowColor = '#000000'; ctx.shadowBlur = 25; ctx.fillStyle = grad;

    ctx.beginPath();
    ctx.arc(orb.x, orb.y, 7 + 2*pulse, 0, Math.PI*2);
    
ctx.shadowColor = '#000000';
ctx.shadowBlur = 25;

ctx.fill();

    // pulses (thin circles)
    for(const p of orb.pulses){
      const a = 0.40 + 0.25*Math.sin((now - p.born)/90);
      ctx.globalAlpha = a;
      ctx.lineWidth = 3;
      ctx.shadowColor = '#000000'; ctx.shadowBlur = 25; ctx.strokeStyle = 'rgba(255,255,255,0.95)';
      ctx.beginPath();
      ctx.arc(orb.x, orb.y, p.r, 0, Math.PI*2);
      ctx.stroke();
    }
  }

  ctx.restore();
}


let lasers=[];
let tempBeams=[]; // Tempostorm lasers (friendly beams)
let wolves=[]; // H√®cate Super: lupi amichevoli
let keys={};
let lastSecondTick=Date.now();
let levelAdvanceLock=false;
let shakeAmount=0;

const images={rooney:new Image(),jimmy:new Image(),jeff:new Image(),voltryx:new Image(),kouvagia:new Image(),salsy:new Image(),tempostorm:new Image() ,marz:new Image(),hecate:new Image(),pdor:new Image(),bane:new Image(),hendel:new Image(),kaerith:new Image(),cosmo:new Image()};
images.rooney.src='https://i.postimg.cc/Vs0G7ZPV/rooneyy.png';
images.jimmy.src='https://i.postimg.cc/13Qzjdn4/jimmyy.png';
images.jeff.src='https://i.postimg.cc/gkQN3v7R/jeff-(1).png';
images.voltryx.src='https://i.postimg.cc/GhjK4WCy/Voltryxx.png';
images.kouvagia.src='https://i.postimg.cc/gj1xjk0G/kouvagiaa-(1).png';
images.salsy.src='https://i.ibb.co/20zSkjsB/salsy.png';
images.tempostorm.src='https://i.postimg.cc/mkzj763m/tempostorm.png';
images.marz.src='https://i.postimg.cc/j5WJZL5X/marz.png';
images.hecate.src='https://i.postimg.cc/9QjRg424/hecate.png';
images.marcus=new Image(); images.marcus.src='https://i.postimg.cc/MpKjhyKD/image.png';
images.lucien=new Image(); images.lucien.src='https://i.postimg.cc/XvqZgdhz/Lucien-(1).png';
images.pdor=new Image(); images.pdor.src='https://i.postimg.cc/y8nHcqnw/pdor24.png';
images.bane=new Image(); images.bane.src='https://i.postimg.cc/Kjc7KMzX/bane.png';
images.hendel.src='https://i.postimg.cc/g2G7LYjr/hendel.png';
images.kaerith.src='https://i.postimg.cc/pLBZRcHy/Kaerith.png';
images.cosmo.src='https://i.postimg.cc/yY5Z6hHP/cosmo.png';
const wolfImg=new Image(); wolfImg.src='https://i.postimg.cc/4y9yBGFw/lupo.png';
const imagesEvo={jimmy:new Image(),rooney:new Image(),jeff:new Image()};
imagesEvo.jimmy.src='https://i.postimg.cc/g26ZX0n9/jimmyevo.png';
imagesEvo.rooney.src='https://i.postimg.cc/x8Ck0fWs/rooneyevo.png';
imagesEvo.jeff.src='https://i.postimg.cc/FsYf8KbV/jeffevo.png';
// --- Pickup images (keep pickup size small; same dimensions already used) ---
const pickupImgs={
  heal: new Image(),
  shield: new Image(),
  speed: new Image(),
  atk: new Image(),
  super: new Image(),
  gold: new Image(),
  stellar: new Image(),
  malus: new Image(),
};
pickupImgs.heal.src='https://i.postimg.cc/c4jNccLC/heal.png';
pickupImgs.shield.src='https://i.postimg.cc/9XnS3QHh/shield.png';
pickupImgs.speed.src='https://i.postimg.cc/DzCV8QHb/speed.png';
pickupImgs.atk.src='https://i.postimg.cc/cHjVcxsS/ATK.png';
pickupImgs.super.src='https://i.postimg.cc/3rss4xSD/Super.png';
pickupImgs.gold.src='https://i.postimg.cc/wjVZGc6h/gold.png';
pickupImgs.stellar.src='https://i.postimg.cc/7hhNdJpp/bossbonus.png';
pickupImgs.malus.src='https://i.postimg.cc/tT1cJKFm/malus.png';
pickupImgs.furia = new Image(); pickupImgs.furia.src='https://i.postimg.cc/BvCsTjYD/furia.png';
pickupImgs.ice = new Image(); pickupImgs.ice.src='https://i.postimg.cc/GmF1RB1k/ice.png';

function getPickupImage(type){
  // internal type names
  const key = (type==='shieldPickup') ? 'shield' : type;
  return pickupImgs[key] || null;
}
 
const enemyImages={
  slime:new Image(),drone:new Image(),boss1:new Image(),mech:new Image(),
  shadow:new Image(),boss2:new Image(),shooter:new Image(),attacker:new Image(),boss3:new Image(),
  veleno:new Image(),oneyes:new Image(),boss4:new Image(),boss5:new Image(),archer:new Image(),glacial:new Image()
};
enemyImages.slime.src='https://i.postimg.cc/NFVhJNLC/pixelcut-export-(2).png';
enemyImages.drone.src='https://i.postimg.cc/13x9HtxZ/image-(1).png';
enemyImages.boss1.src='https://i.postimg.cc/B6bmxMJt/boss1-(1).png';
enemyImages.mech.src='https://i.postimg.cc/qqkys7cT/mech-(1).png';
enemyImages.shadow.src='https://i.postimg.cc/tgWx86Dv/shadow-(1).png';
enemyImages.boss2.src='https://i.postimg.cc/Bvpq8QnR/boss2-(1).png';
enemyImages.shooter.src='https://i.postimg.cc/yNxVZC3D/shooter-(1).png';
enemyImages.attacker.src='https://i.postimg.cc/sxVHMs1H/attacker.png';
enemyImages.boss3.src='https://i.postimg.cc/xjzKWcTs/boss3-(1).png';


enemyImages.veleno.src='https://i.postimg.cc/3xNWGRWY/veleno.png';
enemyImages.oneyes.src='https://i.postimg.cc/g2xkJTBG/oneyes.png';
enemyImages.boss4.src='https://i.postimg.cc/8c9bHWff/unnamed-(2).png';
enemyImages.boss5.src='https://i.postimg.cc/wvGJm86S/boss5.png';
enemyImages.archer.src='https://i.postimg.cc/VLSg4gpV/archer.png';
enemyImages.glacial.src='https://i.postimg.cc/W1LG8vMN/glacial.png';

// ===== Bestiario (Nemici & Boss) - sblocco globale (tutti i personaggi) =====
const ENEMY_SEEN_KEY='jeffsChronicles_enemySeen_v1';
function loadEnemySeen(){
  try{
    const raw=localStorage.getItem(ENEMY_SEEN_KEY);
    return raw ? JSON.parse(raw) : {};
  }catch(e){ return {}; }
}
function saveEnemySeen(map){
  try{ localStorage.setItem(ENEMY_SEEN_KEY, JSON.stringify(map||{})); }catch(e){}
}
let enemySeen = loadEnemySeen();
function markEnemySeen(type){
  if(!type) return;
  if(!enemySeen[type]){
    enemySeen[type]=true;
    saveEnemySeen(enemySeen);
  }
}

// Dati descrittivi (nome + descrizione + chiave immagine)
const enemyGuideData={
  slime:{ name:'SLIME', imgKey:'slime', desc:'Creatura base gelatinosa. Lenta, prevedibile, pensata per mettere pressione numerica pi√π che tecnica. Insegue costantemente il giocatore e infligge danno da contatto.  HP: 45‚Äì50 ‚≠ê‚≠ê‚òÜ‚òÜ‚òÜ Danno: 9‚Äì10 ‚≠ê‚≠ê‚òÜ‚òÜ‚òÜ Velocit√†:   ‚≠ê‚≠ê‚òÜ‚òÜ‚òÜ'},
  drone:{ name:'DRONE', imgKey:'drone', desc:'Unit√† volante veloce e nervosa, progettata per punire chi resta fermo.  Movimento rapido e irregolare, attacco da contatto. HP: ~40 ‚≠ê‚≠ê‚òÜ‚òÜ‚òÜ Danno: 11‚Äì12 ‚≠ê‚≠ê‚≠ê‚òÜ‚òÜ Velocit√†: ‚≠ê‚≠ê‚≠ê‚≠ê‚òÜ'},
  mech:{ name:'MECH', imgKey:'mech', desc:'Nemico corazzato e resistente, fa da ‚Äútank‚Äù nelle ondate.  Avanza lentamente verso il giocatore e colpisce a contatto. HP: 60‚Äì65 ‚≠ê‚≠ê‚≠ê‚≠ê‚òÜ Danno:  16-17 ‚≠ê‚≠ê‚≠ê‚òÜ‚òÜ Velocit√†: ‚≠ê‚≠ê‚òÜ‚òÜ‚òÜ'},
  shadow:{ name:'SHADOW', imgKey:'shadow', desc:'Entit√† oscura estremamente aggressiva, specializzata nel combattimento ravvicinato. Insegue molto velocemente, attacco immediato a contatto. HP: 50‚Äì52 ‚≠ê‚≠ê‚≠ê‚òÜ‚òÜ Danno: 17‚Äì18 ‚≠ê‚≠ê‚≠ê‚≠ê‚òÜ Velocit√†: ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê'},
  shooter:{ name:'SHOOTER', imgKey:'shooter', desc:'Attaccante a distanza che costringe il giocatore a schivare costantemente. Spara proiettili dalla distanza mantenendo posizione.  HP: 45 ‚≠ê‚≠ê‚òÜ‚òÜ‚òÜ Danno: 20‚Äì21 ‚≠ê‚≠ê‚≠ê‚≠ê‚òÜ Velocit√†: ‚≠ê‚≠ê‚≠ê‚òÜ‚òÜ'},
  attacker:{ name:'ATTACKER', imgKey:'attacker', desc:'Assalitore aggressivo con pattern ‚Äúhit & run‚Äù. Carica, colpisce e si allontana rapidamente. HP: 90‚Äì99 ‚≠ê‚≠ê‚≠ê‚≠ê‚òÜ Danno: 17‚Äì19 ‚≠ê‚≠ê‚≠ê‚òÜ‚òÜ Velocit√†: ‚≠ê‚≠ê‚≠ê‚≠ê‚òÜ'},
  archer:{ name:'ARCHER', imgKey:'archer', desc:'Tiratore preciso che punisce il posizionamento sbagliato. Spara frecce a distanza, ricarica tra un colpo e l‚Äôaltro. HP: 78‚Äì86 ‚≠ê‚≠ê‚≠ê‚òÜ‚òÜ Danno: 14‚Äì15 ‚≠ê‚≠ê‚≠ê‚òÜ‚òÜ Velocit√†: ‚≠ê‚≠ê‚≠ê‚òÜ‚òÜ'},
  glacial:{ name:'GLACIAL', imgKey:'glacial', desc:'Nemico pesante del bioma ghiaccio, domina il controllo dell‚Äôarena. Movimento lento ma pressante, danno da contatto. HP: 150‚Äì165 ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Danno: 22‚Äì24 ‚≠ê‚≠ê‚≠ê‚≠ê‚òÜ Velocit√†: ‚≠ê‚≠ê‚òÜ‚òÜ‚òÜ'},
  veleno:{ name:'VELENO', imgKey:'veleno', desc:'Creatura tossica estremamente pericolosa se ignorata. Attacco a contatto che applica Poison. HP: 60‚Äì70 ‚≠ê‚≠ê‚≠ê‚òÜ‚òÜ Danno: 13‚Äì15 ‚≠ê‚≠ê‚≠ê‚òÜ‚òÜ Velocit√†: ‚≠ê‚≠ê‚≠ê‚òÜ‚òÜ Abilit√† passive: ‚ò†Ô∏è Poison ‚Äì danni nel tempo'},
  oneyes:{ name:'ONE-EYE', imgKey:'oneyes', desc:'Entit√† strategica che mantiene distanza e punisce inseguimenti sbagliati. Avanza a scatti, attacca quando il giocatore si espone con attacchi a laser precisi e letali con danni continui se si rimane dentro il raggio del laser. HP: 55‚Äì60 ‚≠ê‚≠ê‚≠ê‚òÜ‚òÜ Danno: 8‚Äì9 ‚≠ê‚≠ê‚òÜ‚òÜ‚òÜ Velocit√†: ‚≠ê‚≠ê‚òÜ‚òÜ‚òÜ'},
  boss1:{ name:'BOSS I', imgKey:'boss1', desc:'HP: 150 ‚≠ê‚≠ê‚≠ê‚òÜ‚òÜ Danno: 20 ‚≠ê‚≠ê‚≠ê‚òÜ‚òÜ Velocit√†: ‚≠ê‚≠ê‚òÜ‚òÜ‚òÜ Passiva: ‚ùå | Boss introduttivo, pressione costante.'},
  boss2:{ name:'BOSS II', imgKey:'boss2', desc:'HP: 300 ‚≠ê‚≠ê‚≠ê‚≠ê‚òÜ Danno: 27 ‚≠ê‚≠ê‚≠ê‚≠ê‚òÜ Velocit√†: ‚≠ê‚≠ê‚≠ê‚òÜ‚òÜ Passiva: ‚ùå | Molto pi√π aggressivo, richiede gestione super.'},
  boss3:{ name:'BOSS III', imgKey:'boss3', desc:'HP: 666 ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Danno:  33 ‚≠ê‚≠ê‚≠ê‚≠ê‚òÜ Velocit√†: ‚≠ê‚≠ê‚òÜ‚òÜ‚òÜ Passiva: ‚ùå | Spartiacque del gioco, alta difficolt√† tecnica.'},
  boss4:{ name:'BOSS IV', imgKey:'boss4', desc:'HP: 900 ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Danno: 30 ‚≠ê‚≠ê‚≠ê‚òÜ‚òÜ Velocit√†: ‚≠ê‚≠ê‚òÜ‚òÜ‚òÜ Attacco: ventaglio 180¬∞ + onda circolare che danneggia e attira.'},
  boss5:{ name:'BOSS V', imgKey:'boss5', desc:'HP: 800 ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Danno: 32 ‚≠ê‚≠ê‚≠ê‚≠ê‚òÜ Velocit√†: ‚≠ê‚≠ê‚òÜ‚òÜ‚òÜ Abilit√† passive: ‚ôªÔ∏è Rigenerazione HP ogni 28s üåä Onda di respinta üßä Rallentamento 50% per 2s se nel raggio'}
};

// Ordine consigliato nella lista
const enemyGuideOrder=['slime','drone','mech','shadow','shooter','attacker','veleno','oneyes','archer','glacial','boss1','boss2','boss3','boss4','boss5'];

function buildEnemyGuideUI(){
  const listEl=document.getElementById('enemyGuideList');
  const detailEl=document.getElementById('enemyGuideDetail');
  if(!listEl || !detailEl) return;

  listEl.innerHTML='';
  const unlocked = enemyGuideOrder.filter(k=>enemySeen && enemySeen[k] && enemyGuideData[k]);

  // empty state
  if(unlocked.length===0){
    // keep existing empty panel text
    detailEl.innerHTML = `<div class="enemy-guide-empty">
      <h3 style="margin:0 0 8px 0;color:#f39c12;">Nessun nemico sbloccato</h3>
      <p style="margin:0;color:#ddd;">Affronta un nemico o un boss almeno una volta per sbloccarlo qui.</p>
    </div>`;
    return;
  }

  function selectKey(key){
    const data=enemyGuideData[key];
    if(!data) return;

    // active state
    listEl.querySelectorAll('button').forEach(b=>b.classList.toggle('active', b.dataset.key===key));

    const img = enemyImages[data.imgKey];
    const src = (img && img.src) ? img.src : '';
    detailEl.innerHTML = `
      <div class="enemy-guide-detail-inner">
        <img src="${src}" alt="${data.name}">
        <div>
          <h3>${data.name}</h3>
          <p>${data.desc}</p>
        </div>
      </div>
    `;
  }

  for(const key of unlocked){
    const data=enemyGuideData[key];
    const btn=document.createElement('button');
    btn.type='button';
    btn.dataset.key=key;

    const img = enemyImages[data.imgKey];
    const src = (img && img.src) ? img.src : '';

    btn.innerHTML = `<img class="enemy-mini" src="${src}" alt="${data.name}"><span>${data.name}</span>`;
    btn.addEventListener('click', ()=>selectKey(key));
    listEl.appendChild(btn);
  }

  // default selection: first unlocked
  selectKey(unlocked[0]);
}

const characterStats={
  jimmy:{
    hp:400,
    speed:6.5,
    damage:47,
    range:600,
    cooldown:800,
    name:'Jimmy',
    attackType:'grapple',
    superCooldown:7000,
    superDuration:3000
  },
  rooney:{
    hp:520,
    speed:5,
    damage:Math.round(80*DAMAGE_MULT),
    range:150,
    cooldown:520,
    name:'Rooney',
    attackType:'punch',
    superCooldown:13000,
    superDuration:750
  },
  jeff:{
    hp:450, 
    speed:6,
    damage:Math.round(57*DAMAGE_MULT), // 38
    range:Math.round(320*JEFF_ATTACK_RANGE_MULT),
    cooldown:700,
    name:'Jeff',
    attackType:'sword',
    superCooldown:11000,
    superDuration:2800
  },
  voltryx:{
    hp:460, 
    speed:7,               
    damage:Math.round(55*DAMAGE_MULT),
    range:Math.round(600), 
    cooldown:650,
    name:'Voltryx',
    attackType:'hybrid',
    superCooldown:9000,
    superDuration:1500 
  },
  kouvagia:{
    hp:470,
    speed:6,
    damage:40,
    range:160,
    cooldown:880,
    name:'Kouvagia',
    attackType:'kouvagia',
    superCooldown:25000,
    superDuration:600
  },
  salsy:{
    hp:460,
    speed:6.5,  // leggermente pi√π veloce di prima
    damage:33,       // per colpo (x2)
    range:330,       // medio ravvicinata
    cooldown:750,
    name:'Salsy',
    attackType:'salsySword',
    superCooldown:6000,
    superDuration:400
  },
  tempostorm:{
  hp:490,
  speed:5.25, // leggermente piu di Rooney
  damage:40,      // hit iniziale (extra +30 se il nemico resta nel fascio)
  range:400,
  cooldown:850,
  name:'Tempostorm',
  attackType:'tempostormLaser',
  superCooldown:50000,
  superDuration:500
},
  marz:{
    hp:410,
    speed:5.5,
    damage:40,
    tripleDamage:[40,50,60],
    range:480,
    cooldown:820,
    name:'Marz',
    attackType:'magic',
    superCooldown:20000,
    superDuration:2200
  }

  ,
  marcus:{
    hp:450,
    speed:6,
    damage:15,
    range:650,
    cooldown:900,
    name:'Marcus',
    attackType:'marcusStream',
    superCooldown:27000,
    superDuration:10000
  },
  lucien:{
    hp:430,
    speed:6.7, // leggermente sopra la media
    damage:15,      // per colpo (x4)
    range:220,      // molto ravvicinato
    cooldown:700,
    name:'Lucien',
    attackType:'lucienBlade',
    superCooldown:21000,
    superDuration:450
  },

  pdor:{
    hp:470,
    speed:5.5,
    damage:42,
    range:700,
    cooldown:180,
    name:'Pdor',
    attackType:'pdorDart',
    superCooldown:16000,
    superDuration:1000
  },


  bane:{
    hp:490,
    speed:5.5, // leggermente pi√π veloce di Tempostorm, ma sempre media-bassa
    damage:67,
    range:230,      // raggio medio-basso
    cooldown:650,   // swing ascia
    name:'Bane',
    attackType:'axeattack',
    superCooldown:60000,
    superDuration:8000
  },

  hendel:{
    hp:500,
    speed:5, // la pi√π bassa (o tra le pi√π basse) del gioco
    damage:120,
    range:160,
    cooldown:810, // attacco base molto lento
    name:'Hendel',
    attackType:'hammerattack',
    superCooldown:26000,
    superDuration:3000
  },

  kaerith:{
    hp:460,
    speed:6.5,
    damage:0,
    range:300,
    cooldown:1000, // fiammata continua
    name:'Kaerith',
    attackType:'kaerithFlame',
    superCooldown:21000,
    superDuration:6000
  },

  hecate:{
    hp:425,
    speed:7.5,
    damage:52,
    range:990,
    cooldown:900,
    name:'H√®cate',
    attackType:'hecateBow',
    superCooldown:22000,
    superDuration:700
  }

  ,
  cosmo:{
    hp:430,
    speed:7,
    damage:32,
    range:480,
    cooldown:800,
    name:'Cosmo',
    attackType:'cosmo',
    superCooldown: 44000,
    superDuration:7000
  }
};




const levelConfigs=[
  {enemyType:'slime',enemyHP:45,enemyDamage:9,enemySpeed:2*0.75,time:45,enemyCount:4},
  {enemyType:'slime',enemyHP:50,enemyDamage:10,enemySpeed:2*0.75,time:45,enemyCount:9 },
  {enemyType:'drone',enemyHP:40,enemyDamage:11,enemySpeed:3*0.75,time:40,enemyCount:6},
  {enemyType:'drone',enemyHP:40,enemyDamage:12,enemySpeed:3*0.75,time:40,enemyCount:7},
  {enemyType:'boss1',enemyHP:150,enemyDamage:20,enemySpeed:2.8*0.75,time:60,enemyCount:1},
  {enemyType:'mech',enemyHP:60,enemyDamage:16,enemySpeed:2.5*0.75,time:35,enemyCount:7},
  {enemyType:'shadow',enemyHP:50,enemyDamage:17,enemySpeed:4*0.75,time:30,enemyCount:6},
  {enemyType:'shadow',enemyHP:52,enemyDamage:18,enemySpeed:4 *0.75,time:30,enemyCount:6},
  {enemyType:'mech',enemyHP:65,enemyDamage:16,enemySpeed:2.5*0.75,time:35,enemyCount:8},
  {enemyType:'boss2',enemyHP:300,enemyDamage:27,enemySpeed:3*0.75,time:60,enemyCount:1},
  {enemyType:'shooter',enemyHP:45,enemyDamage:20,enemySpeed:2.5*0.75,time:45,enemyCount:5},
  {enemyType:'shooter',enemyHP:45,enemyDamage:21,enemySpeed:2.7*0.75,time:45,enemyCount:7},
  {enemyType:'attacker',enemyHP:90,enemyDamage:17,enemySpeed:3.2*0.75,time:50,enemyCount:5},
  {enemyType:'attacker',enemyHP:99,enemyDamage:19,enemySpeed:3.4*0.75,time:60,enemyCount:6},
  {enemyType:'boss3',enemyHP:666,enemyDamage:33,enemySpeed:2.4*0.75,time:100,enemyCount:1}
  ,{enemyType:'veleno',enemyHP:60,enemyDamage:13,enemySpeed:2.8*0.75,time:50,enemyCount:7} // Level 16
  ,{enemyType:'veleno',enemyHP:70,enemyDamage:15,enemySpeed:2.9*0.75,time:50,enemyCount:9} // Level 17
  ,{enemyType:'oneyes',enemyHP:55,enemyDamage:8,enemySpeed:2.1*0.75,time:55,enemyCount:4} // Level 18
  ,{enemyType:'oneyes',enemyHP:60,enemyDamage:9,enemySpeed:2.3*0.75,time:55,enemyCount:5} // Level 19
  ,{enemyType:'boss4',enemyHP:900,enemyDamage:30,enemySpeed:4.2,time:180,enemyCount:1} // Level 20
  ,{enemyType:'archer',enemyHP:78,enemyDamage:14,enemySpeed:2.3*0.75,time:65,enemyCount:4} // Level 21 (Ice)
  ,{enemyType:'archer',enemyHP:86,enemyDamage:15,enemySpeed:2.4*0.75,time:65,enemyCount:5} // Level 22 (Ice)
  ,{enemyType:'glacial',enemyHP:150,enemyDamage:22,enemySpeed:2.3*0.75,time:70,enemyCount:2} // Level 23 (Ice)
  ,{enemyType:'glacial',enemyHP:165,enemyDamage:24,enemySpeed:2.4*0.75,time:80,enemyCount:3} // Level 24 (Ice)

  ,{enemyType:'boss5',enemyHP:800,enemyDamage:32,enemySpeed:2.2*0.75,time:200,enemyCount:1} // Level 25 (Boss V)
];

const RECORDS_KEY='pf_records_v19';

/* ===== Account Level System (v1) ===== */
const ACCOUNT_KEY = "pf_account_v1";
const ACCOUNT_DEFAULT = {
  level: 1,
  xp: 0,
  xpNeed: 100,
  totalXp: 0,
  schema: 2,
  stats: {totalKills:0, superUses:0, pickups:0, totalGoldPickups:0, bestMatchKills:0, totalDamage:0, totalScore:0, totalHeal:0, jimmySuperKills:0, jimmySuperUses:0, rooneySuperUses:0, jeffSuperUses:0, voltryxSuperUses:0, kouvagiaSuperUses:0, salsySuperUses:0, tempostormSuperUses:0, marzSuperUses:0, hecateSuperUses:0, marcusSuperUses:0, lucienSuperUses:0, pdorSuperUses:0, baneSuperUses:0, hendelSuperUses:0, kaerithSuperUses:0, cosmoSuperUses:0 },
  missions: [
  // 1000 kill missions
  { id:"m_jimmy_1000",    char:"jimmy",    target:1000, progress:0, xpReward:120, claimed:false, difficulty:null },
  { id:"m_rooney_1000",   char:"rooney",   target:1000, progress:0, xpReward:120, claimed:false, difficulty:null },
  { id:"m_jeff_1000",     char:"jeff",     target:1000, progress:0, xpReward:120, claimed:false, difficulty:null },

  // INTERMEDIA (giallo) - 200 XP
  { id:"m_goldpickups_50", title:"Raccogli 50 Pickups Gold (totali)", type:"goldPickups", target:50, progress:0, xpReward:200, claimed:false, difficulty:"mid" },

  { id:"m_voltryx_1000",    char:"voltryx",    target:1000, progress:0, xpReward:200, claimed:false, difficulty:"mid" },
  { id:"m_kouvagia_1000",   char:"kouvagia",   target:1000, progress:0, xpReward:200, claimed:false, difficulty:"mid" },
  { id:"m_salsy_1000",      char:"salsy",      target:1000, progress:0, xpReward:200, claimed:false, difficulty:"mid" },
  { id:"m_tempostorm_1000", char:"tempostorm", target:1000, progress:0, xpReward:200, claimed:false, difficulty:"mid" },
  { id:"m_marz_1000",       char:"marz",       target:1000, progress:0, xpReward:200, claimed:false, difficulty:"mid" },
  { id:"m_hecate_1000",     char:"hecate",     target:1000, progress:0, xpReward:200, claimed:false, difficulty:"mid" },
  { id:"m_cosmo_1000",      char:"cosmo",      target:1000, progress:0, xpReward:200, claimed:false, difficulty:"mid" },

  { id:"m_marcus_1000",   char:"marcus",   target:1000, progress:0, xpReward:200, claimed:false, difficulty:"mid" },
  { id:"m_lucien_1000",   char:"lucien",   target:1000, progress:0, xpReward:200, claimed:false, difficulty:"mid" },
  { id:"m_pdor_1000",     char:"pdor",     target:1000, progress:0, xpReward:200, claimed:false, difficulty:"mid" },
  { id:"m_bane_1000",     char:"bane",     target:1000, progress:0, xpReward:200, claimed:false, difficulty:"mid" },
  { id:"m_hendel_1000",   char:"hendel",   target:1000, progress:0, xpReward:200, claimed:false, difficulty:"mid" },
  { id:"m_kaerith_1000",  char:"kaerith",  target:1000, progress:0, xpReward:200, claimed:false, difficulty:"mid" },

  // FACILE (verde) - 100 XP
  // Missioni FACILI personaggio (100 XP): 500 kill con lo stesso personaggio
  { id:"e_bane_500", char:"bane", target:500, progress:0, xpReward:100, claimed:false, difficulty:"easy" },
  { id:"e_cosmo_500", char:"cosmo", target:500, progress:0, xpReward:100, claimed:false, difficulty:"easy" },
  { id:"e_hecate_500", char:"hecate", target:500, progress:0, xpReward:100, claimed:false, difficulty:"easy" },
  { id:"e_hendel_500", char:"hendel", target:500, progress:0, xpReward:100, claimed:false, difficulty:"easy" },
  { id:"e_jeff_500", char:"jeff", target:500, progress:0, xpReward:100, claimed:false, difficulty:"easy" },
  { id:"e_jimmy_500", char:"jimmy", target:500, progress:0, xpReward:100, claimed:false, difficulty:"easy" },
  { id:"e_jimmy_super_50", title:"Uccidi 50 nemici con la super di Jimmy", type:"jimmySuperKills", target:50, progress:0, xpReward:100, claimed:false, difficulty:"easy" },
  { id:"e_kaerith_500", char:"kaerith", target:500, progress:0, xpReward:100, claimed:false, difficulty:"easy" },
  { id:"e_kouvagia_500", char:"kouvagia", target:500, progress:0, xpReward:100, claimed:false, difficulty:"easy" },
  { id:"e_lucien_500", char:"lucien", target:500, progress:0, xpReward:100, claimed:false, difficulty:"easy" },
  { id:"e_marcus_500", char:"marcus", target:500, progress:0, xpReward:100, claimed:false, difficulty:"easy" },
  { id:"e_marz_500", char:"marz", target:500, progress:0, xpReward:100, claimed:false, difficulty:"easy" },
  { id:"e_pdor_500", char:"pdor", target:500, progress:0, xpReward:100, claimed:false, difficulty:"easy" },
  { id:"e_rooney_500", char:"rooney", target:500, progress:0, xpReward:100, claimed:false, difficulty:"easy" },
  { id:"e_salsy_500", char:"salsy", target:500, progress:0, xpReward:100, claimed:false, difficulty:"easy" },
  { id:"e_tempostorm_500", char:"tempostorm", target:500, progress:0, xpReward:100, claimed:false, difficulty:"easy" },
  { id:"e_voltryx_500", char:"voltryx", target:500, progress:0, xpReward:100, claimed:false, difficulty:"easy" },
  // Missioni FACILI (100 XP): usa la SUPER 40 volte (accumulabile)
  { id:"e_jimmy_super_40", type:"charSuperUses", char:"jimmy", target:40, progress:0, xpReward:100, claimed:false, difficulty:"easy" },
  { id:"e_rooney_super_40", type:"charSuperUses", char:"rooney", target:40, progress:0, xpReward:100, claimed:false, difficulty:"easy" },
  { id:"e_jeff_super_40", type:"charSuperUses", char:"jeff", target:40, progress:0, xpReward:100, claimed:false, difficulty:"easy" },
  { id:"e_voltryx_super_40", type:"charSuperUses", char:"voltryx", target:40, progress:0, xpReward:100, claimed:false, difficulty:"easy" },
  { id:"e_kouvagia_super_40", type:"charSuperUses", char:"kouvagia", target:40, progress:0, xpReward:100, claimed:false, difficulty:"easy" },
  { id:"e_salsy_super_40", type:"charSuperUses", char:"salsy", target:40, progress:0, xpReward:100, claimed:false, difficulty:"easy" },
  { id:"e_tempostorm_super_40", type:"charSuperUses", char:"tempostorm", target:40, progress:0, xpReward:100, claimed:false, difficulty:"easy" },
  { id:"e_marz_super_40", type:"charSuperUses", char:"marz", target:40, progress:0, xpReward:100, claimed:false, difficulty:"easy" },
  { id:"e_hecate_super_40", type:"charSuperUses", char:"hecate", target:40, progress:0, xpReward:100, claimed:false, difficulty:"easy" },
  { id:"e_marcus_super_40", type:"charSuperUses", char:"marcus", target:40, progress:0, xpReward:100, claimed:false, difficulty:"easy" },
  { id:"e_lucien_super_40", type:"charSuperUses", char:"lucien", target:40, progress:0, xpReward:100, claimed:false, difficulty:"easy" },
  { id:"e_pdor_super_40", type:"charSuperUses", char:"pdor", target:40, progress:0, xpReward:100, claimed:false, difficulty:"easy" },
  { id:"e_bane_super_40", type:"charSuperUses", char:"bane", target:40, progress:0, xpReward:100, claimed:false, difficulty:"easy" },
  { id:"e_hendel_super_40", type:"charSuperUses", char:"hendel", target:40, progress:0, xpReward:100, claimed:false, difficulty:"easy" },
  { id:"e_kaerith_super_40", type:"charSuperUses", char:"kaerith", target:40, progress:0, xpReward:100, claimed:false, difficulty:"easy" },
  { id:"e_cosmo_super_40", type:"charSuperUses", char:"cosmo", target:40, progress:0, xpReward:100, claimed:false, difficulty:"easy" },
  { id:"e_totalKills_500",    type:"totalKills", target:500,  progress:0, xpReward:100, claimed:false, difficulty:"easy" },
  { id:"e_matchKills_75",     type:"matchKills", target:75,   progress:0, xpReward:100, claimed:false, difficulty:"easy" },
  { id:"e_bossLevel10",       type:"bossLevel",  target:1,    progress:0, xpReward:100, claimed:false, difficulty:"easy", levelTarget:10 },
  { id:"e_superUses_50",      type:"superUses",  target:50,   progress:0, xpReward:100, claimed:false, difficulty:"easy" },
  { id:"e_pickups_100",       type:"pickups",    target:100,  progress:0, xpReward:100, claimed:false, difficulty:"easy" },
  { id:"e_totalKills_1000",   type:"totalKills",  target:1000,  progress:0, xpReward:100, claimed:false, difficulty:"easy" },
  { id:"e_totalHeal_5000",    title:"Recupera 5000 HP (totali)",    type:"totalHeal", target:5000,   progress:0, xpReward:100, claimed:false, difficulty:"easy" },
  { id:"e_record_jimmy_40000", type:"recordScore", char:"jimmy", target:40000, progress:0, xpReward:100, claimed:false, difficulty:"easy" },
  { id:"e_record_jeff_40000",  type:"recordScore", char:"jeff",  target:40000, progress:0, xpReward:100, claimed:false, difficulty:"easy" },
  { id:"e_record_rooney_40000",type:"recordScore", char:"rooney",target:40000, progress:0, xpReward:100, claimed:false, difficulty:"easy" },
  { id:"e_totalScore_175000",  type:"totalScore", target:175000, progress:0, xpReward:100, claimed:false, difficulty:"easy" },
  { id:"m_totalScore_500000",  type:"totalScore", target:500000, progress:0, xpReward:200, claimed:false, difficulty:"mid" },
  { id:"m_totalHeal_50000",   title:"Recupera 50000 HP (totali)",   type:"totalHeal", target:50000,  progress:0, xpReward:200, claimed:false, difficulty:"mid" },

// COMPLICATA (rosso) - 300 XP
{ id:"h_jimmy_super_750", title:"Uccidi 750 nemici con la super di Jimmy", type:"jimmySuperKills", target:750, progress:0, xpReward:300, claimed:false, difficulty:"hard" },
{ id:"h_level20_clear",    type:"reachLevel",      target:1,    progress:0, xpReward:300, claimed:false, difficulty:"hard", levelTarget:20 },
{ id:"h_totalKills_10000", type:"totalKills",      target:10000, progress:0, xpReward:300, claimed:false, difficulty:"hard" },
{ id:"h_level15_noSuper",  type:"noSuperToLevel",  target:1,    progress:0, xpReward:300, claimed:false, difficulty:"hard", levelTarget:15 },
{ id:"h_level15_noDamage", type:"noDamageToLevel", target:1,    progress:0, xpReward:300, claimed:false, difficulty:"hard", levelTarget:15 },

// Danni (totali)
{ id:"e_totalDmg_10000",  type:"totalDamage", target:10000,   progress:0, xpReward:100, claimed:false, difficulty:"easy" },
{ id:"m_totalDmg_100000", type:"totalDamage", target:100000,  progress:0, xpReward:200, claimed:false, difficulty:"mid" },
{ id:"h_totalDmg_2000000",type:"totalDamage", target:2000000, progress:0, xpReward:300, claimed:false, difficulty:"hard" },
{ id:"h_totalHeal_500000",  title:"Recupera 500000 HP (totali)",  type:"totalHeal", target:500000, progress:0, xpReward:300, claimed:false, difficulty:"hard" },


  // MITICA (platino) - 300 XP
  { id:"x_totalScore_1500000", type:"totalScore", target:1500000, progress:0, xpReward: 1000, claimed:false, difficulty:"mythic" },

]
};

function xpNeedForLevel(level){
  // XP necessario per passare dal livello 'level' al successivo
  level = Math.max(1, Math.floor(level||1));
  return Math.max(100, 100 * Math.pow(2, level-1));
}

function xpNeedForLevelOld(level){
  // Vecchia curva: xpNeed = floor(prev*1.2 + 12), partendo da 100 al livello 1->2
  level = Math.max(1, Math.floor(level||1));
  let need = 100;
  for(let l=1; l<level; l++){
    need = Math.floor(need*1.20 + 12);
  }
  return Math.max(50, need);
}

function recalcAccountFromTotalXp(showAnim){
  // Deriva level/xp/xpNeed dalla totalXp usando la curva attuale (100,200,400,...)
  const prevLevel = accountState.level;
  let total = Math.max(0, Math.floor(accountState.totalXp||0));
  let lvl = 1;
  let need = xpNeedForLevel(lvl);
  let safety=0;
  while(total >= need && safety++<200){
    total -= need;
    lvl += 1;
    need = xpNeedForLevel(lvl);
  }
  accountState.level = lvl;
  accountState.xpNeed = need;
  accountState.xp = total;

  if(showAnim && accountState.level > prevLevel){
    showLevelUpOverlay(accountState.level);
  }
}


function syncMissionsFromStats(){
  try{
    if(!accountState.stats) accountState.stats = { totalKills:0, superUses:0, pickups:0, totalGoldPickups:0, bestMatchKills:0, totalDamage:0, totalScore:0, totalHeal:0, jimmySuperKills:0, jimmySuperUses:0, rooneySuperUses:0, jeffSuperUses:0, voltryxSuperUses:0, kouvagiaSuperUses:0, salsySuperUses:0, tempostormSuperUses:0, marzSuperUses:0, hecateSuperUses:0, marcusSuperUses:0, lucienSuperUses:0, pdorSuperUses:0, baneSuperUses:0, hendelSuperUses:0, kaerithSuperUses:0, cosmoSuperUses:0 };

    for(const m of accountState.missions){
      if(!m || m.claimed) continue;

      if(m.type==='totalKills')    m.progress = Math.min(m.target, Math.floor(accountState.stats.totalKills||0));
      else if(m.type==='superUses')   m.progress = Math.min(m.target, Math.floor(accountState.stats.superUses||0));
      else if(m.type==='pickups')     m.progress = Math.min(m.target, Math.floor(accountState.stats.pickups||0));
      else if(m.type==='goldPickups') m.progress = Math.min(m.target, Math.floor(accountState.stats.totalGoldPickups||0));
      else if(m.type==='matchKills')  m.progress = Math.min(m.target, Math.floor(accountState.stats.bestMatchKills||0));
      else if(m.type==='totalDamage') m.progress = Math.min(m.target, Math.floor(accountState.stats.totalDamage||0));
      else if(m.type==='totalScore')  m.progress = Math.min(m.target, Math.floor(accountState.stats.totalScore||0));
      else if(m.type==='totalHeal')   m.progress = Math.min(m.target, Math.floor(accountState.stats.totalHeal||0));
      else if(m.type==='jimmySuperKills') m.progress = Math.min(m.target, Math.floor(accountState.stats.jimmySuperKills||0));
      else if(m.type==='charSuperUses'){
        const k = (m.char ? (String(m.char)+'SuperUses') : null);
        m.progress = Math.min(m.target, Math.floor((k && accountState.stats && accountState.stats[k])||0));
      }
      else if(accountState.stats && m.type && (m.type in accountState.stats)) m.progress = Math.min(m.target, Math.floor(accountState.stats[m.type]||0));
      else if(m.type==='recordScore') m.progress = Math.min(m.target, Math.floor((records && records[m.char])||0));
    }
  }catch(e){}
}


function loadAccount(){
  try{
    const raw = localStorage.getItem(ACCOUNT_KEY);
    if(!raw) return JSON.parse(JSON.stringify(ACCOUNT_DEFAULT));
    const a = JSON.parse(raw);

    const out = JSON.parse(JSON.stringify(ACCOUNT_DEFAULT));
    out.schema = 2;

    // legacy fields
    if(typeof a.level==="number") out.level = Math.max(1, Math.floor(a.level));
    if(typeof a.xp==="number") out.xp = Math.max(0, Math.floor(a.xp));

    // Source of truth: totalXp
    if(typeof a.totalXp==="number"){
      out.totalXp = Math.max(0, Math.floor(a.totalXp));
    }else{
      // Migrazione intelligente: ricostruisci TOTAL XP dalla vecchia curva (1.2+12) + livello + xp correnti
      // Esempio reale: livello 3 con 118/170 => 100 + 132 + 118 = 350 totalXP
      let sum=0;
      for(let l=1; l<out.level; l++){
        sum += xpNeedForLevelOld(l);
      }
      out.totalXp = sum + out.xp;
    }

    // placeholder;
    if(a.stats && typeof a.stats==='object'){
      out.stats = {
        totalKills: Math.max(0, Math.floor(a.stats.totalKills||0)),
        superUses: Math.max(0, Math.floor(a.stats.superUses||0)),
        pickups: Math.max(0, Math.floor(a.stats.pickups||0)),
        totalGoldPickups: Math.max(0, Math.floor(a.stats.totalGoldPickups||0)),
        bestMatchKills: Math.max(0, Math.floor(a.stats.bestMatchKills||0)),
        totalDamage: Math.max(0, Math.floor(a.stats.totalDamage||0)),
        totalScore: Math.max(0, Math.floor(a.stats.totalScore||0)),
        totalHeal: Math.max(0, Math.floor(a.stats.totalHeal||0)),
        jimmySuperKills: Math.max(0, Math.floor(a.stats.jimmySuperKills||0)),
        jimmySuperUses: Math.max(0, Math.floor(a.stats.jimmySuperUses||0)),
        rooneySuperUses: Math.max(0, Math.floor(a.stats.rooneySuperUses||0)),
        jeffSuperUses: Math.max(0, Math.floor(a.stats.jeffSuperUses||0)),
        voltryxSuperUses: Math.max(0, Math.floor(a.stats.voltryxSuperUses||0)),
        kouvagiaSuperUses: Math.max(0, Math.floor(a.stats.kouvagiaSuperUses||0)),
        salsySuperUses: Math.max(0, Math.floor(a.stats.salsySuperUses||0)),
        tempostormSuperUses: Math.max(0, Math.floor(a.stats.tempostormSuperUses||0)),
        marzSuperUses: Math.max(0, Math.floor(a.stats.marzSuperUses||0)),
        hecateSuperUses: Math.max(0, Math.floor(a.stats.hecateSuperUses||0)),
        marcusSuperUses: Math.max(0, Math.floor(a.stats.marcusSuperUses||0)),
        lucienSuperUses: Math.max(0, Math.floor(a.stats.lucienSuperUses||0)),
        pdorSuperUses: Math.max(0, Math.floor(a.stats.pdorSuperUses||0)),
        baneSuperUses: Math.max(0, Math.floor(a.stats.baneSuperUses||0)),
        hendelSuperUses: Math.max(0, Math.floor(a.stats.hendelSuperUses||0)),
        kaerithSuperUses: Math.max(0, Math.floor(a.stats.kaerithSuperUses||0)),
        cosmoSuperUses: Math.max(0, Math.floor(a.stats.cosmoSuperUses||0)),
      };
    }

    // placeholder; verr√† ricalcolato da totalXp
    out.xpNeed = xpNeedForLevel(out.level);

    // missions
    if(Array.isArray(a.missions)){
      for(const mm of out.missions){
        const found = a.missions.find(x=>x && x.id===mm.id);
        if(found){
          if(typeof found.progress==="number") mm.progress = Math.max(0, Math.floor(found.progress));
          if(typeof found.claimed==="boolean") mm.claimed = found.claimed;
        }
      }
    }
    return out;
  }catch(e){
    return JSON.parse(JSON.stringify(ACCOUNT_DEFAULT));
  }
}
function saveAccount(){ try{ localStorage.setItem(ACCOUNT_KEY, JSON.stringify(accountState)); }catch(e){} }


function normalizeAccountProgress(showAnim){
  // Allinea level/xp/xpNeed al totale. Se totalXp manca (legacy), lo ricostruiamo.
  try{
    if(!(typeof accountState.totalXp==="number")){
      let sum=0;
      for(let l=1; l<accountState.level; l++){
        sum += xpNeedForLevelOld(l);
      }
      accountState.totalXp = sum + (accountState.xp||0);
    }else{
      accountState.totalXp = Math.max(0, Math.floor(accountState.totalXp||0));
    }
    recalcAccountFromTotalXp(!!showAnim);
    syncMissionsFromStats();
    saveAccount();
  }catch(e){}
}

let accountState = loadAccount();

/* === MISSIONS CLAIM-ONCE (stable) === */
const MISSION_CLAIMS_KEY = "pf_mission_claims_v2";
function missionKey(m){
  // Deterministic key even if ids are missing/duplicated
  const type = (m && (m.type ?? "base")) + "";
  const char = (m && (m.char ?? "")) + "";
  const diff = (m && (m.difficulty ?? "")) + "";
  const target = (m && (m.target ?? "")) + "";
  const title = (m && (m.title ?? m.name ?? "")) + "";
  return [type,char,diff,target,title].join("|");
}
function loadMissionClaims(){
  try{
    const raw = localStorage.getItem(MISSION_CLAIMS_KEY);
    const arr = raw ? JSON.parse(raw) : [];
    return new Set(Array.isArray(arr) ? arr : []);
  }catch(e){ return new Set(); }
}
function saveMissionClaims(set){
  try{ localStorage.setItem(MISSION_CLAIMS_KEY, JSON.stringify(Array.from(set))); }catch(e){}
}
let missionClaims = loadMissionClaims();

function applyMissionClaimsToState(){
  try{
    if(!accountState || !Array.isArray(accountState.missions)) return;
    for(const m of accountState.missions){
      if(!m) continue;
      const k = missionKey(m);
      if(missionClaims.has(k)){
        m.claimed = true;
      }
      // ensure id exists (nice-to-have for debugging/UI)
      if(!m.id || typeof m.id!=="string" || !m.id.trim()){
        m.id = k;
      }
    }
  }catch(e){}
}

applyMissionClaimsToState();

normalizeAccountProgress(false);
let matchKills=0;
let matchHealMissionCount=0; // heal counted toward heal-missions in this run (capped)
let runUsedSuper=false;
let runTookDamage=false;


function accountXpPct(){
  const need = Math.max(1, accountState.xpNeed);
  return Math.max(0, Math.min(1, accountState.xp/need));
}

function applyAccountXp(xpGain){
  xpGain = Math.max(0, Math.floor(xpGain||0));
  if(xpGain<=0) return;

  accountState.totalXp = Math.max(0, Math.floor(accountState.totalXp||0)) + xpGain;

  recalcAccountFromTotalXp(true);
  saveAccount();
  refreshAccountUi(true);
}

function showXpFloat(text){
  const d=document.createElement("div");
  d.className="xp-float";
  d.textContent=text;
  document.body.appendChild(d);
  setTimeout(()=>{ try{ d.remove(); }catch(e){} }, 720);
}

function flyXpToAccountBtn(xpGain, doneCb){
  xpGain = Math.max(0, Math.floor(xpGain||0));
  const btn = document.getElementById('accountLevelBtn');
  if(!btn || xpGain<=0){
    try{ if(typeof doneCb==="function") doneCb(); }catch(e){}
    return;
  }

  const fly=document.createElement('div');
  fly.className='xp-fly';
  fly.textContent = `+${xpGain} XP`;

  // start at center of end screen (or screen center)
  const endScreen=document.getElementById('endScreen');
  let sx = window.innerWidth/2, sy = window.innerHeight/2;
  try{
    if(endScreen && endScreen.style.display!=='none'){
      const r=endScreen.getBoundingClientRect();
      sx = r.left + r.width/2;
      sy = r.top + Math.min(r.height*0.35, 180);
    }
  }catch(e){}

  fly.style.left = sx + 'px';
  fly.style.top  = sy + 'px';
  fly.style.transform = 'translate(-50%,-50%) scale(1)';
  fly.style.opacity = '1';
  document.body.appendChild(fly);

  // destination: center of account button
  const br = btn.getBoundingClientRect();
  const dx = br.left + br.width/2;
  const dy = br.top + br.height/2;

  // trigger transition
  requestAnimationFrame(()=>{
    fly.style.left = dx + 'px';
    fly.style.top  = dy + 'px';
    fly.classList.add('go');
  });

  const finish = ()=>{
    fly.removeEventListener('transitionend', finish);
    try{ fly.remove(); }catch(e){}
    try{ if(typeof doneCb==="function") doneCb(); }catch(e){}
  };
  fly.addEventListener('transitionend', finish);
  // safety timeout
  setTimeout(finish, 800);
}


function showLevelUpOverlay(newLevel){
  const ov=document.getElementById('levelUpOverlay');
  const lv=document.getElementById('levelUpNewLevel');
  if(lv) lv.textContent=String(newLevel);
  if(!ov) return;
  ov.classList.remove('show'); // restart anim
  void ov.offsetWidth;
  ov.classList.add('show');

  // extra juice
  try{ shakeScreen(9); }catch(e){}
  setTimeout(()=>{ try{ ov.classList.remove('show'); }catch(e){} }, 900);
}

function refreshAccountUi(animate){
  const lvEl=document.getElementById("accountLevelText");
  const miniXp=document.getElementById("accountXpMini");
  if(lvEl) lvEl.textContent=String(accountState.level);
  if(miniXp) miniXp.textContent = `${accountState.xp}/${accountState.xpNeed}`;

  const lv2=document.getElementById("accountMenuLevel");
  const xpEl=document.getElementById("accountMenuXp");
  const needEl=document.getElementById("accountMenuXpNeed");
  const bar=document.getElementById("accountXpBar");
  if(lv2) lv2.textContent=String(accountState.level);
  if(xpEl) xpEl.textContent=String(accountState.xp);
  if(needEl) needEl.textContent=String(accountState.xpNeed);

  if(bar){
    const pct = Math.round(accountXpPct()*100);
    if(animate){
      bar.style.transition="width 520ms ease";
      requestAnimationFrame(()=>{ bar.style.width = pct+"%"; });
    } else {
      bar.style.transition="width 260ms ease";
      bar.style.width = pct+"%";
    }
  }
  renderMissions();
}

function charLabel(c){
  if(c==='jimmy') return 'Jimmy';
  if(c==='rooney') return 'Rooney';
  if(c==='jeff') return 'Jeff';
  return c;
}

function missionTitle(m){
  if(m.type==='totalKills') return `Uccidi ${m.target} nemici totali`;
  if(m.type==='totalDamage') return `Causa ${m.target} danni totali`;
  if(m.type==='totalScore') return `Ottieni un punteggio totale superiore a ${m.target}`;
  if(m.type==='matchKills') return `Fai ${m.target} kill in una partita`;
  if(m.type==='bossLevel') return `Supera il livello ${m.levelTarget||10}`;
  if(m.type==='reachLevel') return `Sconfiggi il livello ${m.levelTarget||20}`;
  if(m.type==='noSuperToLevel') return `Supera il livello ${m.levelTarget||15} senza usare la super`;
  if(m.type==='noDamageToLevel') return `Subisci 0 danni fino al livello ${m.levelTarget||15}`;
  if(m.type==='superUses') return `Usa la super ${m.target} volte (totali)`;
  if(m.type==='charSuperUses') return `Utilizza la super di ${charLabel(m.char)} ${m.target} volte`;
  if(m.type==='jimmySuperKills') return `Uccidi ${m.target} nemici con la super di Jimmy`;
  if(m.type==='pickups') return `Raccogli ${m.target} pickup (totali)`;
  if(m.type==='totalHeal') return `Recupera ${m.target} HP (totali)`;
  if(m.type==='recordScore') return `Raggiungi record di ${m.target} con ${charLabel(m.char)}`;
  if(m.type==='goldPickups') return `Raccogli ${m.target} Pickups Gold (totali)`;
  return 'Missione';
}

let missionsSortMode = "difficulty"; // "difficulty" | "completion"

function renderMissions(){
  const wrap=document.getElementById("missionsList");
  if(!wrap) return;
  wrap.innerHTML="";


// Ordine missioni (selezionabile dall'UI):
// - "difficulty": ordine classico (base -> facile -> intermedia -> complicata -> mythic), riscattate in fondo
// - "completion": da quella pi√π vicina al completamento a quella pi√π lontana, riscattate in fondo

const missionsSorted = (() => {
  const list = accountState.missions.map((m,i)=>({m,i}));

  if(missionsSortMode === 'completion'){
    return list
      .sort((A,B)=>{
        const a=A.m, b=B.m;

        // riscattate sempre in fondo
        if(!!a.claimed !== !!b.claimed) return a.claimed ? 1 : -1;

        const aDone = (a.progress||0) >= (a.target||0);
        const bDone = (b.progress||0) >= (b.target||0);

        // completate (ma non ancora riscattate) in alto
        if(aDone !== bDone) return aDone ? -1 : 1;

        // Ordina per PROPORZIONE di completamento (pi√π alto = pi√π vicino)
        const aPct = (a.target>0) ? ((a.progress||0) / a.target) : 0;
        const bPct = (b.target>0) ? ((b.progress||0) / b.target) : 0;
        if(aPct !== bPct) return bPct - aPct;

        // tie-break: meno rimanenti (assoluto) prima
        const aRem = Math.max(0, (a.target||0) - (a.progress||0));
        const bRem = Math.max(0, (b.target||0) - (b.progress||0));
        if(aRem !== bRem) return aRem - bRem;

        return A.i - B.i; // stabile
      })
      .map(o=>o.m);
  }

  // default: difficulty
  return list
    .sort((A,B)=>{
      const a=A.m, b=B.m;

      // riscattate sempre in fondo
      if(!!a.claimed !== !!b.claimed) return a.claimed ? 1 : -1;

      const isBase = (x)=>['jimmy','rooney','jeff'].includes(x.char) && !x.type;

      // priorit√†:
      // 0 = base
      // 1 = facile
      // 2 = intermedia
      // 3 = complicata
      // 4 = mythic
      // 5 = altre
      const weight = (x)=>{
        if(isBase(x)) return 0;
        if(x.difficulty==='easy') return 1;
        if(x.difficulty==='mid') return 2;
        if(x.difficulty==='hard') return 3;
        if(x.difficulty==='mythic') return 4;
        return 5;
      };

      const dw = weight(a) - weight(b);
      if(dw!==0) return dw;

      return A.i - B.i; // stabile
    })
    .map(o=>o.m);
})();


  for(const m of missionsSorted){
    const done = m.progress >= m.target;
    const claimed = !!m.claimed || (missionClaims && missionClaims.has(missionKey(m)));

    const row=document.createElement("div");
    row.className="mission";

    const left=document.createElement("div");
    left.className="m-left";

    const title=document.createElement("div");
    title.className="m-title";
    const isBaseMission = (m && m.char && !m.type && ['jimmy','rooney','jeff'].includes(m.char));
    const badge = isBaseMission ? "<span class='mission-base'>BASE</span>" : (m.difficulty==='easy') ? "<span class='mission-easy'>FACILE</span>" : (m.difficulty==='mid') ? "<span class='mission-mid'>INTERMEDIA</span>" : (m.difficulty==='hard') ? "<span class='mission-hard'>COMPLICATA</span>" : (m.difficulty==='mythic') ? "<span class='mission-mythic'>MITICA</span>" : "";
    if(m.char && !m.type){
      title.innerHTML = `Fai ${m.target} kill con ${charLabel(m.char)} ${badge}`;
    } else {
      title.innerHTML = `${missionTitle(m)} ${badge}`;
    }

    const prog=document.createElement("div");
    prog.className="m-progress";
    const p = Math.min(m.target, m.progress);
    let unit='progresso';
    if(!m.type && m.char) unit='kill';
    else if(m.type==='totalHeal') unit='HP';
    else if(m.type==='totalScore' || m.type==='recordScore') unit='punti';
    else if(['bossLevel','reachLevel','noSuperToLevel','noDamageToLevel'].includes(m.type)) unit='completato';
    prog.textContent = `${p}/${m.target} ${unit} ‚Ä¢ Ricompensa: ${m.xpReward} XP`;

    const barwrap=document.createElement("div");
    barwrap.className="m-barwrap";
    const bar=document.createElement("div");
    bar.className="m-bar";
    const pct=Math.round(Math.min(1, (m.progress||0)/m.target)*100);
    bar.style.width=pct+"%";
    barwrap.appendChild(bar);

    left.appendChild(title);
    left.appendChild(prog);
    left.appendChild(barwrap);

    const btn=document.createElement("button");
    btn.type="button";
    btn.className="claim-btn";
    if(claimed){
      btn.classList.add("claimed");
      btn.textContent=" Riscattata";
      btn.disabled=true;
    }else if(done){
      btn.classList.add("ready");
      btn.textContent="Riscatta +XP";
      btn.disabled=false;
      btn.addEventListener("click", ()=>{
        const key = missionKey(m);
        if(missionClaims && missionClaims.has(key)) return; // already claimed
        if(missionClaims){ missionClaims.add(key); saveMissionClaims(missionClaims); }
        m.claimed=true;
        saveAccount();
        showXpFloat(`+${m.xpReward} XP`);
        applyAccountXp(m.xpReward);
        refreshAccountUi(true);
      });
    }else{
      btn.textContent="Non completata";
      btn.disabled=true;
    }

    row.appendChild(left);
    row.appendChild(btn);
    wrap.appendChild(row);
  }
}

function accountOnKill(charType, n=1){
  n = Math.max(1, Math.floor(n||1));
  // stats
  if(!accountState.stats) accountState.stats = { totalKills:0, superUses:0, pickups:0, totalGoldPickups:0, bestMatchKills:0, totalDamage:0, totalScore:0, totalHeal:0, jimmySuperKills:0 };
  accountState.stats.totalKills = Math.max(0, Math.floor(accountState.stats.totalKills||0)) + n;

  

  // Jimmy: kills fatti durante la SUPER (conteggio dedicato per missioni)
  try{
    if(player && player.type==='jimmy' && player.isDoingSuper){
      accountState.stats.jimmySuperKills = Math.max(0, Math.floor(accountState.stats.jimmySuperKills||0)) + n;
      for(const m of accountState.missions){
        if(m && !m.claimed && m.type==='jimmySuperKills'){
          m.progress = Math.min(m.target, Math.floor(accountState.stats.jimmySuperKills||0));
        }
      }
    }
  }catch(e){}
// character kill missions (solo missioni kill: quelle senza 'type')
  for(const m of accountState.missions){
    if(m.claimed) continue;
    if(m.char && m.char===charType && !m.type){
      m.progress = Math.min(m.target, (m.progress||0) + n);
    }
  }

  // easy missions
  for(const m of accountState.missions){
    if(m.claimed) continue;
    if(m.type==='totalKills'){
      m.progress = Math.min(m.target, Math.floor(accountState.stats.totalKills||0));
    }
  }
  saveAccount();
}



function accountOnScoreAdded(points){
  points = Math.max(0, Math.floor(points||0));
  if(points<=0) return;
  try{
    accountState.stats.totalScore = Math.max(0, Math.floor(accountState.stats.totalScore||0)) + points;
    for(const m of accountState.missions){
      if(!m.claimed && m.type==='totalScore'){
        m.progress = accountState.stats.totalScore;
      }
    }
    saveAccount();
  }catch(e){}
}
function accountOnDamageDealt(dmg){
  dmg = Math.max(0, Math.floor(dmg||0));
  if(dmg<=0) return;
  try{
    accountState.stats = accountState.stats || {};
    accountState.stats.totalDamage = Math.max(0, Math.floor(accountState.stats.totalDamage||0)) + dmg;

    for(const m of accountState.missions){
      if(m.claimed) continue;
      if(m.type==='totalDamage'){
        m.progress = Math.min(m.target, accountState.stats.totalDamage);
      }
    }
    saveAccount();
  }catch(e){}
}

function accountOnHeal(amount){
  amount = Math.max(0, Math.floor(amount||0));
  if(amount<=0) return;

  // Heal-missions should be accumulative across multiple runs, but not "farmable" in a single run.
  // We therefore CAP how much healing can contribute to missions per run.
  // (Healing in-game still happens normally; this cap only limits mission/stat progression.)
  try{
    accountState.stats = accountState.stats || {};

    // Per-run cap: at least 300, otherwise ~5x player's maxHP
    let maxHP = 0;
    try{
      maxHP = Math.max(0, Math.floor((player && (player.maxHP ?? player.maxHp ?? player.maxHpAlias ?? player.maxHealth)) || 0));
    }catch(e){ maxHP = 0; }
    const perRunCap = Math.max(300, Math.floor(maxHP * 5));

    // Amount that actually counts toward mission progress this run
    let add = amount;
    if(perRunCap > 0){
      const used = Math.max(0, Math.floor(matchHealMissionCount||0));
      const remaining = Math.max(0, perRunCap - used);
      add = Math.min(amount, remaining);
      matchHealMissionCount = used + add;
    }

    if(add<=0) return;

    accountState.stats.totalHeal = Math.max(0, Math.floor(accountState.stats.totalHeal||0)) + add;
    for(const m of accountState.missions){
      if(m.claimed) continue;
      if(m.type==='totalHeal'){
        m.progress = Math.min(m.target, Math.floor(accountState.stats.totalHeal||0));
      }
    }
    saveAccount();
  }catch(e){}
}



function accountOnBossLevel(level){
  try{
    for(const m of accountState.missions){
      if(m.claimed) continue;
      if(m.type==='bossLevel' && (m.levelTarget||10)===level){
        m.progress = 1;
      }
    }
    saveAccount();
  }catch(e){}
}
function accountOnSuperUsed(){
  try{
    const now = Date.now();
    if(now - (lastSuperUseCountTs||0) < 250) return; // evita conteggi multipli ravvicinati
    lastSuperUseCountTs = now;
    runUsedSuper=true;
    if(!accountState.stats) accountState.stats = { totalKills:0, superUses:0, pickups:0, totalGoldPickups:0, bestMatchKills:0, totalDamage:0, totalScore:0, totalHeal:0 , jimmySuperKills:0, jimmySuperUses:0, rooneySuperUses:0, jeffSuperUses:0, voltryxSuperUses:0, kouvagiaSuperUses:0, salsySuperUses:0, tempostormSuperUses:0, marzSuperUses:0, hecateSuperUses:0, marcusSuperUses:0, lucienSuperUses:0, pdorSuperUses:0, baneSuperUses:0, hendelSuperUses:0, kaerithSuperUses:0, cosmoSuperUses:0 };
    accountState.stats.superUses = Math.max(0, Math.floor(accountState.stats.superUses||0)) + 1;
    const chKey = (player && player.type) ? String(player.type) : ((typeof selectedCharacter!=='undefined' && selectedCharacter) ? String(selectedCharacter) : null);
    const statKey = chKey ? (chKey + 'SuperUses') : null;
    if(statKey){
      accountState.stats[statKey] = Math.max(0, Math.floor(accountState.stats[statKey]||0)) + 1;
    }
    for(const m of accountState.missions){
      if(m.claimed) continue;
      if(m.type==='superUses'){
        m.progress = Math.min(m.target, Math.floor(accountState.stats.superUses||0));
      }
      if(statKey && m.type==='charSuperUses' && m.char===chKey){
        m.progress = Math.min(m.target, Math.floor(accountState.stats[statKey]||0));
      }
    }
    saveAccount();
  }catch(e){}
}

function accountOnPlayerDamaged(){
  try{
    runTookDamage = true;
    // missione no-damage fino al livello X: se prendi danno, resta non completata in questa run
  }catch(e){}
}

function accountOnPickupCollected(pickupType){
  try{
    if(!accountState.stats) accountState.stats = { totalKills:0, superUses:0, pickups:0, totalGoldPickups:0, bestMatchKills:0, totalDamage:0, totalScore:0, totalHeal:0 };
    accountState.stats.pickups = Math.max(0, Math.floor(accountState.stats.pickups||0)) + 1;
    if(pickupType==='gold') accountState.stats.totalGoldPickups = Math.max(0, Math.floor(accountState.stats.totalGoldPickups||0)) + 1;
    for(const m of accountState.missions){
      if(m.claimed) continue;
      if(m.type==='pickups'){
        m.progress = Math.min(m.target, Math.floor(accountState.stats.pickups||0));
      }
      if(m.type==='goldPickups'){
        m.progress = Math.min(m.target, Math.floor(accountState.stats.totalGoldPickups||0));
      }
    }
    saveAccount();
  }catch(e){}
}
  
  function accountOnHealed(amount){
  try{
    amount = Math.max(0, Math.floor(amount||0));
    if(amount<=0) return;

    // Somma cumulativa tra partite (persistente)
    if(!accountState.stats) accountState.stats = { totalKills:0, superUses:0, pickups:0, totalGoldPickups:0, bestMatchKills:0, totalDamage:0, totalScore:0, totalHeal:0 };
    accountState.stats.totalHeal = Math.max(0, Math.floor(accountState.stats.totalHeal||0)) + amount;

    // Aggiorna progress missioni heal (cumulativo su totale)
    if(Array.isArray(accountState.missions)){
      for(const m of accountState.missions){
        if(!m || m.claimed) continue;
        if(m.type==='totalHeal'){
          m.progress = Math.min(m.target, Math.floor(accountState.stats.totalHeal||0));
        }
      }
    }
    saveAccount();
  }catch(e){}
}
// Backward compatibility: try older keys used by previous versions
const LEGACY_RECORDS_KEYS = ['pf_records_v18','pf_records_v17','pf_records_v16','pf_records_v15','pf_records'];
// bumped key to include tempostormnclude salsy + new unlock rules // bumped key to include voltryx
let records=loadRecords();
// === SANITIZZAZIONE RECORD (fix bug Marz -> H√®cate) ===
(function sanitizeRecords(){
  if(!records) return;
  // Se H√®cate ha un record ma non √® ancora realmente sbloccata,
  // e Marz ha 0, spostiamo il record su Marz.
  const hecateUnlocked = allPrevAboveHecate85k();
  if(!hecateUnlocked && records.hecate > 0 && records.marz === 0){
    records.marz = records.hecate;
    records.hecate = 0;
    try{
      localStorage.setItem(RECORDS_KEY, JSON.stringify(records));
      console.warn('[SANITIZE] Record spostato da H√®cate a Marz');
    }catch(e){}
  }
})();


function loadRecords(){
  const base={jimmy:0,rooney:0,jeff:0,voltryx:0,kouvagia:0,salsy:0,tempostorm:0,marz:0,hecate:0,marcus:0,lucien:0,pdor:0,bane:0,hendel:0,kaerith:0,cosmo:0};
  try{
    // Primary key (current version)
    const r=localStorage.getItem(RECORDS_KEY);
    if(r){
      const obj=JSON.parse(r);
      return Object.assign({}, base, obj);
    }
    // Migration: older versions may have used a different key
    for(const k of (typeof LEGACY_RECORDS_KEYS!=='undefined'?LEGACY_RECORDS_KEYS:[])){
      const old=localStorage.getItem(k);
      if(old){
        const obj=JSON.parse(old);
        const merged=Object.assign({}, base, obj);
        // persist into the current key so future loads are stable
        try{localStorage.setItem(RECORDS_KEY, JSON.stringify(merged));}catch(e){}
        return merged;
      }
    }
  }catch(e){}
  return base;
}
function saveRecords(){
  try{localStorage.setItem(RECORDS_KEY,JSON.stringify(records))}catch(e){}
}
function updateMenuRecordsDisplay(){
  document.getElementById('record-jimmy').textContent=`Record: ${records.jimmy||0}`;
  document.getElementById('record-rooney').textContent=`Record: ${records.rooney||0}`;
  document.getElementById('record-jeff').textContent=`Record: ${records.jeff||0}`;
  document.getElementById('record-voltryx').textContent=`Record: ${records.voltryx||0}`;
  document.getElementById('record-kouvagia').textContent=`Record: ${records.kouvagia||0}`;
  document.getElementById('record-salsy').textContent=`Record: ${records.salsy||0}`;
  document.getElementById('record-tempostorm').textContent=`Record: ${records.tempostorm||0}`;
  document.getElementById('record-marz').textContent=`Record: ${records.marz||0}`;
  document.getElementById('record-hecate').textContent=`Record: ${records.hecate||0}`;
  document.getElementById('record-marcus').textContent=`Record: ${records.marcus||0}`;
  document.getElementById('record-lucien').textContent=`Record: ${records.lucien||0}`;
  document.getElementById('record-pdor').textContent=`Record: ${records.pdor||0}`;
  document.getElementById('record-bane').textContent=`Record: ${records.bane||0}`;
  const rh=document.getElementById('record-hendel'); if(rh) rh.textContent=`Record: ${records.hendel||0}`;
  const rk=document.getElementById('record-kaerith'); if(rk) rk.textContent=`Record: ${records.kaerith||0}`;
  const brk=document.getElementById('btnrec-kaerith'); if(brk) brk.textContent=`R: ${records.kaerith||0}`;
  const rc=document.getElementById('record-cosmo'); if(rc) rc.textContent=`Record: ${records.cosmo||0}`;
  const brc=document.getElementById('btnrec-cosmo'); if(brc) brc.textContent=`R: ${records.cosmo||0}`;
  updateVoltryxUnlockUI();
  updateKouvagiaUnlockUI();
  updateSalsyUnlockUI();
  updateTempostormUnlockUI();
  updateMarzUnlockUI();
  updateHecateUnlockUI();
  updateLucienUnlockUI();
  updatePdorUnlockUI();
  updateBaneUnlockUI();
  updateHendelUnlockUI();
  updateKaerithUnlockUI();
  updateGuideUnlockUI();

  // Bronze border if record >= 50000
  const charButtons = document.querySelectorAll('.character-btn');
  charButtons.forEach(btn=>{
    const char = btn.dataset.char;
    let record = 0;
    if(char==='jimmy') record = accountState.stats.bestScoreJimmy||0;
    if(char==='jeff') record = accountState.stats.bestScoreJeff||0;
    if(char==='rooney') record = accountState.stats.bestScoreRooney||0;
    if(record >= 50000){
      btn.classList.add('bronze');
    } else {
      btn.classList.remove('bronze');
    }
  });


  try{ applyBronzeCharBorders(); }catch(e){}
}
            


function applyBronzeCharBorders(){
  const bronzeThreshold = 50000;
  const silverThreshold = 75000;
  const goldThreshold = 100000;
  const platinumThreshold = 150000;

const buttons = [
    ...Array.from(document.querySelectorAll('.char-grid button[data-target]')),
    ...Array.from(document.querySelectorAll('button.charBtn,button.characterBtn,button.selectCharBtn,button.char-button')),
  ];

  buttons.forEach(btn=>{
    const key = (btn.dataset && (btn.dataset.target || btn.dataset.char)) 
      ? (btn.dataset.target || btn.dataset.char) 
      : ((btn.id||'').toLowerCase().replace('btn','').replace('button',''));

    const rec = (typeof records === 'object' && records) ? (Number(records[key])||0) : 0;

    btn.classList.remove('bronzeBorder','silverBorder','goldBorder','platinumBorder');

    if(rec >= platinumThreshold){
      btn.classList.add('platinumBorder');
    } else if(rec >= goldThreshold){
      btn.classList.add('goldBorder');
    } else if(rec >= silverThreshold){
      btn.classList.add('silverBorder');
    } else if(rec >= bronzeThreshold){
      btn.classList.add('bronzeBorder');
    }
  });
}




function allThreeAbove50k(){
  return (records.jimmy||0)>45000 && (records.rooney||0)>45000 && (records.jeff||0)>45000;
}

function setLockBadgeState(badge, isLocked){
  if(!badge) return;
  if(isLocked){
    badge.style.display = 'block';
    badge.textContent = 'LOCKED';
    badge.style.color = '#f39c12';
    badge.style.borderColor = '#f39c12';
  } else {
    // When unlocked we want the card to look "normal": no extra UNLOCKED label.
    badge.style.display = 'none';
  }
}

function updateVoltryxUnlockUI(){
  const card=document.getElementById('card-voltryx');
  const badge=document.getElementById('voltryxLockBadge');
  if(!card||!badge) return;

  const unlocked = allThreeAbove50k();
  if(unlocked){
    card.classList.remove('disabled');
    setLockBadgeState(badge, false);
    card.title='Voltryx sbloccata!';
  }else{
    card.classList.add('disabled');
    setLockBadgeState(badge, true);
    card.title='Sblocca completando 50.000 punti con Jimmy, Rooney e Jeff';
  }
}



function voltryxAbove51k(){
  return (records.voltryx||0) >= 50000;
}

function updateKouvagiaUnlockUI(){
  const card=document.getElementById('card-kouvagia');
  const badge=document.getElementById('kouvagiaLockBadge');
  if(!card||!badge) return;

  const unlocked = voltryxAbove51k();
  if(unlocked){
    card.classList.remove('disabled');
    setLockBadgeState(badge, false);
    card.title='Kouvagia sbloccato!';
  }else{
    card.classList.add('disabled');
    setLockBadgeState(badge, true);
    card.title='Sblocca facendo 50.000 punti con Voltryx';
  }
}


function allPrevAbove70k(){
  return (records.jimmy||0)>=60000 && (records.rooney||0)>=60000 && (records.jeff||0)>=60000 && (records.voltryx||0)>=60000 && (records.kouvagia||0)>=60000;
}
function updateSalsyUnlockUI(){
  const card=document.getElementById('card-salsy');
  const badge=document.getElementById('salsyLockBadge');
  if(!card||!badge) return;

  const unlocked = allPrevAbove70k();
  if(unlocked){
    card.classList.remove('disabled');
    setLockBadgeState(badge, false);
    card.title='Salsy sbloccata!';
  }else{
    card.classList.add('disabled');
    setLockBadgeState(badge, true);
    card.title='Sblocca facendo 60.000 punti con Jimmy, Rooney, Jeff, Voltryx e Kouvagia';
  }
}



function allPrevAbove85k(){
  return (records.jimmy||0) >= 65000 &&
         (records.rooney||0) >= 65000 &&
         (records.jeff||0) >= 65000 &&
         (records.voltryx||0) >= 65000 &&
         (records.kouvagia||0) >= 65000 &&
         (records.salsy||0) >= 65000;
}
function updateTempostormUnlockUI(){
  const card=document.getElementById('card-tempostorm');
  const badge=document.getElementById('tempostormLockBadge');
  if(!card||!badge) return;

  const unlocked = allPrevAbove85k();
  if(unlocked){
    card.classList.remove('disabled');
    card.classList.remove('coming-soon');
    setLockBadgeState(badge, false);
    card.title='Tempostorm sbloccato!';
  }else{
    card.classList.add('disabled');
    setLockBadgeState(badge, true);
    card.title='Sblocca facendo 65.000 punti con tutti i personaggi precedenti (Jimmy, Rooney, Jeff, Voltryx, Kouvagia e Salsy)';
  }
}



function allPrevAboveMarz80k(){
  return (records.jimmy||0) >= 70000 &&
         (records.rooney||0) >= 70000 &&
         (records.jeff||0) >= 70000 &&
         (records.voltryx||0) >= 70000 &&
         (records.kouvagia||0) >= 70000 &&
         (records.salsy||0) >= 70000 &&
         (records.tempostorm||0) >= 70000 ;
}
function updateMarzUnlockUI(){
  const card=document.getElementById('card-marz');
  const badge=document.getElementById('marzLockBadge');
  if(!card||!badge) return;

  const unlocked = allPrevAboveMarz80k();
  if(unlocked){
    card.classList.remove('disabled');
    setLockBadgeState(badge, false);
    card.title='Marz sbloccato!';
  }else{
    card.classList.add('disabled');
    setLockBadgeState(badge, true);
    card.title='Sblocca facendo 70.000 punti con tutti i personaggi precedenti';
  }
}


function allPrevAboveHecate85k(){
  return (records.jimmy||0) >= 75000 &&
         (records.rooney||0) >= 75000 &&
         (records.jeff||0) >= 75000 &&
         (records.voltryx||0) >= 75000 &&
         (records.kouvagia||0) >= 75000 &&
         (records.salsy||0) >= 75000 &&
         (records.tempostorm||0) >= 75000 &&
         (records.marz||0) >= 75000;
}
function updateHecateUnlockUI(){
  const card=document.getElementById('card-hecate');
  const badge=document.getElementById('hecateLockBadge');
  if(!card||!badge) return;

  const unlocked = allPrevAboveHecate85k();
  if(unlocked){
    card.classList.remove('disabled');
    card.classList.remove('coming-soon');
    setLockBadgeState(badge, false);
    card.title='H√®cate sbloccata!';
  }else{
    card.classList.add('disabled');
    setLockBadgeState(badge, true);
    card.title='Sblocca facendo 75.000 punti con tutti i personaggi precedenti';
  }
}
function marcusUnlockedAny(){
  try{
    const vals = Object.values(records||{}).map(v=>parseInt(v)||0);
    return (vals.length? Math.max(...vals) : 0) >= 70000;
  }catch(e){
    return false;
  }
}
function lucienUnlocked(){
  return (records.marcus||0) > 25000;
}
function updateLucienUnlockUI(){
  const card=document.getElementById('card-lucien');
  const badge=document.getElementById('lucienLockBadge');
  if(!card||!badge) return;

  const unlocked = lucienUnlocked();
  if(unlocked){
    card.classList.remove('disabled');
    setLockBadgeState(badge, false);
    card.title='Lucien sbloccato!';
  }else{
    card.classList.add('disabled');
    setLockBadgeState(badge, true);
    card.title='Sblocca facendo un record con Marcus superiore a 25.000 punti';
  }
}

function pdorUnlocked(){
  return (records.marcus||0) >= 50000 && (records.lucien||0) >= 50000;
}
function updatePdorUnlockUI(){
  const card=document.getElementById('card-pdor');
  const badge=document.getElementById('pdorLockBadge');
  if(!card||!badge) return;

  const unlocked = pdorUnlocked();
  if(unlocked){
    card.classList.remove('disabled');
    setLockBadgeState(badge, false);
    card.title='Pdor sbloccato!';
  }else{
    card.classList.add('disabled');
    setLockBadgeState(badge, true);
    card.title='Sblocca facendo almeno 50.000 punti di record con Marcus e Lucien';
  }
}

function baneUnlocked(){
  return (records.pdor||0) >= 50000;
}

function hendelUnlocked(){
  return (records.bane||0) >= 50000;
}

function updateHendelUnlockUI(){
  const card=document.getElementById('card-hendel');
  const badge=document.getElementById('hendelLockBadge');
  if(!card||!badge) return;

  const unlocked = hendelUnlocked();
  if(unlocked){
    card.classList.remove('disabled');
    setLockBadgeState(badge, false);
    card.title='Hendel sbloccato!';
  }else{
    card.classList.add('disabled');
    setLockBadgeState(badge, true);
    card.title='Sblocca facendo 50.000 punti con Bane';
  }
}


function kaerithUnlocked(){
  return (records.hendel||0) >= 40000;
}

function updateKaerithUnlockUI(){
  const card=document.getElementById('card-kaerith');
  const badge=document.getElementById('kaerithLockBadge');
  if(!card||!badge) return;

  const unlocked = kaerithUnlocked();
  if(unlocked){
    card.classList.remove('disabled');
    setLockBadgeState(badge, false);
    card.title='Kaerith sbloccato!';
  }else{
    card.classList.add('disabled');
    setLockBadgeState(badge, true);
    card.title='Sblocca facendo 40.000 punti con Hendel';
  }
}

function updateBaneUnlockUI(){
  const card=document.getElementById('card-bane');
  const badge=document.getElementById('baneLockBadge');
  if(!card||!badge) return;

  const unlocked = baneUnlocked();
  if(unlocked){
    card.classList.remove('disabled');
    setLockBadgeState(badge, false);
    card.title='Bane sbloccato!';
  }else{
    card.classList.add('disabled');
    setLockBadgeState(badge, true);
    card.title='Sblocca facendo almeno 50.000 punti di record con PDOR';
  }
}

function updateGuideUnlockUI(){
  const vUnlocked = allThreeAbove50k();
  const kUnlocked = voltryxAbove51k();
  const sUnlocked = allPrevAbove70k();
  const tUnlocked = allPrevAbove85k();
  const mUnlocked = allPrevAboveMarz80k();
  const hUnlocked = allPrevAboveHecate85k();
  const marcUnlocked = marcusUnlockedAny();
  const lucUnlocked = lucienUnlocked();
  const pUnlocked = pdorUnlocked();
  const bUnlocked = baneUnlocked();
  const kaeUnlocked = kaerithUnlocked();

  const vBox=document.getElementById('guide-voltryx');
  const vLock=document.getElementById('guide-voltryx-locked');
  if(vBox&&vLock){ vBox.style.display = vUnlocked ? 'block' : 'none'; vLock.style.display = vUnlocked ? 'none' : 'block'; }

  const kBox=document.getElementById('guide-kouvagia');
  const kLock=document.getElementById('guide-kouvagia-locked');
  if(kBox&&kLock){ kBox.style.display = kUnlocked ? 'block' : 'none'; kLock.style.display = kUnlocked ? 'none' : 'block'; }

  const sBox=document.getElementById('guide-salsy');
  const sLock=document.getElementById('guide-salsy-locked');
  if(sBox&&sLock){ sBox.style.display = sUnlocked ? 'block' : 'none'; sLock.style.display = sUnlocked ? 'none' : 'block'; }

  const tBox=document.getElementById('guide-tempostorm');
  const tLock=document.getElementById('guide-tempostorm-locked');
  if(tBox&&tLock){ tBox.style.display = tUnlocked ? 'block' : 'none'; tLock.style.display = tUnlocked ? 'none' : 'block'; }

  const mBox=document.getElementById('guide-marz');
  const mLock=document.getElementById('guide-marz-locked');
  if(mBox&&mLock){ mBox.style.display = mUnlocked ? 'block' : 'none'; mLock.style.display = mUnlocked ? 'none' : 'block'; }

  const hBox=document.getElementById('guide-hecate');
  const hLock=document.getElementById('guide-hecate-locked');
  if(hBox&&hLock){ hBox.style.display = hUnlocked ? 'block' : 'none'; hLock.style.display = hUnlocked ? 'none' : 'block'; }

  const pBox=document.getElementById('guide-pdor');
  const pLock=document.getElementById('guide-pdor-locked');
  if(pBox&&pLock){ pBox.style.display = pUnlocked ? 'block' : 'none'; pLock.style.display = pUnlocked ? 'none' : 'block'; }

  const bBox=document.getElementById('guide-bane');
  const hendBox=document.getElementById('guide-hendel');
  const hendLock=document.getElementById('guide-hendel-locked');
  const bLock=document.getElementById('guide-bane-locked');
  if(bBox&&bLock){ bBox.style.display = bUnlocked ? 'block' : 'none'; bLock.style.display = bUnlocked ? 'none' : 'block'; }

  const hendUnlocked = hendelUnlocked();
  if(hendBox&&hendLock){ hendBox.style.display = hendUnlocked ? 'block' : 'none'; hendLock.style.display = hendUnlocked ? 'none' : 'block'; }

  const kaeBox=document.getElementById('guide-kaerith');
  const kaeLock=document.getElementById('guide-kaerith-locked');
  if(kaeBox&&kaeLock){ kaeBox.style.display = kaeUnlocked ? 'block' : 'none'; kaeLock.style.display = kaeUnlocked ? 'none' : 'block'; }


  const marcBox=document.getElementById('guide-marcus');
  const marcLock=document.getElementById('guide-marcus-locked');
  if(marcBox&&marcLock){ marcBox.style.display = marcUnlocked ? 'block' : 'none'; marcLock.style.display = marcUnlocked ? 'none' : 'block'; }

  const lucBox=document.getElementById('guide-lucien');
  const lucLock=document.getElementById('guide-lucien-locked');
  if(lucBox&&lucLock){ lucBox.style.display = lucUnlocked ? 'block' : 'none'; lucLock.style.display = lucUnlocked ? 'none' : 'block'; }

}


function createParticles(x,y,color,count=10,size=4){
  for(let i=0;i<count;i++){
    particles.push({
      x:x+Math.random()*20-10,
      y:y+Math.random()*20-10,
      vx:(Math.random()-0.5)*6,
      vy:(Math.random()-0.5)*6,
      life:30,
      color,size
    });
  }
}
function updateParticles(){
  particles=particles.filter(p=>{
    p.x+=p.vx;p.y+=p.vy;p.vy+=0.2;p.life--;
    return p.life>0
  });
}
function drawParticles(){
  particles.forEach(p=>{
    ctx.fillStyle=p.color;
    ctx.globalAlpha=p.life/30;
    ctx.fillRect(p.x,p.y,p.size,p.size)
  });
  ctx.globalAlpha=1
}

// --- IRA kill FX (Bane SUPER) ---
let iraFxBursts = []; // radial glows on kill
let iraScreenFlash = 0; // frames

function createIraKillFX(x,y){
  // Big red burst + sparks
  createParticles(x,y,'#ff1b3a',70,5);
  createParticles(x,y,'#7a0019',45,6);
  createParticles(x,y,'#ff6b6b',35,4);
  // Expanding glow rings
  for(let k=0;k<3;k++){
    iraFxBursts.push({
      x, y,
      r: 18 + k*10,
      vr: 6 + k*1.5,
      life: 18 + k*6,
      maxLife: 18 + k*6
    });
  }
  // Small screen flash
  iraScreenFlash = Math.max(iraScreenFlash, 14);
}

function updateIraFX(){
  iraFxBursts = iraFxBursts.filter(b=>{
    b.r += b.vr;
    b.life--;
    return b.life>0;
  });
  if(iraScreenFlash>0) iraScreenFlash--;
}

function drawIraFX(){
  // Draw glow rings behind particles
  iraFxBursts.forEach(b=>{
    const t = b.life / b.maxLife; // 1 -> 0
    ctx.save();
    ctx.globalAlpha = 0.55 * t;
    ctx.shadowColor = '#000000'; ctx.shadowBlur = 25; ctx.strokeStyle = '#7a0019';
    ctx.lineWidth = 6 * t + 1;
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
    ctx.stroke();
    ctx.globalAlpha = 0.25 * t;
    ctx.shadowColor = '#000000'; ctx.shadowBlur = 25; ctx.strokeStyle = '#ff1b3a';
    ctx.lineWidth = 10 * t + 2;
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.r*1.12, 0, Math.PI*2);
    ctx.stroke();
    ctx.restore();
  });
}


function showDamageNumber(x,y,dmg){
  const div=document.createElement('div');
  div.className='damage-number';
  div.textContent=`-${dmg}`;
  const rect=canvas.getBoundingClientRect();
  div.style.left=(rect.left+x)+'px';
  div.style.top=(rect.top+y-10)+'px';
  document.body.appendChild(div);
  setTimeout(()=>div.remove(),1000)
}

// ===== Lupi amichevoli (H√àCATE SUPER) =====
const WOLF_MAX = 3;
class Wolf{
  constructor(x,y){
    this.x=x; this.y=y;
    this.width=72; this.height=72;
    this.maxHP=51;
    this.hp=this.maxHP;
    this.maxHp=this.maxHP; // alias for legacy code
    this.speed=3.5; // movimento rapido ma non OP
    this.damage=16;
    this.range=70; // morso ravvicinato
    this.cooldown=700;
    this.lastAttack=0;

    // per compatibilit√† con l'AI dei nemici (che si aspetta un "player-like")
    this.invulnerable=false;
    this.shieldActive=false;
  }
  takeDamage(d, attacker){
    if(this.hp<=0) return;

    // Kaerith SUPER: 25% damage reduction while active
    // --- Safety: avoid NaN/Infinity damage propagating to HP ---
    d = Number(d);
    if(!Number.isFinite(d) || d < 0) d = 0;
    this.hp = Number(this.hp);
    if(!Number.isFinite(this.hp)) this.hp = Number(this.maxHP)||0;
    this.hp -= d;
    if(!Number.isFinite(this.hp)) this.hp = 0;
    // clamp
    const _maxHp = Number(this.maxHP);
    if(Number.isFinite(_maxHp) && _maxHp > 0){
      this.hp = Math.max(0, Math.min(_maxHp, this.hp));
    } else {
      this.hp = Math.max(0, this.hp);
    }
// Account mission: no-damage run tracking
    if(d>0){ try{ accountOnPlayerDamaged(); }catch(e){} }
    createParticles(this.x+this.width/2, this.y+this.height/2, '#90caf9', 14, 4);

    // Hendel passive: every enemy that hits him is knocked back and takes 40 damage
    if(this.type==='hendel' && attacker && typeof attacker.hp==='number'){
      const pcx=this.x+this.width/2, pcy=this.y+this.height/2;
      const ecx=attacker.x+attacker.width/2, ecy=attacker.y+attacker.height/2;
      let dx=ecx-pcx, dy=ecy-pcy;
      const len=Math.hypot(dx,dy)||1;
      dx/=len; dy/=len;

      // knockback away from Hendel
      const kb=140;
      attacker.x += dx*kb;
      attacker.y += dy*kb;
      attacker.x = Math.max(0, Math.min(canvas.width - attacker.width, attacker.x));
      attacker.y = Math.max(0, Math.min(canvas.height - attacker.height, attacker.y));

      // damage
      const ret=40;
      attacker.hp -= ret;
      showDamageNumber(attacker.x, attacker.y, ret);
      createParticles(attacker.x+attacker.width/2, attacker.y+attacker.height/2, '#8b5a2b', 10, 4);
      createParticles(attacker.x+attacker.width/2, attacker.y+attacker.height/2, '#9e9e9e', 6, 4);

      // kill handling
      if(attacker.hp<=0 && enemies){
        const idx=enemies.indexOf(attacker);
        if(idx!==-1){
          createParticles(attacker.x,attacker.y,'#fff176',28,6);
          dropStellarBonusAtIndexIfNeeded(idx);
          enemies.splice(idx,1);
          applyScore(100*currentLevel);
          addKill();
          if(this._baneSuperOnKill) this._baneSuperOnKill();
        }
      }
    }
  }
  _nearestEnemy(){
    if(!enemies || enemies.length===0) return null;
    const cx=this.x+this.width/2, cy=this.y+this.height/2;
    let best=null, bestD=1e9;
    for(const e of enemies){
      const ex=e.x+e.width/2, ey=e.y+e.height/2;
      const d=Math.hypot(ex-cx, ey-cy);
      if(d<bestD){ bestD=d; best=e; }
    }
    return best;
  }
  update(){
    const now=Date.now();
    // COSMO: manage short invul + passive stacks
    if(this.type==='cosmo'){
      if(this._cosmoInvulUntil && now > this._cosmoInvulUntil){
        // don't override shield pickup invulnerability
        if(!this.pickupShieldUntil || now > this.pickupShieldUntil){
          this.invulnerable = false;
        }
        this._cosmoInvulUntil = 0;
      }
      try{ _cosmoRecalcDmgMult(); }catch(e){}
    }
const target=this._nearestEnemy();
    if(!target) return;

    const cx=this.x+this.width/2, cy=this.y+this.height/2;
    const tx=target.x+target.width/2, ty=target.y+target.height/2;
    const dx=tx-cx, dy=ty-cy;
    const dist=Math.hypot(dx,dy) || 1;

    // Move towards target
    const nx=dx/dist, ny=dy/dist;
    this.x += nx*this.speed;
    this.y += ny*this.speed;

    // Clamp arena
    this.x=Math.max(0, Math.min(canvas.width-this.width, this.x));
    this.y=Math.max(0, Math.min(canvas.height-this.height, this.y));

    // Bite
    if(dist <= this.range && (now-this.lastAttack) >= this.cooldown){
      this.lastAttack=now;
      const finalDmg = Math.max(0, Math.round(this.damage * markMult(target)));
      target.hp -= finalDmg;
      showDamageNumber(target.x, target.y, finalDmg);
      createParticles(tx, ty, '#b0bec5', 10, 3);

      if(target.hp<=0){
        // kill credit: same as normal kill
        createParticles(target.x, target.y, '#fff176', 30, 6);
        const idx=enemies.indexOf(target);
        if(idx>=0){dropStellarBonusAtIndexIfNeeded(idx);enemies.splice(idx,1);}
        applyScore(100*currentLevel);
      addKill(); }
    }
  }
  draw(){
    // sprite
    if(wolfImg && wolfImg.complete){
      ctx.drawImage(wolfImg, this.x, this.y, this.width, this.height);
    }else{
      ctx.fillStyle='#90caf9';
      ctx.fillRect(this.x,this.y,this.width,this.height);
    }

    // mini HP bar
    const barW=this.width, barH=6;
    const pct=Math.max(0, Math.min(1, this.hp/this.maxHP));
    ctx.fillStyle='rgba(0,0,0,0.55)';
    ctx.fillRect(this.x, this.y-10, barW, barH);
    ctx.fillStyle='#66bb6a';
    ctx.fillRect(this.x, this.y-10, barW*pct, barH);
  }
}

function spawnWolvesNearPlayer(playerObj, wanted){
  if(!playerObj) return;
  const free = Math.max(0, WOLF_MAX - (wolves?.length||0));
  const n = Math.max(0, Math.min(wanted||0, free));
  if(n<=0) return;

  const px=playerObj.x+playerObj.width/2;
  const py=playerObj.y+playerObj.height/2;

  for(let i=0;i<n;i++){
    const a=Math.random()*Math.PI*2;
    const r=55 + Math.random()*25;
    const x=Math.max(0, Math.min(canvas.width-64, px + Math.cos(a)*r - 32));
    const y=Math.max(0, Math.min(canvas.height-64, py + Math.sin(a)*r - 32));
    wolves.push(new Wolf(x,y));
    createParticles(x+32,y+32,'#90caf9',18,4);
  }
}

function updateWolves(){
  if(!wolves || wolves.length===0) return;
  // remove dead
  wolves = wolves.filter(w => w && w.hp>0);
  for(const w of wolves) w.update();
}

function drawWolves(){
  if(!wolves || wolves.length===0) return;
  for(const w of wolves) w.draw();
}

// I nemici attaccano i lupi se pi√π vicini del player
function getPreferredTarget(enemy, playerObj){
  try{
    // Boss sempre focalizzati sul player (evita "zone sicure" quando i lupi attirano l'aggro)
    if(enemy && typeof enemy.type==='string' && enemy.type.startsWith('boss')) return playerObj;
    if(!wolves || wolves.length===0) return playerObj;
    if(!enemy || !playerObj) return playerObj;

    const ex=enemy.x+enemy.width/2, ey=enemy.y+enemy.height/2;
    const px=playerObj.x+playerObj.width/2, py=playerObj.y+playerObj.height/2;
    const dp=Math.hypot(px-ex, py-ey);

    let best=null, bestD=1e9;
    for(const w of wolves){
      if(!w || w.hp<=0) continue;
      const wx=w.x+w.width/2, wy=w.y+w.height/2;
      const d=Math.hypot(wx-ex, wy-ey);
      if(d<bestD){ bestD=d; best=w; }
    }
    return (best && bestD < dp) ? best : playerObj;
  }catch(e){
    return playerObj;
  }
}

function markMult(enemy){
  return (enemy && enemy.salsyMarkUntil && Date.now() < enemy.salsyMarkUntil) ? 2 : 1;
}
function applyEnemyDamage(enemy, baseDmg){
  // Rooney EVO passive: first hit on a given enemy deals +15% damage (doesn't change stats)
  let mult=1;
  if(typeof player!=='undefined' && player && player.type==='rooney' && player.evolved && enemy && !enemy._rooneyFirstHit){
    mult=1.5; // EVO: Rooney first hit +50% damage
    enemy._rooneyFirstHit=true;
  }
  const finalDmg = Math.max(0, Math.round(baseDmg * mult * markMult(enemy)));
  enemy._lastHitAt = Date.now();
  enemy.hp -= finalDmg;
  try{ accountOnDamageDealt(finalDmg); }catch(e){}
  return finalDmg;
}

function shakeScreen(){shakeAmount=8}

// Extended projectile to support friendly, AoE, homing, pulse damage


function aabbDist2(ax,ay,aw,ah,bx,by,bw,bh){
  // distanza minima tra due rettangoli (0 se overlap)
  const dx = (ax+aw < bx) ? (bx - (ax+aw)) : (bx+bw < ax) ? (ax - (bx+bw)) : 0;
  const dy = (ay+ah < by) ? (by - (ay+ah)) : (by+bh < ay) ? (ay - (by+bh)) : 0;
  return dx*dx + dy*dy;
}
function spawnProjectile(opts){
  // opts: {x,y,vx,vy,damage,ttl,color,radius,friendly,aoeRadius,aoeFullDamage,homing,speed,isVoltryxSuper,pulseInterval,lastPulse,targetRef,explodeOnExpire}
  const p={
    x:opts.x,y:opts.y,vx:opts.vx||0,vy:opts.vy||0,
    damage:opts.damage||10,created:Date.now(),
    ttl:opts.ttl||3000,color:opts.color||'#000000',
    radius:opts.radius||6,friendly:!!opts.friendly,
    aoeRadius:opts.aoeRadius||0,aoeFullDamage:!!opts.aoeFullDamage,homing:!!opts.homing,
    speed:opts.speed||Math.hypot(opts.vx||0,opts.vy||0)||6,
    isVoltryxSuper:!!opts.isVoltryxSuper,
    pulseInterval:opts.pulseInterval||0,
    lastPulse:opts.lastPulse||0,
  targetRef:opts.targetRef||null,
    explodeOnExpire:!!opts.explodeOnExpire,
    shape:opts.shape||'circle',
    w:opts.w||0,
    h:opts.h||0,
    angle:typeof opts.angle==='number'?opts.angle:null,
    onHitPlayer:opts.onHitPlayer||null,
    source:opts.source||opts.owner||null,
    meta:opts.meta||null,
    excludeRef:opts.excludeRef||null
  };
  projectiles.push(p);
}

function updateProjectiles(){
  const now=Date.now();

  // NOTE: Player/enemy freeze logic used to live here (Marz old super).
  // updateProjectiles runs in global scope; player state is handled in Player.update().


    // Grapple safety: prevent rare stuck state (e.g., Jimmy vs shooter)
    if(this.isGrappling){
      if(!this.grappleTarget || !enemies.includes(this.grappleTarget) || (this.grappleStartTime && now-this.grappleStartTime>1400)){
        this.isGrappling=false;this.grappleTarget=null;this.vx=0;this.vy=0;
          this.grappleStartTime=0;
        this.grappleStartTime=0;
        if(this.type==='jimmy' && this.shieldActive && !this.isDoingSuper) this.shieldActive=false;
      }
    }

  projectiles=projectiles.filter(p=>{
    // homing behavior (friendly):
    // - if targetRef exists and is still alive, home on it
    // - otherwise fall back to nearest enemy
    if(p.homing && p.friendly && enemies.length>0){
      let target = (p.targetRef && enemies.includes(p.targetRef)) ? p.targetRef : null;

      if(!target){
        let closest=null, best=Infinity;
        for(const e of enemies){
          const dx=(e.x+e.width/2)-p.x;
          const dy=(e.y+e.height/2)-p.y;
          const d=Math.hypot(dx,dy);
          if(d<best){best=d;closest=e}
        }
        target = closest;
      }

      if(target){
        const dx=(target.x+target.width/2)-p.x;
        const dy=(target.y+target.height/2)-p.y;
        const len=Math.hypot(dx,dy)||1;
        const steerX=(dx/len)*p.speed;
        const steerY=(dy/len)*p.speed;
        // soft steer
        p.vx = p.vx*0.6 + steerX*0.4;
        p.vy = p.vy*0.6 + steerY*0.4;
      }
    }

    p.x+=p.vx;
    p.y+=p.vy;

    // Bounds
    const aliveInBounds = p.x>=-60 && p.x<=canvas.width+60 && p.y>=-60 && p.y<=canvas.height+60;

    // Voltryx super orb pulse AoE damage
    if(p.isVoltryxSuper){
      if(!p.lastPulse || now - p.lastPulse >= p.pulseInterval){
        p.lastPulse = now;
        // damage all enemies within aoeRadius
        for(let i=enemies.length-1;i>=0;i--){
          const e=enemies[i];
        if(p.excludeRef && e===p.excludeRef) continue;
          const dist=Math.hypot((e.x+e.width/2)-p.x,(e.y+e.height/2)-p.y);
          if(dist <= p.aoeRadius){
            const dmg = p.aoeFullDamage ? Math.round(p.damage) : Math.round(p.damage*SUPER_DAMAGE_MULT);
            const _dmg=dmg; const _final=applyEnemyDamage(e,_dmg);
            createParticles(e.x,e.y,'#f39c12',12,5);
            showDamageNumber(e.x,e.y, _final);
            if(e.hp<=0){
              createParticles(e.x,e.y,'#fff176',30,6);
              dropStellarBonusAtIndexIfNeeded(i);
              enemies.splice(i,1);
              applyScore(100*currentLevel);
                addKill(); if(this.type==='kouvagia'){this.hp=Math.min(this.maxHP,this.hp+3);createParticles(this.x,this.y,'#2ecc71',6,3);}
            }
          }
        }
      }
    }

    // Collision: friendly hits enemies
    if(p.friendly){
      for(let i=enemies.length-1;i>=0;i--){
        const e=enemies[i];
        const dx=(e.x+e.width/2)-p.x;
        const dy=(e.y+e.height/2)-p.y;
        const dist=Math.hypot(dx,dy);
        if(dist <= (p.radius + Math.max(e.width,e.height)/2)*0.8){
          // impact
          if(p.aoeRadius>0){
            // area explosion
            for(let j=enemies.length-1;j>=0;j--){
              const ee=enemies[j];
              const d2=Math.hypot((ee.x+ee.width/2)-p.x,(ee.y+ee.height/2)-p.y);
              if(d2<=p.aoeRadius){
                const dmg = p.aoeFullDamage ? Math.round(p.damage) : Math.round(p.damage*SUPER_DAMAGE_MULT);
                const _dmg=dmg; const _final=applyEnemyDamage(ee,_dmg);
                createParticles(ee.x,ee.y,'#ffb74d',8,4);
                showDamageNumber(ee.x,ee.y, _final);
                if(ee.hp<=0){
                  createParticles(ee.x,ee.y,'#fff176',30,6);
                  dropStellarBonusAtIndexIfNeeded(j);
                  enemies.splice(j,1);
                  applyScore(100*currentLevel);
                addKill(); }
              }
            }
          }else{
            // single target
            const dmg=Math.round(p.damage);
            const _dmg=dmg; const _final=applyEnemyDamage(e,_dmg);
            createParticles(e.x,e.y,'#ffd54f',8,4);
            showDamageNumber(e.x,e.y, _final);
            // H√®cate: main arrow splits into 3 arrows to OTHER enemies
            if(p.meta && p.meta.type==='hecateMain'){
              const impactX=p.x, impactY=p.y;
              createParticles(impactX, impactY, '#c5cae9', 18, 4);
              const others = enemies.filter(ee=>ee!==e).sort((a,b)=>{
                const da=Math.hypot((a.x+a.width/2)-impactX,(a.y+a.height/2)-impactY);
                const db=Math.hypot((b.x+b.width/2)-impactX,(b.y+b.height/2)-impactY);
                return da-db;
              }).slice(0,3);
              const splitDmg = Math.round((p.meta.splitDamage || Math.round(p.damage * 0.5)));
              for(const t of others){
                const dx=(t.x+t.width/2)-impactX;
                const dy=(t.y+t.height/2)-impactY;
                const len=Math.hypot(dx,dy)||1;
                const speed=12;
                const vx=(dx/len)*speed;
                const vy=(dy/len)*speed;
                spawnProjectile({
                  x:impactX,y:impactY,vx,vy,speed,
                  damage:splitDmg,ttl:520,color:'#c5cae9',
                  radius:6,friendly:true,
                  shape:'rect',w:18,h:4,angle:Math.atan2(vy,vx),
                  excludeRef:e
                });
                createParticles(impactX,impactY,'#c5cae9',6,3);
              }
            }
            if(e.hp<=0){
              createParticles(e.x,e.y,'#fff176',30,6);
              dropStellarBonusAtIndexIfNeeded(i);
              enemies.splice(i,1);
              applyScore(100*currentLevel);
                addKill(); if(this.type==='kouvagia'){this.hp=Math.min(this.maxHP,this.hp+3);createParticles(this.x,this.y,'#2ecc71',6,3);}
            }
          }
          if(p.meta && p.meta.pdorChain){
            // Chain: jump to nearest enemy up to 5 hits, halving damage each jump.
            if(!p.meta.hitRefs) p.meta.hitRefs = [];
            p.meta.hitRefs.push(e);
            p.meta.hitsLeft = (typeof p.meta.hitsLeft==='number'? p.meta.hitsLeft : 1) - 1;

            if(p.meta.hitsLeft > 0){
              let bestT=null, bestD=Infinity;
              for(const t of enemies){
                if(t===e) continue;
                if(p.meta.hitRefs.includes(t)) continue;
                const dx=(t.x+t.width/2)-p.x;
                const dy=(t.y+t.height/2)-p.y;
                const d=Math.hypot(dx,dy);
                if(d<bestD){bestD=d;bestT=t;}
              }
              if(bestT){
                const dx=(bestT.x+bestT.width/2)-p.x;
                const dy=(bestT.y+bestT.height/2)-p.y;
                const len=Math.hypot(dx,dy)||1;
                const speed=9;
                // halve damage on every jump (including the next hit)
                p.damage = Math.max(1, Math.round(p.damage * 0.5));
                p.vx=(dx/len)*speed;
                p.vy=(dy/len)*speed;
                p.speed=speed;
                p.shape='rect';
                p.w=35; p.h=10;
                p.angle=Math.atan2(p.vy,p.vx);
                // nudge forward to avoid re-hitting instantly
                p.x += p.vx*0.35;
                p.y += p.vy*0.35;
                createParticles(p.x,p.y,'#000000',6,3);
                return true; // keep projectile alive
              }
            }
            return false; // no more targets
          }
          return false; // projectile consumed
        }
      }
    }else{
      // enemy projectiles hit player
      if(player && p.x>player.x && p.x<player.x+player.width && p.y>player.y && p.y<player.y+player.height){
        if(typeof p.onHitPlayer==='function'){ try{ p.onHitPlayer(player); }catch(e){} }
        player.takeDamage(p.damage, p.source || null);
        return false;
      }

      // enemy projectiles can hit wolves (H√®cate summon)
      if(wolves && wolves.length){
        for(const w of wolves){
          if(!w || w.hp<=0) continue;
          if(p.x>w.x && p.x<w.x+w.width && p.y>w.y && p.y<w.y+w.height){
            // apply damage to wolf
            w.hp -= Math.max(1, Math.round(p.damage));
            createParticles(w.x+w.width/2, w.y+w.height/2, '#90caf9', 10, 4);
            return false;
          }
        }
      }
    }

    const aliveTime = (now-p.created)<p.ttl;
    const alive = aliveTime && aliveInBounds;

    // Optional AoE explosion when the projectile stops (ttl end / out of bounds)
    if(!alive && p.explodeOnExpire && p.friendly && p.aoeRadius>0){
      // apply AoE at last position
      for(let j=enemies.length-1;j>=0;j--){
        const ee=enemies[j];
        const dx=(ee.x+ee.width/2)-p.x;
        const dy=(ee.y+ee.height/2)-p.y;
        const d=Math.hypot(dx,dy);
        if(d<=p.aoeRadius){
          const dmg=Math.round(p.damage);
          const _dmg=dmg; const _final=applyEnemyDamage(ee,_dmg);
          createParticles(ee.x,ee.y,'#ffb74d',8,4);
          showDamageNumber(ee.x,ee.y, _final);
          if(ee.hp<=0){
            createParticles(ee.x,ee.y,'#fff176',30,6);
            dropStellarBonusAtIndexIfNeeded(j);
            enemies.splice(j,1);
            applyScore(100*currentLevel);
          addKill(); }
        }
      }
      createParticles(p.x,p.y,'#ffa726',18,5);
    }

    return alive;
  });
}

function drawProjectiles(){
  projectiles.forEach(p=>{
    ctx.globalAlpha = p.isVoltryxSuper ? 0.8 : 1;

    // Archer arrows (small elongated hits)
    if(p.shape==='rect'){
      const ang = (p.angle!==null && !Number.isNaN(p.angle)) ? p.angle : Math.atan2(p.vy||0, p.vx||0);
      const w = p.w || 16;
      const h = p.h || 4;
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(ang);
      ctx.fillStyle=p.color;

      // PDOR dart: tapered "crystal/teardrop" instead of a plain rectangle
      if(p.meta && p.meta.pdorChain){
        const L = w;               // length
        const W = Math.max(6, h*1.6); // width (a bit thicker so the shape reads better)
        ctx.beginPath();
        // tip (front)
        ctx.moveTo(L/2, 0);
        // upper edge to rounded base
        ctx.quadraticCurveTo(L*0.15,  W*0.75, -L/2,  W*0.35);
        // round the base
        ctx.quadraticCurveTo(-L/2 - W*0.25, 0, -L/2, -W*0.35);
        // lower edge back to tip
        ctx.quadraticCurveTo(L*0.15, -W*0.75, L/2, 0);
        ctx.closePath();
        
ctx.shadowColor = '#000000';
ctx.shadowBlur = 25;

ctx.fill();

        // subtle inner highlight
        ctx.globalAlpha = 0.25;
        ctx.shadowColor = '#000000'; ctx.shadowBlur = 25; ctx.strokeStyle = 'rgba(255,255,255,0.8)';
        ctx.lineWidth = Math.max(1.5, W*0.12);
        ctx.stroke();
        ctx.globalAlpha = 1;
      }else{
        // Rooney punch-style homogeneous flared end
        const L = w;
        const W = h*1.2;

        ctx.beginPath();
        // main shaft
        ctx.moveTo(-L/2, -W/2);
        ctx.lineTo(L*0.15, -W/2);
        ctx.lineTo(L*0.15, W/2);
        ctx.lineTo(-L/2, W/2);
        ctx.closePath();
        
ctx.shadowColor = '#000000';
ctx.shadowBlur = 25;

ctx.fill();

        // flared fist tip
        ctx.beginPath();
        ctx.moveTo(L*0.15, -W*0.9);
        ctx.lineTo(L/2, -W*0.5);
        ctx.lineTo(L/2, W*0.5);
        ctx.lineTo(L*0.15, W*0.9);
        ctx.closePath();
        
ctx.shadowColor = '#000000';
ctx.shadowBlur = 25;

ctx.fill();
      }
      ctx.restore();
      
    // Marcus wavy projectile visual (thick undulating line)
    if(p.meta && p.meta.marcus){
      const ang = Math.atan2(p.vy||0, p.vx||1);
      const segs = 20;
      const length = 120; // total length of the visible wave
      const step = length / segs;
      const amp = (p.meta && p.meta.amp) ? p.meta.amp : 14;
      const freq = (p.meta && p.meta.freq) ? p.meta.freq : 0.9;
      const phase = (p.meta && p.meta.phase) ? p.meta.phase : 0;
      const nowT = Date.now();
      const t2 = (nowT - (p.created||0)) / 1000;

      const cx = p.x, cy = p.y;
      const dxUnit = Math.cos(ang), dyUnit = Math.sin(ang);
      const pxUnit = Math.cos(ang + Math.PI/2), pyUnit = Math.sin(ang + Math.PI/2);

      ctx.save();
      ctx.lineWidth = Math.max(6, (p.radius||8) * 2.2);
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';
      ctx.shadowColor = '#000000'; ctx.shadowBlur = 25; ctx.strokeStyle = p.color || '#b19cff';
      ctx.beginPath();
      for(let i = -Math.floor(segs/2); i <= Math.floor(segs/2); i++){
        const u = i * step;
        const wobble = Math.sin((u * 0.06 * freq) + (t2 * freq) + phase);
        const ox = pxUnit * wobble * amp;
        const oy = pyUnit * wobble * amp;
        const x = cx + dxUnit * u + ox;
        const y = cy + dyUnit * u + oy;
        if(i === -Math.floor(segs/2)) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();

      ctx.globalAlpha = 0.14;
      ctx.lineWidth = Math.max(10, (p.radius||8) * 3.0);
      ctx.stroke();
      ctx.globalAlpha = 1;
      ctx.restore();
      return;
    }

    ctx.globalAlpha = 1;
      return;
    }

    // Default circular bullets
    ctx.fillStyle=p.color;
    ctx.beginPath();
    ctx.arc(p.x,p.y,p.isVoltryxSuper ? 18 : p.radius,0,Math.PI*2);
    
ctx.shadowColor = '#000000';
ctx.shadowBlur = 25;

ctx.fill();
    ctx.globalAlpha = 1;

    if(p.isVoltryxSuper){
      // draw a soft aura
      ctx.strokeStyle='rgba(243,156,18,0.5)';
      ctx.lineWidth=4;
      ctx.beginPath();
      ctx.arc(p.x,p.y,p.aoeRadius,0,Math.PI*2);
      ctx.stroke();
    }
  });
}


// Laser hazards (OneEyes)
function spawnLaser(opts){
  // opts: {x,y,angle,length,width,ttl,damage,kind,chargeMs,chargedAt}
  lasers.push({
    x:opts.x,y:opts.y,angle:opts.angle||0,length:opts.length||520,width:opts.width||14,
    created:Date.now(),ttl:opts.ttl||1000,damage:opts.damage||15,
    kind:opts.kind||'laser', chargeMs:opts.chargeMs||0, chargedAt:Date.now()+ (opts.chargeMs||0),
    hitCooldown:220, lastHit:0,
    owner:opts.owner||opts.source||null,
    trackPlayer: !!opts.trackPlayer,
    hitOnce:false
  });
}

function updateLasers(){
  const now=Date.now();
  lasers = lasers.filter(L=>{
    // Aimbot 360¬∞ per boss: laser che segue il player durante la durata
    if(L.trackPlayer && player){
      const ocx = (L.owner? (L.owner.x + L.owner.width/2) : L.x);
      const ocy = (L.owner? (L.owner.y + L.owner.height/2) : L.y);
      const pcx = player.x + player.width/2;
      const pcy = player.y + player.height/2;
      L.x = ocx; L.y = ocy;
      L.angle = Math.atan2(pcy-ocy, pcx-ocx);
    }
    const alive = (now - L.created) < (L.ttl + (L.chargeMs||0));
    if(!alive) return false;

    // During charge: no damage
    const active = now >= L.chargedAt;

    if(active && player){
      // Collision: distance from player center to laser segment
      const px = player.x + player.width/2;
      const py = player.y + player.height/2;

      const x2 = L.x + Math.cos(L.angle)*L.length;
      const y2 = L.y + Math.sin(L.angle)*L.length;

      // projection
      const vx = x2 - L.x, vy = y2 - L.y;
      const wx = px - L.x, wy = py - L.y;
      const c1 = wx*vx + wy*vy;
      const c2 = vx*vx + vy*vy;
      let t = c2 ? (c1 / c2) : 0;
      t = Math.max(0, Math.min(1, t));
      const cx = L.x + t*vx;
      const cy = L.y + t*vy;
      const dist = Math.hypot(px - cx, py - cy);

      if(dist <= (L.width/2 + Math.max(player.width, player.height)*0.20)){
        // OneEyes: il danno pu√≤ essere preso una sola volta per raggio
        if(L.kind==='oneyes'){
          if(!L.hitOnce){
            L.hitOnce=true;
            player.takeDamage(L.damage, L.owner || null);
          }
        } else {
          if(now - L.lastHit >= L.hitCooldown){
            L.lastHit = now;
            player.takeDamage(L.damage, L.owner || null);
          }
        }
      }
    }

    return true;
  });
}

function drawLasers(){
  const now=Date.now();
  lasers.forEach(L=>{
    const active = now >= L.chargedAt;
    const x2 = L.x + Math.cos(L.angle)*L.length;
    const y2 = L.y + Math.sin(L.angle)*L.length;

    ctx.save();
    ctx.lineCap='round';

    if(!active){
      // charge preview
      ctx.globalAlpha = 0.55;
      ctx.shadowColor = '#000000'; ctx.shadowBlur = 25; ctx.strokeStyle = 'rgba(255,255,255,0.7)';
      ctx.lineWidth = Math.max(6, L.width*0.5);
      ctx.beginPath(); ctx.moveTo(L.x,L.y); ctx.lineTo(x2,y2); ctx.stroke();
      ctx.globalAlpha = 1;
    } else {
      // active beam
      ctx.globalAlpha = (L.kind==='photon') ? 0.92 : 0.75;
      ctx.shadowColor = '#000000'; ctx.shadowBlur = 25; ctx.strokeStyle = (L.kind==='photon') ? 'rgba(243,156,18,0.9)' : 'rgba(52,152,219,0.9)';
      ctx.lineWidth = L.width;
      ctx.beginPath(); ctx.moveTo(L.x,L.y); ctx.lineTo(x2,y2); ctx.stroke();

      // glow
      ctx.globalAlpha = 0.28;
      ctx.lineWidth = L.width*1.9;
      ctx.beginPath(); ctx.moveTo(L.x,L.y); ctx.lineTo(x2,y2); ctx.stroke();
      ctx.globalAlpha = 1;
    }

    ctx.restore();
  });
}


function spawnTempBeam(opts){
  // opts: {x1,y1,x2,y2,width,ttl,damage1,damageStay,friendly}
  tempBeams.push({
    x1:opts.x1,y1:opts.y1,x2:opts.x2,y2:opts.y2,
    width:opts.width||18,
    created:Date.now(),
    ttl:opts.ttl||260,
    damage1:opts.damage1||40,
    damageStay:opts.damageStay||30,
    hitMap:new Map() // enemy -> {firstHit, left, extraDone}
  });
}

// distance from point to segment
function _distPointToSeg(px,py,x1,y1,x2,y2){
  const vx=x2-x1, vy=y2-y1;
  const wx=px-x1, wy=py-y1;
  const c1=wx*vx+wy*vy;
  if(c1<=0) return Math.hypot(px-x1,py-y1);
  const c2=vx*vx+vy*vy;
  if(c2<=c1) return Math.hypot(px-x2,py-y2);
  const b=c1/c2;
  const bx=x1+b*vx, by=y1+b*vy;
  return Math.hypot(px-bx,py-by);
}

function updateTempBeams(){
  const now=Date.now();
  for(let i=tempBeams.length-1;i>=0;i--){
    const B=tempBeams[i];
    const age=now-B.created;
    if(age>B.ttl){ tempBeams.splice(i,1); continue; }

    // collisions with enemies
    enemies.forEach(e=>{
      const ex=e.x+e.width/2, ey=e.y+e.height/2;
      const dist=_distPointToSeg(ex,ey,B.x1,B.y1,B.x2,B.y2);
      const inside = dist <= (B.width*0.55 + Math.max(e.width,e.height)*0.18);

      const state = B.hitMap.get(e);
      if(inside){
        if(!state){
          // first hit
          const dmg = B.damage1;
          const final = applyEnemyDamage(e, dmg);
          showDamageNumber(e.x,e.y, final);
          createParticles(e.x+e.width/2,e.y+e.height/2,'#4fc3f7',10,4);
          B.hitMap.set(e,{firstHit:now,left:false,extraDone:false});
        } else {
          // check linger bonus only if stayed inside continuously
          if(!state.extraDone && !state.left && (now - state.firstHit) >= 180){
            const dmg2=B.damageStay;
            const final2 = applyEnemyDamage(e, dmg2);
            showDamageNumber(e.x,e.y, final2);
            createParticles(e.x+e.width/2,e.y+e.height/2,'#81d4fa',12,4);
            state.extraDone=true;
          }
        }
      } else {
        if(state && !state.extraDone){
          state.left=true;
        }
      }
    });
  }
}

function drawTempBeams(){
  tempBeams.forEach(B=>{
    const x1=B.x1, y1=B.y1, x2=B.x2, y2=B.y2;
    ctx.save();
    ctx.lineCap='round';

    // glow
    ctx.globalAlpha=0.22;
    ctx.strokeStyle='#00b0ff';
    ctx.lineWidth=B.width*2.4;
    ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();

    // core
    ctx.globalAlpha=0.85;
    ctx.strokeStyle='#4fc3f7';
    ctx.lineWidth=B.width;
    ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();

    // white highlight
    ctx.globalAlpha=0.65;
    ctx.strokeStyle='rgba(255,255,255,0.9)';
    ctx.lineWidth=Math.max(2, B.width*0.22);
    ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();

    ctx.restore();
  });
}

function spawnPickup(x,y,type,value=0){
  // Small collectible pickup (compatible with updatePickups / drawPickups)
  const hitR = (type==='malus') ? MALUS_HIT_RADIUS : BONUS_HIT_RADIUS;
  pickups.push({x,y,type,value,created:Date.now(),ttl:20000,radius:18,hitRadius:hitR,w:28,h:28});
}

// Guaranteed StellarBonus drop: on levels 5/10/15/20/25, the LAST enemy alive always drops a StellarBonus exactly where it dies.
const GUARANTEED_STELLAR_LEVELS = new Set([5,10,15,20,25]);
function dropStellarBonusAtIndexIfNeeded(enemyIndex){
  if(!GUARANTEED_STELLAR_LEVELS.has(currentLevel)) return;
  // if we're about to remove an enemy and it's the last one on the field, enemies.length is 1 at this exact moment
  if(enemies.length !== 1) return;
  const e = enemies[enemyIndex];
  if(!e) return;
  const cx = e.x + (e.width||0)/2;
  const cy = e.y + (e.height||0)/2;
  spawnPickup(cx, cy, 'stellar');
}
function spawnPickupsForLevel(level){
  // IMPORTANT: do NOT clear existing pickups here.
  // Bonus pickups remain on the field when the level ends.
  if(level<4) return;

  const count=1+Math.floor(Math.random()*2);
  for(let i=0;i<count;i++){
    const isGold=Math.random()<GOLD_PROB;
    const type=isGold ? 'gold' : pickRandomPickupType();

    const x=60+Math.random()*(canvas.width-240);
    const y=60+Math.random()*(canvas.height-180);

    const hitR = (type==='malus') ? MALUS_HIT_RADIUS : BONUS_HIT_RADIUS;
    // keep visual size small (radius:18) but increase hitbox via hitRadius
    pickups.push({type,x,y,radius:18,hitRadius:hitR,created:Date.now(),ttl:20000});
  }
}
function drawPickups(){
  pickups.forEach(p=>{
    const img = getPickupImage(p.type);
    // Keep the existing small pickup size:
    // - if pickup defines w/h use those
    // - else if pickup defines radius use diameter
    // - fallback to 28px
    const w = (p.w!=null)?p.w: (p.radius!=null)?(p.radius*2):28;
    const h = (p.h!=null)?p.h: (p.radius!=null)?(p.radius*2):28;
    const dw = w*2;
    const dh = h*2;

    if(img && img.complete && img.naturalWidth>0){
      ctx.drawImage(img, p.x - dw/2, p.y - dh/2, dw, dh);
    } else {
      // Fallback if image not yet loaded
      if(p.type==='heal')ctx.fillStyle='#2ecc71';
      else if(p.type==='atk')ctx.fillStyle='#e74c3c';
      else if(p.type==='super')ctx.fillStyle='#f1c40f';
      else if(p.type==='gold')ctx.fillStyle='gold';
      else if(p.type==='stellar')ctx.fillStyle='rgba(255,255,255,0.9)';
      else if(p.type==='speed')ctx.fillStyle='#3498db';
      else if(p.type==='shieldPickup')ctx.fillStyle='#7fdbff';
      else if(p.type==='malus')ctx.fillStyle='#8b0000';
      ctx.beginPath();
      ctx.arc(p.x,p.y,(p.radius!=null)?p.radius:Math.min(w,h)/2,0,Math.PI*2);
      
ctx.shadowColor = '#000000';
ctx.shadowBlur = 25;

ctx.fill();
    }
  });
}

function updatePickups(playerRef){
  // Use player CENTER for pickup collection checks.
  // This fixes edge cases where (using top-left) some pickups became uncollectable near arena borders.
  const pcx = playerRef.x + (playerRef.width||0)/2;
  const pcy = playerRef.y + (playerRef.height||0)/2;

  pickups = pickups.filter(p=>{
    if(Date.now()-p.created>p.ttl) return false;

    const dist = Math.hypot((p.x-pcx),(p.y-pcy));
    const pr = (p.hitRadius!=null) ? p.hitRadius : (p.radius!=null ? p.radius : 18);

    if(dist < pr + Math.max(playerRef.width,playerRef.height)/2){
      applyPickupEffect(playerRef,p.type);
      try{ accountOnPickupCollected(p.type); }catch(e){}
      return false;
    }
    return true;
  });
}
function applyPickupEffect(playerRef,type){
  if(type==='heal'){
    const healAmount=Math.round(playerRef.maxHP*0.25);
    const _before=playerRef.hp;
    playerRef.hp=Math.min(playerRef.maxHP,playerRef.hp+healAmount);
    try{ accountOnHeal(playerRef.hp - _before); }catch(e){}
    createParticles(playerRef.x,playerRef.y,'#2ecc71',20);
  } else if(type==='atk'){
    playerRef.attackBuffMultiplier=1.6;
    playerRef.attackBuffUntil=Date.now()+10000;
    createParticles(playerRef.x,playerRef.y,'#e74c3c',20);
  } else if(type==='super'){
    playerRef.lastSuper=Date.now()-playerRef.superCooldown-100;
    createParticles(playerRef.x,playerRef.y,'#f1c40f',20);
    } else if(type==='stellar'){
    // StellarBonus: +100 HP, +25% speed for 3s, white opaque glow for 3s
    const _beforeHp = playerRef.hp;
    playerRef.hp = Math.min(playerRef.maxHP, playerRef.hp + 100);
    try{ accountOnHeal(playerRef.hp - _beforeHp); }catch(e){}
    playerRef.speed = playerRef._baseSpeed * 1.25;
    playerRef.speedBuffUntil = Date.now() + 3000;
    playerRef.stellarGlowUntil = Date.now() + 1000;
    createParticles(playerRef.x, playerRef.y, '#000000', 36, 5);
  } else if(type==='gold'){
    const _beforeHp = playerRef.hp;
    playerRef.hp=playerRef.maxHP;
    try{ accountOnHeal(playerRef.hp - _beforeHp); }catch(e){}
    playerRef.attackBuffMultiplier=2.0;
    playerRef.attackBuffUntil=Date.now()+15000;
    playerRef.lastSuper=Date.now()-playerRef.superCooldown-100;
    createParticles(playerRef.x,playerRef.y,'gold',40);
    for(let i=0;i<8;i++) createParticles(playerRef.x+(Math.random()-0.5)*40,playerRef.y+(Math.random()-0.5)*40,'#fff176',6);
  } else if(type==='speed'){
    playerRef.speed=playerRef._baseSpeed*1.5;
    playerRef.speedBuffUntil=Date.now()+7000;
    createParticles(playerRef.x,playerRef.y,'#3498db',20);
  } else if(type==='shieldPickup'){
    playerRef.pickupShieldUntil=Date.now()+6000;
    playerRef.invulnerable=true;
    createParticles(playerRef.x,playerRef.y,'#7fdbff',30);

    } else if(type==='furia'){
    // Cura nel tempo: +10 HP/s per 10s
    playerRef.furiaHealUntil = Date.now()+10000;
    playerRef.furiaLastHeal = Date.now();

    // Onde di danno (3 aree visibili che si allargano)
    const cx = playerRef.x + playerRef.width/2;
    const cy = playerRef.y + playerRef.height/2;
    spawnFuriaWaves(cx, cy);

    // Extra feedback visivo
    createParticles(cx,cy,'#ff00ff',70,6);
  } else if(type==='ice'){
    enemies.forEach(e=>{
      e.speed *= 0.4;
      e.iceUntil = Date.now()+17000;
      e.iceDps = 2;
      e.iceLastTick = Date.now();
    });
    createParticles(playerRef.x,playerRef.y,'#000000',40);
  } else if(type==='malus'){
    playerRef.poisonUntil=Date.now()+10000;
    playerRef.poisonTickLast=Date.now();
    playerRef.poisonTickDamage=1;
    createParticles(playerRef.x,playerRef.y,'#8b0000',30);
  }
}

class Player{
  constructor(type){
    const s=characterStats[type];
    this.type=type;
    this.x=canvas.width/2;this.y=canvas.height/2;
    this.width=130;this.height=135;
    this.vx=0;this.vy=0;
    this.maxHP=s.hp;this.hp=s.hp;
    this.speed=s.speed;this._baseSpeed=s.speed;
    // Archer slow (temporary): stacks up to -15% total
    this._slowPct=0;
    this._slowUntil=0;
    this.damage=s.damage;this.range=s.range;
    this.cooldown=s.cooldown;this.attackType=s.attackType;
    this._baseCooldown=s.cooldown;
    // Bane SUPER state
    this.baneSuperUntil=0;
    this.baneSuperAttackMult=1;
    this._baneSuperAppliedCooldown=false;
    this.lastAttack=0;this.facingRight=true;
    this.aimX=1;this.aimY=0; // ultima direzione di mira/movimento
    this.dashCooldown=0.0;this.attacking=false;this.attackTime=0;
    this.combo=0;this.damageTaken=0;this.isDashing=false;this.dashTime=0;
    this.superCooldown=s.superCooldown;this.superDuration=s.superDuration;
    this.lastSuper=-s.superCooldown;this.isDoingSuper=false;this.superStartTime=0;
    this.superTargets=[];this.grappleTarget=null;this.isGrappling=false;
    this.grappleStartTime=0; // safety timeout for grapple

    // Jimmy SUPER grapple pass-through helpers (no "grab" interaction)
    this._superGrapplePassUntil=0;
    this._superGrappleDirX=1;
    this._superGrappleDirY=0;
    this.aimAssistRadius=400;this.aimAssistStrength=0.35;
    this._superHitDone=false;this._superPhase=0;
    this.shieldActive=false;this.shieldDurability=4;this.shieldMaxDurability=4;this.shieldBroken=false;this.shieldBrokenTime=0;this.shieldRegenMs=6000;
    this.attackBuffMultiplier=1;this.attackBuffUntil=0;this.speedBuffUntil=0;this.pickupShieldUntil=0;this.invulnerable=false;
    this._dashSpeedMult=3;
    this._dashDuration=200;

    // Kouvagia dash-attack helpers
    this._kouvagiaDashActive=false;
    this._kouvagiaDashHitCd=0;
    this._kouvagiaExplosionPending=false;
    this._kouvagiaSuperFxStart=0;
    this._kouvagiaSuperFxUntil=0;

    // Jimmy jetpack
    this.jetpackCooldown=15000;
    this.lastJetpack=Date.now()-this.jetpackCooldown;
    this.isJetpacking=false;
    this.jetpackDuration=3000;
    this._jetpackSpeedMultiplier=2;

    this.lastSuper=-99999;
    this.poisonUntil=0;
    this.poisonTickLast=0;
    this.poisonTickDamage=1;

    // --- Evolution (after Boss level 15) ---
    this.evolved=false;
    this._evoFxUntil=0;
    // StellarBonus visual
    this.stellarGlowUntil=0;
    this._jimmyNextGrappleCdMult=1;
  }

  evolve(){
    if(this.evolved) return;
    this.evolved=true;
    this._evoFxUntil=Date.now()+650;
    // passive is enabled by this.evolved flag, no stat changes
  }


  // Rallentamento temporaneo (usato da alcuni nemici/boss)
  // pct: 0.20 = -10% velocit√†. durationMs in millisecondi.
  applySlow(pct, durationMs){
    const now=Date.now();
    const p=Math.max(0, Math.min(0.60, pct||0)); // cap 60% (Boss5 usa 50%)
    this._slowPct = Math.min(0.60, Math.max(this._slowPct||0, p));
    this._slowUntil = Math.max(this._slowUntil||0, now + (durationMs||0));
  }

  findClosestEnemy(radius=this.aimAssistRadius){
    let closest=null;let best=radius;
    enemies.forEach(e=>{
      const dx=(e.x+e.width/2)-(this.x+this.width/2);
      const dy=(e.y+e.height/2)-(this.y+this.height/2);
      const dist=Math.hypot(dx,dy);
      if(dist<best){best=dist;closest=e}
    });
    return closest;
  }

  update(){
    const now=Date.now();

    // COSMO: breve invulnerabilit√† (dash) ‚Äî evita invulnerabilit√† permanente
    if(this.type==='cosmo'){
      if(this._cosmoInvulUntil && now > this._cosmoInvulUntil){
        // non disattivare l'invulnerabilit√† se √® attiva quella del pickup scudo
        if(!(this.pickupShieldUntil && now < this.pickupShieldUntil)){
          this.invulnerable = false;
        }
        this._cosmoInvulUntil = 0;
      }
      try{ _cosmoRecalcDmgMult(); }catch(e){}
    }

    if(this.shieldBroken&&now-this.shieldBrokenTime>this.shieldRegenMs){
      this.shieldBroken=false;this.shieldDurability=this.shieldMaxDurability
    }
    if(this.attackBuffUntil && now>this.attackBuffUntil){this.attackBuffMultiplier=1;this.attackBuffUntil=0}
    if(this._slowUntil && now>this._slowUntil){ this._slowUntil=0; this._slowPct=0; }
    if(this.speedBuffUntil && now>this.speedBuffUntil){
      this.speed=this._baseSpeed;this.speedBuffUntil=0;this.isJetpacking=false;this.invulnerable=false
    }
    // Bane SUPER speed boost handling (independent from pickups)
    if(this.type==='bane'){
      if(this.baneSuperSpeedUntil && now < this.baneSuperSpeedUntil){
        this.speed = Math.max(this.speed, this._baseSpeed * 1.25);
      } else if(this.baneSuperSpeedUntil && now >= this.baneSuperSpeedUntil){
        this.baneSuperSpeedUntil = 0;
        // if no other speed buff is active, restore base speed
        if(!(this.speedBuffUntil && now < this.speedBuffUntil)){
          this.speed = this._baseSpeed;
        }
      }
    }

    if(this.pickupShieldUntil && now>this.pickupShieldUntil){this.pickupShieldUntil=0;this.invulnerable=false}

    // Furia heal-over-time (+10 HP/s for 10s)
    if(this.furiaHealUntil && now < this.furiaHealUntil){
      if(!this.furiaLastHeal) this.furiaLastHeal = now;
      if(now - this.furiaLastHeal >= 1000){
        this.furiaLastHeal = now;
        const _beforeHp = this.hp;
        this.hp = Math.min(this.maxHP, this.hp + 10);
        try{ accountOnHeal(this.hp - _beforeHp); }catch(e){}
        createParticles(this.x+this.width/2, this.y+this.height/2, '#ff00ff', 8, 3);
      }
    } else {
      this.furiaLastHeal = 0;
      this.furiaHealUntil = 0;
    }

    // Jimmy jetpack passive
    if(this.type==='jimmy'){
      if(!this.isJetpacking && now-this.lastJetpack>=this.jetpackCooldown && !this.isDoingSuper){
        this.isJetpacking=true;
        this.lastJetpack=now;
        this.invulnerable=true;
        this.speed=this._baseSpeed * this._jetpackSpeedMultiplier;
        this.speedBuffUntil=now+this.jetpackDuration;
      }
      if(this.isJetpacking && now>=this.speedBuffUntil){
        this.isJetpacking=false;
        this.invulnerable=false;
        this.speed=this._baseSpeed;
      }
    }


    // Salsy passive: speed boost every 12s for 2s (DOUBLES BASE SPEED ONLY)
    if(this.type==='salsy'){
      if(!this._salsyBoostCooldown){
        this._salsyBoostCooldown = 12000;
        this._salsyBoostDuration = 2000;
        this.lastSalsyBoost = now - this._salsyBoostCooldown;
        this.salsyBoostUntil = 0;
      }

      if(!this.isDoingSuper && now - this.lastSalsyBoost >= this._salsyBoostCooldown){
        this.lastSalsyBoost = now;
        this.salsyBoostUntil = now + this._salsyBoostDuration;
      }

      if(this.salsyBoostUntil && now < this.salsyBoostUntil){
        // SOLO velocit√† base raddoppiata
        this.speed = this._baseSpeed * 2;
      }
      else if(this.salsyBoostUntil && now >= this.salsyBoostUntil){
        this.salsyBoostUntil = 0;

        // Ripristino corretto
        if(this.speedBuffUntil && now < this.speedBuffUntil){
          this.speed = this._baseSpeed * 1.5;
        } else {
          this.speed = this._baseSpeed;
        }
      }
    }

    // Poison

    if(this.poisonUntil && now < this.poisonUntil){
      if(!this.poisonTickLast) this.poisonTickLast = now;
      if(now - this.poisonTickLast >= 1000){
        this.poisonTickLast = now;
        this.hp = Math.max(0, this.hp - (this.poisonTickDamage||1));
        createParticles(this.x,this.y,'#8b0000',6,3);
        if(this.hp<=0 && gameState==='playing') endGame(false);
      }
    } else this.poisonTickLast = 0;

    // Movement
    let moveX=0,moveY=0;
    if(!this.isGrappling){
      if(keys['a']){moveX=-1;this.facingRight=false}
      if(keys['d']){moveX=1;this.facingRight=true}
      if(keys['w'])moveY=-1;
      if(keys['s'])moveY=1
    }
    if(moveX!==0&&moveY!==0){moveX*=0.707;moveY*=0.707}

    // aggiorna direzione di mira (per attacchi in tutte le direzioni)
    if(moveX!==0 || moveY!==0){
      const len=Math.hypot(moveX,moveY)||1;
      this.aimX=moveX/len;
      this.aimY=moveY/len;
    }

    // Kaerith (J) - Attacco continuo a ventaglio stretto (30¬∞) con danno progressivo per bersaglio
    if(this.type==='kaerith'){
      if(keys['j'] && !this.isDoingSuper){
        if(!this._kaerithFlame){
          this._kaerithFlame={
            start: now,
            lastPulse: 0,
            pulseMs: 90,
            range: (characterStats?.[this.type]?.range ?? 206),                 // range ridotto (-30%)
            angle: Math.PI/6,           // 30¬∞
            dir:(()=>{  if(typeof enemies!=='undefined' && enemies && enemies.length){    const pcx=this.x+this.width/2, pcy=this.y+this.height/2;    let best=null, bestD=1e18;    for(const e of enemies){      const ex=e.x+e.width/2, ey=e.y+e.height/2;      const d=(ex-pcx)*(ex-pcx)+(ey-pcy)*(ey-pcy);      if(d<bestD){bestD=d; best={x:ex,y:ey};}    }    if(best) return Math.atan2(best.y-pcy, best.x-pcx);  }  return Math.atan2(this.aimY||0, this.aimX||1);})()
          };
        } else {
          this._kaerithFlame.dir = (()=>{  if(typeof enemies!=='undefined' && enemies && enemies.length){    const pcx=this.x+this.width/2, pcy=this.y+this.height/2;    let best=null, bestD=1e18;    for(const e of enemies){      const ex=e.x+e.width/2, ey=e.y+e.height/2;      const d=(ex-pcx)*(ex-pcx)+(ey-pcy)*(ey-pcy);      if(d<bestD){bestD=d; best={x:ex,y:ey};}    }    if(best) return Math.atan2(best.y-pcy, best.x-pcx);  }  return Math.atan2(this.aimY||0, this.aimX||1);})();
        }
      } else {
        this._kaerithFlame=null;
      }
    }


    // Marz super bonus: +50% speed while inside the magic zone
    const marzZoneMult = (this.type==='marz' && isPointInsideMagicZone(this.x+this.width/2, this.y+this.height/2)) ? 1.5 : 1;

    if(this.isDashing){
      const speedNow=this.speed*marzZoneMult*(1-(this._slowPct||0));
      const dashSpeed=speedNow*(this._dashSpeedMult||3);
      this.vx=(this.facingRight?1:-1)*dashSpeed;
      if(this.type==='kouvagia' && this._kouvagiaDashActive){this.vy=0;}

      // Kouvagia: deal damage during dash (tick-based)
      if(this.type==='kouvagia' && this._kouvagiaDashActive){
        if(this._kouvagiaDashHitCd<=0){
          this._kouvagiaDashHitCd=4; // roughly every few frames
          for(let i=enemies.length-1;i>=0;i--){
            const e=enemies[i];
            const dist=Math.hypot((e.x+e.width/2)-(this.x+this.width/2),(e.y+e.height/2)-(this.y+this.height/2));
            if(dist<110){
              const dmg=Math.round(40*this.attackBuffMultiplier*(this.baneSuperAttackMult||1));
              const _dmg=dmg; const _final=applyEnemyDamage(e,_dmg);
              createParticles(e.x,e.y,'#e84393',10,5);
              showDamageNumber(e.x,e.y, _final);
              if(e.hp<=0){
                createParticles(e.x,e.y,'#fff176',30,6);
                dropStellarBonusAtIndexIfNeeded(i);
                enemies.splice(i,1);
                applyScore(100*currentLevel);
                addKill(); this._baneSuperOnKill();
                if(this.type==='kouvagia'){this.hp=Math.min(this.maxHP,this.hp+3);createParticles(this.x,this.y,'#2ecc71',6,3);}
              }
            }
          }
        }else this._kouvagiaDashHitCd--;
      }
      if(now-this.dashTime>(this._dashDuration||200)){
        this.isDashing=false; this.vx=0; this.vy=0; this._dashSpeedMult=3; this._dashDuration=200; if(this.type==='kouvagia'){this._kouvagiaDashActive=false;}
        // Kouvagia: explosion at end of dash
        if(this.type==='kouvagia' && this._kouvagiaExplosionPending){
          this._kouvagiaExplosionPending=false;
    this._kouvagiaSuperFxStart=0;
    this._kouvagiaSuperFxUntil=0;
          this._kouvagiaDashActive=false;
          for(let i=enemies.length-1;i>=0;i--){
            const e=enemies[i];
            const dist=Math.hypot((e.x+e.width/2)-(this.x+this.width/2),(e.y+e.height/2)-(this.y+this.height/2));
            if(dist<165){
              const dmg=Math.round(65*this.attackBuffMultiplier*(this.baneSuperAttackMult||1));
              const _dmg=dmg; const _final=applyEnemyDamage(e,_dmg);
              createParticles(e.x,e.y,'#fd79a8',16,5);
              showDamageNumber(e.x,e.y, _final);
              if(e.hp<=0){
                createParticles(e.x,e.y,'#fff176',30,6);
                dropStellarBonusAtIndexIfNeeded(i);
                enemies.splice(i,1);
                applyScore(100*currentLevel);
                addKill(); this._baneSuperOnKill();
                if(this.type==='kouvagia'){this.hp=Math.min(this.maxHP,this.hp+3);createParticles(this.x,this.y,'#2ecc71',6,3);}
              }
            }
          }
          shakeScreen();
        }

      }
    } else if(!this.isGrappling){
      const speedNow=this.speed*marzZoneMult*(1-(this._slowPct||0));
      this.vx=moveX*speedNow+this.vx*0.1;
            this.vy=moveY*speedNow+this.vy*0.1;
    }

    // Grapple chase
    // Jimmy grapple rework:
    // - L'attacco base NON "si attacca" al bersaglio: Jimmy si avvicina e si ferma a pochi pixel.
    // - Quando √® abbastanza vicino, esegue un colpo a ventaglio (120¬∞) con raggio 90.
    if(this.isGrappling&&this.grappleTarget){
      if(!enemies.includes(this.grappleTarget)){
        this.isGrappling=false;this.grappleTarget=null;this.grappleStartTime=0;
      } else {
        const pcx=this.x+this.width/2, pcy=this.y+this.height/2;
        const tcx=this.grappleTarget.x+this.grappleTarget.width/2, tcy=this.grappleTarget.y+this.grappleTarget.height/2;
        const dx=tcx-pcx;const dy=tcy-pcy;
        const dist=Math.hypot(dx,dy);const speedMult=5;
        // Safety: some special enemies may not have valid geometry; avoid NaN lock
        if(!Number.isFinite(dx)||!Number.isFinite(dy)||!Number.isFinite(dist)){
          this.isGrappling=false;this.grappleTarget=null;this.vx=0;this.vy=0;this.grappleStartTime=0;
        }

        const stopDist=62; // "un po' di pixel" dal nemico
        if(dist>stopDist){
          this.vx=(dx/(dist||1))*this.speed*marzZoneMult*speedMult;
          this.vy=(dy/(dist||1))*this.speed*marzZoneMult*speedMult;
        } else {
          // Fan hit: 120¬∞ cone, radius 90 (small hit)
          const dirAngle=Math.atan2(dy,dx);
          const arcWidth=Math.PI*(120/180);
          const radius=90;

          const baseDmg=Math.round(this.damage*0.65*this.attackBuffMultiplier*(this.baneSuperAttackMult||1));

          let killedGrappleTarget=false;

          for(let i=enemies.length-1;i>=0;i--){
            const e=enemies[i];
            const ex=e.x+e.width/2, ey=e.y+e.height/2;
            const edx=ex-pcx, edy=ey-pcy;
            const edist=Math.hypot(edx,edy);
            if(edist<=radius){
              const ang=Math.atan2(edy,edx);
              let diff=ang-dirAngle;
              while(diff>Math.PI) diff-=Math.PI*2;
              while(diff<-Math.PI) diff+=Math.PI*2;
              if(Math.abs(diff)<=arcWidth/2){
                const _final=applyEnemyDamage(e, baseDmg);
                createParticles(e.x,e.y,'#e74c3c',14,5);
                showDamageNumber(e.x,e.y,_final);
                if(e.hp<=0){
                  if(e===this.grappleTarget) killedGrappleTarget=true;
                  createParticles(e.x,e.y,'#fff176',30,6);
                  dropStellarBonusAtIndexIfNeeded(i);
                  enemies.splice(i,1);
                  applyScore(100*currentLevel);
                addKill(); this._baneSuperOnKill();
                }
              }
            }
          }

          // Jimmy EVO passive: next grapple has -20% cooldown after a grappled target dies
          if(this.type==='jimmy' && this.evolved && killedGrappleTarget){ this._jimmyNextGrappleCdMult=0.8; }

          this.isGrappling=false;this.grappleTarget=null;this.vx=0;this.vy=0;this.grappleStartTime=0;
        }
      }
    }

    // Super handling
    if(this.isDoingSuper){
      const elapsed=now-this.superStartTime;
      if(this.type==='jimmy'){this.invulnerable=true;this.shieldActive=true}

      if(this.attackType==='punch'){
        if(!this._superHitDone&&elapsed>=300){
          this._superHitDone=true;
          if(this.type==='rooney'){
            // Rooney SUPER (rework):
            // - Area QUADRATA centrata su Rooney.
            // - Danno totale massimo: 300 (senza buff) distribuito tra TUTTI i nemici nell'area.
            // - Falloff: pi√π un nemico √® lontano dal centro, meno danno subisce.
            const half=320; // mezzo lato del quadrato (lato=640) [60% pi√π grande]
            const px=this.x+this.width/2, py=this.y+this.height/2;
            // VISUAL: show the super area on screen
            try{ addRooneyAreaFX(px, py, half); }catch(e){}
            const hits=[];
            // 3 fasce (come in UI): centro (rosso) > medio (arancione) > esterno (giallo)
            // Usiamo la distanza "Chebyshev" (max(|dx|,|dy|)) per ottenere quadri concentrici.
            const innerHalf = half * 0.55; // fascia centrale
            const midHalf   = half * 0.80; // fascia intermedia

            for(const enemy of enemies){
              const ex=enemy.x+enemy.width/2, ey=enemy.y+enemy.height/2;
              const dx=ex-px, dy=ey-py;
              if(Math.abs(dx)<=half && Math.abs(dy)<=half){
                const d = Math.max(Math.abs(dx), Math.abs(dy)); // quadri concentrici
                let w = 0.25; // fascia esterna (gialla) - danno minimo ma sempre presente
                if(d <= innerHalf) w = 1.00;        // centro (rosso)
                else if(d <= midHalf) w = 0.55;     // medio (arancione)
                hits.push({enemy,w, dist:d});
              }
            }

            if(hits.length>0){
              // Compensiamo SUPER_DAMAGE_MULT cos√¨ che la SOMMA dei danni (senza buff) sia 300.
              const totalBase=Math.round(350 / SUPER_DAMAGE_MULT);
              const sumW=hits.reduce((a,h)=>a+h.w,0) || 1;

              for(const h of hits){
                const share=h.w/sumW;
                const raw=totalBase*share;
                const dmg=Math.max(6, Math.round(raw * SUPER_DAMAGE_MULT * this.attackBuffMultiplier));
                const _final=applyEnemyDamage(h.enemy, dmg);

                // Hit FX
                createParticles(h.enemy.x,h.enemy.y,'#f39c12',22,6);
                showDamageNumber(h.enemy.x,h.enemy.y, _final);
              }

              // Ground-break FX (debris + dust) nell'area quadrata
              createParticles(px,py,'#795548',55,8);
              for(let k=0;k<12;k++){
                const rx=px + (Math.random()*2-1)*half;
                const ry=py + (Math.random()*2-1)*half;
                createParticles(rx,ry,'#6d4c41',14,6);
                createParticles(rx,ry,'#b0bec5',8,4);
              }

              // rimuovi i morti (e assegna score) subito, come per le altre super
              for(let i=enemies.length-1;i>=0;i--){
                if(enemies[i].hp<=0){
                  createParticles(enemies[i].x,enemies[i].y,'#fff176',30,6);
                  dropStellarBonusAtIndexIfNeeded(i);
                  enemies.splice(i,1);
                  applyScore(100*currentLevel);
                addKill(); this._baneSuperOnKill();
                }
              }
            }
          } else {
            enemies.forEach((enemy,idx)=>{
              const dist=Math.hypot(enemy.x-this.x,enemy.y-this.y);
              if(dist<350){
                const base=(this.type==='jimmy')?300:140;
                const mult=(this.type==='jimmy')?(SUPER_DAMAGE_MULT*JIMMY_SUPER_ADDITIONAL_MULT):SUPER_DAMAGE_MULT;
                let extra=1;if(this.type==='rooney'&&dist<150)extra=1.5;
                const dmg=Math.round(base*mult*extra*this.attackBuffMultiplier*(this.baneSuperAttackMult||1));
                const _dmg=dmg; const _final=applyEnemyDamage(enemy,_dmg);
                createParticles(enemy.x,enemy.y,'#f39c12',30,6);
                showDamageNumber(enemy.x,enemy.y, _final);
                if(enemy.hp<=0){
  if(player && player.type==='jeff' && player.evolved){
    player.hp = Math.min(Number(player.maxHP)||0, (Number(player.hp)||0) + 5);
}
                  createParticles(enemy.x,enemy.y,'#fff176',30,6);
                  // IRA kill special FX (Bane SUPER)
                  if(player && player.type==='bane' && Date.now() < player.baneSuperUntil){
                    createIraKillFX(enemy.x, enemy.y);
                  }
                  dropStellarBonusAtIndexIfNeeded(idx);
                  enemies.splice(idx,1);
                  applyScore(100*currentLevel);addKill(); this._baneSuperOnKill();
                }
              }
            });
          }
          shakeScreen();
        }
        if(elapsed>=this.superDuration)this.endSuper();

            } else if(this.attackType==='grapple'){
        // Jimmy SUPER rework:
        // - NON si aggrappa ai nemici (niente "stop" sul bersaglio).
        // - Jimmy li attraversa (pass-through) e applica lo stesso colpo/danni quando li raggiunge.
        const chaseSpeed=this.speed*6;

        // Se siamo nel "pass-through window", continua dritto nella direzione salvata
        if(this._superGrapplePassUntil && now < this._superGrapplePassUntil){
          this.vx=this._superGrappleDirX*chaseSpeed;
          this.vy=this._superGrappleDirY*chaseSpeed;
        } else {
          this._superGrapplePassUntil=0;

          if(this.superTargets.length>0){
            const target=this.superTargets[0];
            if(!enemies.includes(target)){
              this.superTargets.shift();
            } else {
              const px=this.x+this.width/2, py=this.y+this.height/2;
              const tx=target.x+target.width/2, ty=target.y+target.height/2;
              const dx=tx-px;const dy=ty-py;
              const dist=Math.hypot(dx,dy);

              if(dist>50){
                this.vx=(dx/(dist||1))*chaseSpeed;
                this.vy=(dy/(dist||1))*chaseSpeed;
              } else {
                // hit once, then keep moving forward briefly (pass-through)
                const base=120;
                const mult=(this.type==='jimmy')?(SUPER_DAMAGE_MULT*JIMMY_SUPER_ADDITIONAL_MULT):SUPER_DAMAGE_MULT;
                const dmg=Math.round(base*mult*this.attackBuffMultiplier*(this.baneSuperAttackMult||1)*(this.type==='jimmy'?2.0:1));
                const _final=applyEnemyDamage(target, dmg);
                createParticles(target.x,target.y,'#e74c3c',15,6);
                showDamageNumber(target.x,target.y, _final);
                if(target.hp<=0){
                  createParticles(target.x,target.y,'#fff176',30,6);
                  const idx=enemies.indexOf(target);
                  if(idx>-1){dropStellarBonusAtIndexIfNeeded(idx);enemies.splice(idx,1);applyScore(100*currentLevel);addKill(); this._baneSuperOnKill();
                }
                }

                // store direction and move through (no interaction/stop)
                let nx=dx/(dist||1), ny=dy/(dist||1);
                if(!isFinite(nx) || !isFinite(ny)){ nx=this.facingRight?1:-1; ny=0; }
                this._superGrappleDirX=nx; this._superGrappleDirY=ny;
                this._superGrapplePassUntil=now+160;

                // next target
                this.superTargets.shift();
                this._superPhase=Date.now();
              }
            }
          } else {
            if(now-this.superStartTime>=Math.min(this.superDuration,1200))this.endSuper();
          }
        }
      } else if(this.attackType==='sword'){
        if(elapsed>=0&&elapsed<this.superDuration){
          if(!this._lastSwordTick||now-this._lastSwordTick>=180){
            this._lastSwordTick=now;
            enemies.forEach((enemy,idx)=>{
              const dist=Math.hypot(enemy.x-this.x,enemy.y-this.y);
              if(dist<JEFF_SUPER_RADIUS){
                const tickDmg=Math.round(28*SUPER_DAMAGE_MULT);
                const _dmg=tickDmg; const _final=applyEnemyDamage(enemy,_dmg);
                createParticles(enemy.x,enemy.y,'#9b59b6',8,4);
                showDamageNumber(enemy.x,enemy.y, _final);
                if(enemy.hp<=0){
  if(player && player.type==='jeff' && player.evolved){
    player.hp = Math.min(Number(player.maxHP)||0, (Number(player.hp)||0) + 5);
}
                  createParticles(enemy.x,enemy.y,'#fff176',30,6);
                  dropStellarBonusAtIndexIfNeeded(idx);
                  enemies.splice(idx,1);
                  applyScore(100*currentLevel);addKill(); this._baneSuperOnKill();
                }
              }
            });
          }
        } else this.endSuper();

      
      } else if(this.attackType==='salsySword'){
        if(elapsed>=this.superDuration) this.endSuper();

      
    } else if(this.attackType==='axeattack'){
      // BANE axe wide swing: 270¬∞ fan, hits max 2 enemies
      const attackAngle = this.facingRight ? 0 : Math.PI;
      const arcWidth = Math.PI * 1.5; // 270 degrees
      let hits = 0;
      // sort enemies by distance (closer hit first)
      const sorted = enemies.slice().sort((a,b)=>{
        const da=Math.hypot(a.x-this.x,a.y-this.y);
        const db=Math.hypot(b.x-this.x,b.y-this.y);
        return da-db;
      });
      sorted.forEach(enemy=>{
        if(hits>=2) return;
        const dx=enemy.x-this.x;
        const dy=enemy.y-this.y;
        const dist=Math.hypot(dx,dy);
        const angle=Math.atan2(dy,dx);
        let angleDiff=angle-attackAngle;
        while(angleDiff>Math.PI) angleDiff-=Math.PI*2;
        while(angleDiff<-Math.PI) angleDiff+=Math.PI*2;
        if(dist < this.range && Math.abs(angleDiff) < arcWidth/2){
          const superMult = (this.type==='bane' && this.baneSuperUntil && now < this.baneSuperUntil) ? (this.baneSuperAttackMult||1) : 1;
          const base = this.damage * this.attackBuffMultiplier * superMult;
          const dmg = applyEnemyDamage(enemy, base);
          createParticles(enemy.x,enemy.y,'#c0392b',14,6);
          showDamageNumber(enemy.x,enemy.y,dmg);
          hits++;
          if(enemy.hp<=0){
            createParticles(enemy.x,enemy.y,'#fff176',30,6);
            dropStellarBonusAtIndexIfNeeded(enemies.indexOf(enemy));
            enemies.splice(enemies.indexOf(enemy),1);
            applyScore(100*currentLevel);
          addKill(); this._baneSuperOnKill();
                }
        }
      });


    } else if(this.attackType==='lucienBlade'){
        if(elapsed>=this.superDuration) this.endSuper();

      } else if(this.attackType==='kouvagia'){
        if(elapsed>=this.superDuration) this.endSuper();
} else if(this.attackType==='hybrid'){

        if(now - this.superStartTime >= this.superDuration){
          this.endSuper();
        }
      } else if(this.attackType==='tempostormLaser'){
        // Tempostorm SUPER is applied instantly in superAttack(); keep VFX only for superDuration.
        if(elapsed>=this.superDuration){
          this.endSuper();
        }
      } else if(this.attackType==='hecateBow'){
        // H√®cate SUPER: heal happens instantly; keep short FX then end.
        if(elapsed>=this.superDuration){
          this.endSuper();
        }
      } else if(this.attackType==='magic'){
        // Freeze is applied instantly in superAttack(); keep VFX only for superDuration.
        if(elapsed>=this.superDuration){
          this.endSuper();
        }
      } else if(this.attackType==='cosmo'){
        if(elapsed>=this.superDuration){
          this.endSuper();
        }
      }
    }
    

    // handle Kaerith continuous fan attack (per-target progressive damage, max 90)
    if(this.type==='kaerith' && this._kaerithFlame){
      const F=this._kaerithFlame;
      const now2=Date.now();

      if(!F.lastPulse) F.lastPulse = now2;
      if(now2 - F.lastPulse >= F.pulseMs){
        F.lastPulse = now2;

        const pcx=this.x+this.width/2, pcy=this.y+this.height/2;
        // Aim-assist: orienta il ventaglio verso il nemico pi√π vicino (se presente)
        if(enemies && enemies.length){
          let best=null, bestD=1e18;
          for(const e of enemies){
            const ex=e.x+e.width/2, ey=e.y+e.height/2;
            const d=(ex-pcx)*(ex-pcx)+(ey-pcy)*(ey-pcy);
            if(d<bestD){bestD=d; best={x:ex,y:ey};}
          }
          if(best){ F.dir=Math.atan2(best.y-pcy, best.x-pcx); }
        }
        const dir=F.dir;
        const arc=F.angle;
        const r=F.range;

        // Track per-enemy "time inside cone" (reset quickly if leaves)
        for(let i=enemies.length-1;i>=0;i--){
          const e=enemies[i];
          const ex=e.x+e.width/2, ey=e.y+e.height/2;
          const dx=ex-pcx, dy=ey-pcy;
          const dist=Math.hypot(dx,dy);

          let inside=false;
          if(dist<=r){
            const ang=Math.atan2(dy,dx);
            let diff=ang-dir;
            while(diff>Math.PI) diff-=Math.PI*2;
            while(diff<-Math.PI) diff+=Math.PI*2;
            if(Math.abs(diff)<=arc/2) inside=true;
          }

          if(inside){
            // start/continue inside timer
            if(!e._kaerithInsideSince || (e._kaerithLastInside && (now2 - e._kaerithLastInside)>220)){
              e._kaerithInsideSince = now2;
            }
            e._kaerithLastInside = now2;

            const insideSec = Math.max(0, (now2 - e._kaerithInsideSince)/1000);

            // Progressive damage: starts low, ramps up while the SAME enemy stays inside, caps at 90
            const base = 8;
            const slope = 13; // ramp ridotta (-35%)
            const dmg = Math.min(59, Math.round(base + insideSec * slope));

            const final = applyEnemyDamage(e, dmg * (this.attackBuffMultiplier||1) * (this.baneSuperAttackMult||1));
            showDamageNumber(e.x, e.y, final);
            createParticles(ex, ey, '#ff3d00', 6, 3);

            if(e.hp<=0){
              createParticles(e.x,e.y,'#fff176',30,6);
              dropStellarBonusAtIndexIfNeeded(i);
              enemies.splice(i,1);
              applyScore(100*currentLevel);
              addKill(); if(this._baneSuperOnKill) this._baneSuperOnKill();
            }
          } else {
            // reset if outside for a short moment
            if(e._kaerithLastInside && (now2 - e._kaerithLastInside)>260){
              e._kaerithLastInside=0;
              e._kaerithInsideSince=0;
            }
          }
        }
      }
    }
// === Kaerith SUPER DoT: Infuocato (progressivo 5 -> 25) ===
if(this.type==='kaerith' && this._kaerithFireUntil && Date.now() < this._kaerithFireUntil){
  const nowF = Date.now();
  if(!this._kaerithFireLastTick) this._kaerithFireLastTick = nowF;
  if(nowF - this._kaerithFireLastTick >= 1000){
    this._kaerithFireLastTick = nowF;

    const elapsedSec = Math.floor((nowF - (this._kaerithFireStart||nowF))/1000);
    // progressione: 5 al secondo 0, fino a 25 entro 8s (cap 25)
    const prog = Math.min(19, Math.round(4 + (elapsedSec * (15/8))));
    const dmg = Math.max(0, prog);

    if(typeof enemies!=='undefined' && enemies && enemies.length){
      for(const e of enemies){
        if(e && typeof e.hp==='number' && e.hp>0){
          e.hp -= dmg;
          // piccolo feedback visivo (brace/ember)
          createParticles(e.x+e.width/2, e.y+e.height/2, '#ff6d00', 6, 3);
        }
      }
    }
  }
}



// handle Hendel hammer sweep (clockwise 75¬∞)
    if(this.type==='hendel' && this._hammerSwing){
      const H=this._hammerSwing;
      const now2=Date.now();
      const t=Math.max(0, Math.min(1, (now2 - H.start)/H.duration));

      // end
      if(t>=1){ this._hammerSwing=null; }
      else if(enemies && enemies.length){
        // clockwise: from baseAng + arc/2 down to baseAng - arc/2
        const angStart = H.baseAng + H.arc/2;
        const angEnd   = H.baseAng - H.arc/2;
        const ang = angStart + (angEnd - angStart) * t;

        const cx=this.x+this.width/2;
        const cy=this.y+this.height/2;

        const cos=Math.cos(ang), sin=Math.sin(ang);
        // rotate world->local by -ang: x' = dx*cos + dy*sin, y' = -dx*sin + dy*cos
        // NOTE: this swing can hit ONLY ONE opponent total
        for(let i=enemies.length-1;i>=0;i--){
          if(H.hitDone) break;
          const e=enemies[i];
          if(H.hitSet && H.hitSet.has(e)) continue;

          const ex=e.x+e.width/2;
          const ey=e.y+e.height/2;
          const dx=ex-cx, dy=ey-cy;

          const lx = dx*cos + dy*sin;
          const ly = -dx*sin + dy*cos;

          const inHandle =
            (lx >= H.handleStart && lx <= (H.handleStart + H.handleLen) &&
             Math.abs(ly) <= (H.handleW/2));

          const hs = H.headSize;
          const hx0 = H.headOffset - hs/2;
          const hx1 = H.headOffset + hs/2;
          const inHead =
            (lx >= hx0 && lx <= hx1 &&
             Math.abs(ly) <= (hs/2));

          if(inHandle || inHead){
            if(H.hitSet) H.hitSet.add(e);

            // Only one enemy per swing
            H.hitDone = true;

            // Stun for 0.5s
            e.stunnedUntil = Date.now() + 500;

            const dmgBase = 120 * (this.attackBuffMultiplier||1) * (this.baneSuperAttackMult||1);
            const final = applyEnemyDamage(e, dmgBase);

            showDamageNumber(e.x, e.y, final);
            createParticles(ex, ey, '#ff8c1a', 18, 5);

            if(e.hp<=0){
              createParticles(e.x,e.y,'#fff176',30,6);
              dropStellarBonusAtIndexIfNeeded(i);
              enemies.splice(i,1);
              applyScore(100*currentLevel);
              addKill(); if(this._baneSuperOnKill) this._baneSuperOnKill();
            }
          }
        }
      }
    }

    // integrate velocity

    this.x+=this.vx;this.y+=this.vy;
    if(!keys['a']&&!keys['d']&&!this.isDashing&&!this.isGrappling)this.vx*=0.86;
    if(!keys['w']&&!keys['s']&&!this.isGrappling)this.vy*=0.86;

    const margin=10;
    const push=10;
    let hitWall=false;
    const B=getPlayBounds();

    const left=B.left+margin, right=B.right-margin;
    const top=B.top+margin, bottom=B.bottom-margin;

    if(this.x<left){ this.x=left+push; hitWall=true; }
    if(this.x+this.width>right){ this.x=right-this.width-push; hitWall=true; }
    if(this.y<top){ this.y=top+push; hitWall=true; }
    if(this.y+this.height>bottom){ this.y=bottom-this.height-push; hitWall=true; }

    if(hitWall){ createParticles(this.x+this.width/2,this.y+this.height/2,'#90caf9',6,3); }

    if(this.dashCooldown>0)this.dashCooldown--;

    if(this.attacking&&Date.now()-this.attackTime>300){
      this.attacking=false;
      if(this.type==='jimmy'&&this.shieldActive&&!this.isDoingSuper){
        this.shieldActive=false;
      }
    }
  }

  dodge(){
    if(this.dashCooldown<=0&&!this.isDoingSuper){
      this.isDashing=true;this.dashTime=Date.now();


      // COSMO dash: short teleport + cosmic trail (0.5s) + slightly longer cooldown
      if(this.type==='cosmo'){
        const now=Date.now();
        const ox=this.x+this.width/2, oy=this.y+this.height/2;
        const dirX=(this.aimX|| (this.facingRight?1:-1));
        const dirY=(this.aimY||0);
        const len=Math.hypot(dirX,dirY)||1;
        const ax=dirX/len, ay=dirY/len;
        const dist=170;

        // trail at origin
        if(!window.cosmoTrails) window.cosmoTrails = [];
        window.cosmoTrails.push({x:ox, y:oy, until: now+500, lastTick: now});

        // teleport
        this.x = Math.max(getPlayBounds().left+10, Math.min(getPlayBounds().right-this.width-10, this.x + ax*dist));
        this.y = Math.max(getPlayBounds().top+10,  Math.min(getPlayBounds().bottom-this.height-10, this.y + ay*dist));

        // brief invulnerability window
        this.invulnerable = true;
        this._cosmoInvulUntil = now + 180;

        // cooldown: +1.2s vs normal (approx)
        this.dashCooldown = 51.25;// reduced -75% cooldown (was 162)
        this.isDashing = false;
        return;
      }


      // Kouvagia passive: dodge deals 10 damage to nearby enemies
      if(this.type==='kouvagia'){
        for(let i=enemies.length-1;i>=0;i--){
          const e=enemies[i];
          const dist=Math.hypot((e.x+e.width/2)-(this.x+this.width/2),(e.y+e.height/2)-(this.y+this.height/2));
          if(dist<95){
            const _dmg=10; const _final=applyEnemyDamage(e,_dmg);
            createParticles(e.x,e.y,'#ff7675',8,4);
            showDamageNumber(e.x,e.y, _final);
            if(e.hp<=0){
              createParticles(e.x,e.y,'#fff176',30,6);
              dropStellarBonusAtIndexIfNeeded(i);
              enemies.splice(i,1);
              applyScore(100*currentLevel);
                addKill(); this._baneSuperOnKill();
                if(this.type==='kouvagia'){this.hp=Math.min(this.maxHP,this.hp+3);createParticles(this.x,this.y,'#2ecc71',6,3);}
            }
          }
        }
      }
      if(this.type==='jimmy' || this.type==='voltryx' || this.type==='kouvagia' || this.type==='hecate' || this.type==='lucien'){
        this._dashSpeedMult=4;
        this._dashDuration=300;
        this.dashCooldown=112.5;
      } else {
        this._dashSpeedMult=3;
        this._dashDuration=200;
        this.dashCooldown=112.5;
      }
    }
  }

  attack(){
    const now=Date.now();
    // Allow Cosmo to keep using base attack (J) even while SUPER is active
    if(now-this.lastAttack<this.cooldown || (this.isDoingSuper && this.type!=='cosmo')) return false;
    // Jimmy EVO passive: if unlocked, the next grapple gets -20% cooldown (only for that next grapple)
    if(this.type==='jimmy' && this.evolved && this.attackType==='grapple' && this._jimmyNextGrappleCdMult && this._jimmyNextGrappleCdMult<1){
      const mult=this._jimmyNextGrappleCdMult;
      this.lastAttack = now - Math.round(this.cooldown*(1-mult));
      this._jimmyNextGrappleCdMult=1;
    } else {
      this.lastAttack=now;
    }
    this.attacking=true;this.attackTime=now;

    if(this.type==='jimmy'&&!this.shieldBroken){this.shieldActive=true;}

    const assistTarget=this.findClosestEnemy();
    if(assistTarget){
      const dx=(assistTarget.x+assistTarget.width/2)-(this.x+this.width/2);
      this.facingRight=dx>=0;
      const dist=Math.hypot(dx,(assistTarget.y+assistTarget.height/2)-(this.y+this.height/2));
      if(dist>10){
        const nx=dx/dist;
        const ny=((assistTarget.y+assistTarget.height/2)-(this.y+this.height/2))/dist;
        this.vx+=nx*this.speed*this.aimAssistStrength;
        this.vy+=ny*this.speed*this.aimAssistStrength;
      }
    }

    if(this.attackType==='cosmo'){
      const cx=this.x+this.width/2, cy=this.y+this.height/2;
      const dirX=(this.aimX|| (this.facingRight?1:-1));
      const dirY=(this.aimY||0);
      const aimLen=Math.hypot(dirX,dirY)||1;
      const ax=dirX/aimLen, ay=dirY/aimLen;


      // If a Singolarit√† is active, allow a precise "billiard" tap to change its direction.
      // Fix: the hitbox used to be too generous, so sometimes your shot would "hit the orb" instead of nearby enemies.
      // New rules:
      //  - if an enemy is very close to the player, we ALWAYS prioritize the enemy shot (no orb redirect)
      //  - orb redirect only if the orb is fairly near and you aim very precisely at it
      if(window.cosmoSingularity && window.cosmoSingularity.active){
        // If there is a close enemy, don't let the orb steal the shot
        let closeEnemy=false;
        for(const e of enemies){
          const ex=e.x+e.width/2, ey=e.y+e.height/2;
          const dd=Math.hypot(ex-cx, ey-cy);
          if(dd <= 140){ closeEnemy=true; break; }
        }

        if(!closeEnemy){
          const orb=window.cosmoSingularity;
          const ox=orb.x, oy=orb.y;
          const vx=ox-cx, vy=oy-cy;
          const proj = vx*ax + vy*ay;

          // Only when the orb is in front AND reasonably close
          if(proj>0 && proj <= Math.min(this.range, 260)){
            const perp = Math.abs(vx*ay - vy*ax);
            const hitR = (orb.r*0.65) + 8; // tighter than before
            if(perp <= hitR){
              const sp = Math.min(6.5, Math.max(3.2, (orb.speed||3.6) + 1.2));
              orb.vx = ax*sp;
              orb.vy = ay*sp;
              orb.speed = sp;
              // small hit feedback
              try{ createParticles(ox,oy,'#b8e6ff',14,4); }catch(e){}
              return true;
            }
          }
        }
      }

      // AIMBOT 360¬∞: pick best enemy anywhere within range (works both left & right)
      // We still give a small preference to the current aim direction (if any), but enemies behind can be selected.
      let best=null, bestScore=1e18;
      for(const enemy of enemies){
        const ex=enemy.x+enemy.width/2, ey=enemy.y+enemy.height/2;
        const dx=ex-cx, dy=ey-cy;
        let dist=Math.hypot(dx,dy);
        if(dist>this.range) continue;

        // If the enemy is overlapping/point-blank, always lock it in.
        // This fixes rare cases where an enemy sits exactly on the player and would be skipped due to dist‚âà0.
        if(dist < 14){
          best = enemy; bestScore = -1;
          break;
        }

        // angle cost vs aim direction (0..pi). If no aim, keep it neutral.
        // Guard against tiny distances to avoid NaN.
        dist = Math.max(dist, 0.001);
        let angleCost=0;
        const dot=((dx/dist)*ax + (dy/dist)*ay);
        const clampedDot=Math.max(-1, Math.min(1, dot));
        angleCost = Math.acos(clampedDot); // radians

        // Score: closest wins, with mild aim-direction bias
        const score = dist + angleCost*90; // 90px per rad (~141px at pi/2)
        if(score<bestScore){ best=enemy; bestScore=score; }
      }
      if(!best) return true;

      // VISUAL: show Cosmo shot on screen
      try{ addCosmoShot(cx, cy, best.x+best.width/2, best.y+best.height/2); }catch(e){}

      // base hit + apply/trigger Marchio Cosmico
      const base = (this.damage||36) * this.attackBuffMultiplier * (this._cosmoDmgMult||1);
      const dealt = applyEnemyDamage(best, base);
      createParticles(best.x,best.y,'#8bd3ff',10,4);
      showDamageNumber(best.x,best.y,dealt);

      // Mark logic
      if(!best._cosmoMark){
        best._cosmoMark = { applied: now, explodeAt: now+1000, mini:false };
      }else{
        // Re-hit before explosion => trigger immediate burst (+60%) + double slow
        if(now < (best._cosmoMark.explodeAt||0)){
          best._cosmoMark.triggerNow = true;
        }else{
          best._cosmoMark = { applied: now, explodeAt: now+1000, mini:false };
        }
      }

      return true;
    }

    else if(this.attackType==='punch'){
      if(this.type==='rooney'){
        const multipliers=[1,1.15,1.25];
        // 360¬∞ aimbot:
        // - Aim: punta SEMPRE verso il nemico pi√π vicino (anche fuori range), per coerenza visiva.
        // - Hit: applica danno SOLO se il nemico √® entro range.
        const pcx=this.x+this.width/2, pcy=this.y+this.height/2;

        // Aim target (qualunque distanza)
        let aimTarget=null; let aimDist=Infinity;
        enemies.forEach(enemy=>{
          const ecx=enemy.x+enemy.width/2, ecy=enemy.y+enemy.height/2;
          const dist=Math.hypot(ecx-pcx, ecy-pcy);
          if(dist<aimDist){ aimDist=dist; aimTarget=enemy; }
        });
        this._rooneyAimTarget = aimTarget || null;

        // Locked target per il danno (entro range)
        let lockedTarget=null; let lockedDist=this.range;
        enemies.forEach(enemy=>{
          const ecx=enemy.x+enemy.width/2, ecy=enemy.y+enemy.height/2;
          const dist=Math.hypot(ecx-pcx, ecy-pcy);
          if(dist<=lockedDist){ lockedDist=dist; lockedTarget=enemy; }
        });
for(let i=0;i<3;i++){
          setTimeout(((idx)=>{
            return ()=>{
              // usa bersaglio bloccato se valido, altrimenti ri-seleziona entro range (centri)
              const pcx2=this.x+this.width/2, pcy2=this.y+this.height/2;
              // aggiorna aim verso il nemico pi√π vicino (anche fuori range)
              try{
                let aim=null; let aimD=Infinity;
                for(const e of enemies){
                  const ex=e.x+e.width/2, ey=e.y+e.height/2;
                  const d=Math.hypot(ex-pcx2, ey-pcy2);
                  if(d<aimD){ aimD=d; aim=e; }
                }
                this._rooneyAimTarget = aim || this._rooneyAimTarget || null;
              }catch(e){}

              let closestEnemy = (lockedTarget && lockedTarget.hp>0) ? lockedTarget : null;

              if(closestEnemy){
                const ecx=closestEnemy.x+closestEnemy.width/2, ecy=closestEnemy.y+closestEnemy.height/2;
                const dist=Math.hypot(ecx-pcx2, ecy-pcy2);
                if(dist>this.range) closestEnemy=null;
              }

              if(!closestEnemy){
                let closestDist=this.range;
                enemies.forEach(enemy=>{
                  const ecx=enemy.x+enemy.width/2, ecy=enemy.y+enemy.height/2;
                  const dist=Math.hypot(ecx-pcx2, ecy-pcy2);
                  if(dist<=closestDist){closestDist=dist;closestEnemy=enemy}
                });
                lockedTarget = closestEnemy || null;
                this._rooneyAimTarget = lockedTarget;
              }

              if(closestEnemy){
                const baseDmg=this.damage;
                const dmg=Math.round(baseDmg * multipliers[idx] * this.attackBuffMultiplier);
                const _dmg=dmg; const _final=applyEnemyDamage(closestEnemy,_dmg);
                createParticles(closestEnemy.x,closestEnemy.y,'#e67e22',12,5);
                showDamageNumber(closestEnemy.x,closestEnemy.y, _final);
                if(closestEnemy.hp<=0){
                  createParticles(closestEnemy.x,closestEnemy.y,'#fff176',30,6);
                  const idxEnemy=enemies.indexOf(closestEnemy);
                  if(idxEnemy>-1){dropStellarBonusAtIndexIfNeeded(idxEnemy);enemies.splice(idxEnemy,1);applyScore(100*currentLevel);addKill(); this._baneSuperOnKill();
                }
                }
              }
            };
          })(i), i*240);
        }
      } else {
        let closestEnemy=null;let closestDist=this.range;
        enemies.forEach(enemy=>{
          const dx=enemy.x-this.x;const dy=enemy.y-this.y;
          const dist=Math.hypot(dx,dy);
          if(dist<closestDist&&Math.abs(dy)<220){closestDist=dist;closestEnemy=enemy}
        });
        if(closestEnemy){
          const dmg=Math.round(this.damage*this.attackBuffMultiplier*(this.baneSuperAttackMult||1));
          const _dmg=dmg; const _final=applyEnemyDamage(closestEnemy,_dmg);
          createParticles(closestEnemy.x,closestEnemy.y,'#e67e22',12,5);
          showDamageNumber(closestEnemy.x,closestEnemy.y, _final);
          if(closestEnemy.hp<=0){
            createParticles(closestEnemy.x,closestEnemy.y,'#fff176',30,6);
            dropStellarBonusAtIndexIfNeeded(enemies.indexOf(closestEnemy));
            enemies.splice(enemies.indexOf(closestEnemy),1);
            applyScore(100*currentLevel);
          addKill(); this._baneSuperOnKill();
                }
        } else if(assistTarget){
          const distA=Math.hypot((assistTarget.x-this.x),(assistTarget.y-this.y));
          if(distA<this.range+240){
            const dmg=Math.round(this.damage*0.9*this.attackBuffMultiplier*(this.baneSuperAttackMult||1));
            const _dmg=dmg; const _final=applyEnemyDamage(assistTarget,_dmg);
            createParticles(assistTarget.x,assistTarget.y,'#e67e22',12,5);
            showDamageNumber(assistTarget.x,assistTarget.y, _final);
            if(assistTarget.hp<=0){
              createParticles(assistTarget.x,assistTarget.y,'#fff176',30,6);
              dropStellarBonusAtIndexIfNeeded(enemies.indexOf(assistTarget));
              enemies.splice(enemies.indexOf(assistTarget),1);
              applyScore(100*currentLevel);
            addKill(); this._baneSuperOnKill();
                }
          }
        }
      }

    } else if(this.attackType==='grapple'){
      let closestEnemy=assistTarget;
      if(!closestEnemy){
        let closestDist=this.range;
        enemies.forEach(enemy=>{
          const dist=Math.hypot(enemy.x-this.x,enemy.y-this.y);
          if(dist<closestDist){closestDist=dist;closestEnemy=enemy}
        })
      }
      if(closestEnemy){
        // Safety: require valid enemy geometry to avoid grappling NaN and getting stuck
        const _w=closestEnemy.width, _h=closestEnemy.height;
        if(Number.isFinite(closestEnemy.x)&&Number.isFinite(closestEnemy.y)&&Number.isFinite(_w)&&Number.isFinite(_h)){
          this.grappleTarget=closestEnemy;this.isGrappling=true;this.grappleStartX=this.x;this.grappleStartY=this.y;this.grappleStartTime=Date.now();
        }
      }

    } else if(this.attackType==='salsySword'){
      // Two consecutive fan slashes (25x2) at medium-close range
      const attackAngle=this.facingRight?0:Math.PI;
      const arcWidth=Math.PI*1.35;
      const doSwing = ()=>{
        enemies.forEach(enemy=>{
          const dx=enemy.x-this.x;const dy=enemy.y-this.y;const dist=Math.hypot(dx,dy);
          const angle=Math.atan2(dy,dx);
          let angleDiff=angle-attackAngle;
          while(angleDiff>Math.PI)angleDiff-=Math.PI*2;
          while(angleDiff<-Math.PI)angleDiff+=Math.PI*2;
          if(dist<this.range && Math.abs(angleDiff)<arcWidth/2+0.15){
            const base=37*this.attackBuffMultiplier*(this.baneSuperAttackMult||1);
            const dmg=applyEnemyDamage(enemy, base);
            createParticles(enemy.x,enemy.y,'#f1c40f',10,4);
            showDamageNumber(enemy.x,enemy.y,dmg);
            if(enemy.hp<=0){
  if(player && player.type==='jeff' && player.evolved){
    player.hp = Math.min(Number(player.maxHP)||0, (Number(player.hp)||0) + 5);
}
              createParticles(enemy.x,enemy.y,'#fff176',30,6);
              dropStellarBonusAtIndexIfNeeded(enemies.indexOf(enemy));
              enemies.splice(enemies.indexOf(enemy),1);
              applyScore(100*currentLevel);
            addKill(); this._baneSuperOnKill();
                }
          }
        });
      };
      doSwing();
      setTimeout(doSwing, 240);


    
    } else if(this.attackType==='axeattack'){
      // BANE axe wide swing: 270¬∞ fan, hits max 2 enemies
      const attackAngle = this.facingRight ? 0 : Math.PI;
      const arcWidth = Math.PI * 1.5; // 270 degrees
      let hits = 0;
      // sort enemies by distance (closer hit first)
      const sorted = enemies.slice().sort((a,b)=>{
        const da=Math.hypot(a.x-this.x,a.y-this.y);
        const db=Math.hypot(b.x-this.x,b.y-this.y);
        return da-db;
      });
      sorted.forEach(enemy=>{
        if(hits>=2) return;
        const dx=enemy.x-this.x;
        const dy=enemy.y-this.y;
        const dist=Math.hypot(dx,dy);
        const angle=Math.atan2(dy,dx);
        let angleDiff=angle-attackAngle;
        while(angleDiff>Math.PI) angleDiff-=Math.PI*2;
        while(angleDiff<-Math.PI) angleDiff+=Math.PI*2;
        if(dist < this.range && Math.abs(angleDiff) < arcWidth/2){
          const superMult = (this.type==='bane' && this.baneSuperUntil && now < this.baneSuperUntil) ? (this.baneSuperAttackMult||1) : 1;
          const base = this.damage * this.attackBuffMultiplier * superMult;
          const dmg = applyEnemyDamage(enemy, base);
          createParticles(enemy.x,enemy.y,'#c0392b',14,6);
          showDamageNumber(enemy.x,enemy.y,dmg);
          hits++;
          if(enemy.hp<=0){
            createParticles(enemy.x,enemy.y,'#fff176',30,6);
            dropStellarBonusAtIndexIfNeeded(enemies.indexOf(enemy));
            enemies.splice(enemies.indexOf(enemy),1);
            applyScore(100*currentLevel);
          addKill(); this._baneSuperOnKill();
                }
        }
      });


    } else if(this.attackType==='lucienBlade'){
      // 4 colpi ravvicinati (15x4), stile simile a Salsy ma pi√π vicino
      const attackAngle=this.facingRight?0:Math.PI;
      const arcWidth=Math.PI*1.05;
      const doSwing = ()=>{
        enemies.forEach(enemy=>{
          const dx=enemy.x-this.x;const dy=enemy.y-this.y;const dist=Math.hypot(dx,dy);
          const angle=Math.atan2(dy,dx);
          let angleDiff=angle-attackAngle;
          while(angleDiff>Math.PI)angleDiff-=Math.PI*2;
          while(angleDiff<-Math.PI)angleDiff+=Math.PI*2;

          if(dist<this.range && Math.abs(angleDiff)<arcWidth/2+0.20){
            const base=15*this.attackBuffMultiplier*(this.baneSuperAttackMult||1);
            const dmg=applyEnemyDamage(enemy, base);
            createParticles(enemy.x,enemy.y,'#c8e6ff',8,4);
            showDamageNumber(enemy.x,enemy.y,dmg);
            if(enemy.hp<=0){
              createParticles(enemy.x,enemy.y,'#fff176',30,6);
              dropStellarBonusAtIndexIfNeeded(enemies.indexOf(enemy));
              enemies.splice(enemies.indexOf(enemy),1);
              applyScore(100*currentLevel);
            addKill(); this._baneSuperOnKill();
                }
          }
        });
      };
      doSwing();
      setTimeout(doSwing, 85);
      setTimeout(doSwing, 170);
      setTimeout(doSwing, 255);

    } else if(this.attackType==='sword'){
      const attackAngle=this.facingRight?0:Math.PI;const arcWidth=Math.PI*1.6;
      let __jeffHitCount=0;
      enemies.forEach(enemy=>{
        const dx=enemy.x-this.x;const dy=enemy.y-this.y;const dist=Math.hypot(dx,dy);
        const angle=Math.atan2(dy,dx);
        let angleDiff=angle-attackAngle;
        while(angleDiff>Math.PI)angleDiff-=Math.PI*2;
        while(angleDiff<-Math.PI)angleDiff+=Math.PI*2;
        if(dist<this.range&&Math.abs(angleDiff)<arcWidth/2+0.2){
          const dmg=Math.round(this.damage*this.attackBuffMultiplier*(this.baneSuperAttackMult||1));
          const _dmg=dmg; const _final=applyEnemyDamage(enemy,_dmg);
          createParticles(enemy.x,enemy.y,'#9b59b6',10,4);
          showDamageNumber(enemy.x,enemy.y, _final);
          if(enemy.hp<=0){
  if(player && player.type==='jeff' && player.evolved){
    player.hp = Math.min(Number(player.maxHP)||0, (Number(player.hp)||0) + 5);
}
            createParticles(enemy.x,enemy.y,'#fff176',30,6);
            dropStellarBonusAtIndexIfNeeded(enemies.indexOf(enemy));
            enemies.splice(enemies.indexOf(enemy),1);
            applyScore(100*currentLevel);addKill(); this._baneSuperOnKill();
                }
        }
      });
      // Jeff EVO passive: if a single attack hits 2+ enemies, heal 1% max HP
      if(this.type==='jeff' && this.evolved && __jeffHitCount>=2){
        const heal = Math.max(1, Math.round(this.maxHP*0.01));
        const _beforeHp = this.hp;
        this.hp = Math.min(this.maxHP, this.hp + heal);
        try{ accountOnHeal(this.hp - _beforeHp); }catch(e){}
        createParticles(this.x+this.width/2,this.y+this.height/2,'#2ecc71',10,4);
      }
      if(assistTarget){
        const distAssist=Math.hypot((assistTarget.x-this.x),(assistTarget.y-this.y));
        if(distAssist<this.range+60){
          const dmg=Math.round(this.damage*0.7*this.attackBuffMultiplier*(this.baneSuperAttackMult||1));
          const _dmg=dmg; const _final=applyEnemyDamage(assistTarget,_dmg);
          createParticles(assistTarget.x,assistTarget.y,'#9b59b6',10,4);
          showDamageNumber(assistTarget.x,assistTarget.y, _final);
          if(assistTarget.hp<=0){
            createParticles(assistTarget.x,assistTarget.y,'#fff176',30,6);
            dropStellarBonusAtIndexIfNeeded(enemies.indexOf(assistTarget));
            enemies.splice(enemies.indexOf(assistTarget),1);
            applyScore(100*currentLevel);addKill(); this._baneSuperOnKill();
                }
        }
      }

    
    } else if(this.attackType==='kouvagia'){

      // Kouvagia: mini dash forward dealing damage during dash + small/medium AoE on stop
      this.isDashing=true;
      this.dashTime=Date.now();
      this._dashSpeedMult=5.2;
      this._dashDuration=260;
      this.dashCooldown=118.75;

      this._kouvagiaDashActive=true;
      this._kouvagiaDashHitCd=0;
      this._kouvagiaExplosionPending=true;

    } else if(this.attackType==='hybrid'){
      
      const target=assistTarget || this.findClosestEnemy(800);
      const dist = target ? Math.hypot((target.x+target.width/2)-(this.x+this.width/2),(target.y+target.height/2)-(this.y+this.height/2)) : Infinity;

      if(dist>150 && target){
        // Ranged: small energy sphere with small AoE
        const dx=(target.x+target.width/2)-(this.x+this.width/2);
        const dy=(target.y+target.height/2)-(this.y+this.height/2);
        const len=Math.hypot(dx,dy)||1;
        const speed=9;
        const vx=(dx/len)*speed;
        const vy=(dy/len)*speed;
        const baseAoeDmg = Math.round(45* this.attackBuffMultiplier);
        spawnProjectile({
          x:this.x+this.width/2, y:this.y+this.height/2,
          vx, vy, speed,
          damage:baseAoeDmg, ttl:2000, color:'#ffb74d',
          radius:9, friendly:true, aoeRadius:110, aoeFullDamage:true, homing:false,
          explodeOnExpire:true
        });
        createParticles(this.x+this.width/2,this.y+this.height/2,'#ffa726',8,3);
      } else {
        // Close: two quick punches, slightly less strong than Rooney
        const perPunchBase=50; // Rooney base ~60; Voltryx slightly less
        const punch = ()=>{
          let closest=null;let best=160;
          enemies.forEach(e=>{
            const d=Math.hypot(e.x-this.x,e.y-this.y);
            if(d<best && Math.abs(e.y-this.y)<220){best=d;closest=e}
          });
          if(closest){
            const dmg=Math.round(perPunchBase*this.attackBuffMultiplier*(this.baneSuperAttackMult||1));
            const _dmg=dmg; const _final=applyEnemyDamage(closest,_dmg);
            createParticles(closest.x,closest.y,'#e67e22',12,5);
            showDamageNumber(closest.x,closest.y, _final);
            if(closest.hp<=0){
              createParticles(closest.x,closest.y,'#fff176',30,6);
              dropStellarBonusAtIndexIfNeeded(enemies.indexOf(closest));
              enemies.splice(enemies.indexOf(closest),1);
              applyScore(100*currentLevel);
            addKill(); this._baneSuperOnKill();
                }
          }
        };
        punch();
        setTimeout(punch, 240);
      }
    }

else if(this.attackType==='hecateBow'){
  // H√®cate: long range arrow that splits into 3 arrows hitting other enemies
  const target = assistTarget || this.findClosestEnemy(this.range);
  const sx=this.x+this.width/2;
  const sy=this.y+this.height/2;

  let dx,dy;
  if(target){
    dx=(target.x+target.width/2)-sx;
    dy=(target.y+target.height/2)-sy;
  } else {
    dx=this.facingRight?1:-1;
    dy=0;
  }
  const len=Math.hypot(dx,dy)||1;
  const speed=13;
  const vx=(dx/len)*speed;
  const vy=(dy/len)*speed;

  const mainDmg = Math.round(this.damage*1.25*this.attackBuffMultiplier*(this.baneSuperAttackMult||1));
  const splitDmg = Math.round(mainDmg * 0.5); // frecce minori: met√† del danno della freccia principale

  spawnProjectile({
    x:sx,y:sy,
    vx,vy,speed,
    damage:mainDmg,
    ttl:720,
    color:'#e0e0e0',
    radius:6,
    friendly:true,
    shape:'rect',
    w:22,
    h:5,
    angle:Math.atan2(vy,vx),
    meta:{type:'hecateMain', splitDamage: splitDmg}
  });
  createParticles(sx,sy,'#c5cae9',14,4);
}
else if(this.attackType==='tempostormLaser'){
  const assistTarget=this.findClosestEnemy(900);
  const sx=this.x+this.width/2;
  const sy=this.y+this.height/2;

  let dx,dy,len;
  if(assistTarget){
    dx=(assistTarget.x+assistTarget.width/2)-sx;
    dy=(assistTarget.y+assistTarget.height/2)-sy;
  }else{
    dx=this.facingRight?1:-1; dy=0;
  }
  len=Math.hypot(dx,dy)||1;
  const ex=sx+(dx/len)*this.range;
  const ey=sy+(dy/len)*this.range;

  spawnTempBeam({
    x1:sx,y1:sy,x2:ex,y2:ey,
    width:18,ttl:260,
    damage1:Math.round(40*this.attackBuffMultiplier*(this.baneSuperAttackMult||1)),
    damageStay:Math.round(30*this.attackBuffMultiplier*(this.baneSuperAttackMult||1))
  });
  createParticles(sx,sy,'#4fc3f7',14,4);
}

else if(this.attackType==='magic'){
  const damages = (characterStats.marz && characterStats.marz.tripleDamage) ? characterStats.marz.tripleDamage : [40,50,60];
  const colors = ['#ff00ff','#00e5ff','#fff176'];

  // Choose up to 3 distinct targets; if fewer, stack on available targets
  const sorted=enemies.slice().sort((a,b)=>{
    const da=Math.hypot((a.x+a.width/2)-(this.x+this.width/2),(a.y+a.height/2)-(this.y+this.height/2));
    const db=Math.hypot((b.x+b.width/2)-(this.x+this.width/2),(b.y+b.height/2)-(this.y+this.height/2));
    return da-db;
  });
  const targets = sorted.slice(0,3);
  const fallback = targets[0] || this.findClosestEnemy(this.range);

  for(let i=0;i<3;i++){
    const t = targets[i] || fallback;
    if(!t) continue;

    const sx=this.x+this.width/2;
    const sy=this.y+this.height/2;
    const tx=t.x+t.width/2;
    const ty=t.y+t.height/2;
    const dx=tx-sx, dy=ty-sy;
    const len=Math.hypot(dx,dy)||1;

    const speed=11;
    const vx=(dx/len)*speed;
    const vy=(dy/len)*speed;

    spawnProjectile({
      x:sx,y:sy,
      vx,vy,speed,
      damage:Math.round(damages[i]*this.attackBuffMultiplier*(this.baneSuperAttackMult||1)),
      ttl:520,
      color:colors[i%colors.length],
      radius:7,
      friendly:true,
      aoeRadius:0,
      homing:true,
      // IMPORTANT: lock each beam to its chosen target (3 different enemies if available)
      targetRef:t
    });
    createParticles(sx,sy,colors[i%colors.length],10,4);
  }
}



    return true;
  }

  superAttack(){
    const now=Date.now();


    // COSMO SUPER ‚Äî Singolarit√† Errante (7s, mobile, steering via base attack)
    if(this.type==='cosmo'){
      const now2=Date.now();
      const sc=(this.superCooldown!=null)?this.superCooldown:25000;
      if(now2-this.lastSuper<sc || this.isDoingSuper) return false;
      this.lastSuper = now2;
      this.isDoingSuper = true;
      this.superStartTime = now2;

      const cx=this.x+this.width/2, cy=this.y+this.height/2;
      const dirX=(this.aimX|| (this.facingRight?1:-1));
      const dirY=(this.aimY||0);
      spawnCosmoSingularity(cx, cy, dirX, dirY);
      return true;
    }

    // Bane SUPER:
// - +25% movement speed for 10s
// - base attack cooldown reduced by 75% (cooldown * 0.25) for the whole SUPER
// - during SUPER, base attack gets an extra buff based on current Kill count at activation:
//   0‚Äì25  => +25% (x1.25)
//   26‚Äì50 => +50% (x1.50)
//   51‚Äì75 => +75% (x1.75)
//   76+   => +100% (x2.00)
//   (this multiplier is independent from pickup/bonus buffs)
// - cooldown 60s
    if(this.type==='hendel'){
      const sc = (this.superCooldown!=null)?this.superCooldown:24000;
      if(now - this.lastSuper < sc) return false;
      this.lastSuper = now;

      
      this.invulnerable = true;
      this.pickupShieldUntil = now + 3000;
      startHendelCrush(3000);
      createParticles(this.x+this.width/2,this.y+this.height/2,'#9e9e9e',28,6);
      shakeScreen();

      return true;
    }


    if(this.type==='kaerith'){
      const sc = (this.superCooldown!=null)?this.superCooldown:21000;
      if(now - this.lastSuper < sc) return false;
      this.lastSuper = now;

      // === NEW SUPER: Inferno Totale (9s) ===
      this._kaerithFireStart = now;
      this._kaerithFireUntil = now + 9000;
      this._kaerithFireLastTick = 0;

      // burst FX iniziale
      createParticles(this.x+this.width/2,this.y+this.height/2,'#ff3d00',34,6);
      shakeScreen(7);
      return true;
    }

    if(this.type==='bane'){
      const sc = (this.superCooldown!=null)?this.superCooldown:60000;
      if(now - this.lastSuper < sc) return false;

      this.lastSuper = now;

      const dur = (this.superDuration!=null)?this.superDuration:10000;
      this.baneSuperUntil = now + dur;

      // speed boost (do not downgrade other speed buffs)
      this.speed = Math.max(this.speed, this._baseSpeed * 1.25);

      // cooldown reduction for base attack (only during SUPER)
      if(typeof this.cooldown === 'number'){
        // remember current cooldown (may include other effects)
        this._preBaneSuperCooldown = this.cooldown;

        // SUPER: faster base attack
        this.cooldown = this._baseCooldown * 0.25;
        this._baneSuperAppliedCooldown = true;

        // When SUPER ends (after `dur`), apply fatigue: +75% time between hits
        // Use a timeout so it triggers even if a frame/update is skipped.
        const expectedEnd = this.baneSuperUntil;
        setTimeout(()=>{
          // still the same player instance and the same SUPER window ended
          if(this.type!=='bane') return;
          if(this.baneSuperUntil && this.baneSuperUntil===expectedEnd && Date.now()>=expectedEnd){
            this.baneSuperUntil = 0;
            if(this._baseCooldown!=null){
              this.cooldown = this._baseCooldown * 0.95;
            }
            this._preBaneSuperCooldown = undefined;
            this._baneSuperAppliedCooldown = false;

            // restore speed only if SUPER was the active boost (avoid downgrading other buffs)
            const superSpeed = this._baseSpeed * 1.25;
            if(this.speed <= superSpeed + 0.0001){
              this.speed = this._baseSpeed;
            }
          }
        }, dur + 20);
      }

      // attack multiplier for SUPER (independent from pickup/bonus buffs)
      const k = (typeof kills==='number') ? kills : 0;
      if(k<=25) this.baneSuperAttackMult = 1.25;
      else if(k<=50) this.baneSuperAttackMult = 1.50;
      else if(k<=75) this.baneSuperAttackMult = 1.75;
      else this.baneSuperAttackMult = 2.00;

      return true;
    }

    
// --- FIX: H√àCATE SUPER (ensure it always triggers correctly) ---
// In some later refactors the generic cooldown / isDoingSuper flow can block H√®cate.
// We handle her super explicitly here, mirroring the old working behavior.
if(this.type==='hecate'){
  const sc = (this.superCooldown!=null)?this.superCooldown:22000;
  if(now - this.lastSuper < sc || this.isDoingSuper) return false;

  this.lastSuper = now;
  this.isDoingSuper = true;
  this.superStartTime = now;
  this._superHitDone = false;

  // Heal: 5 HP per enemy on field
  const heal = Math.max(0, (typeof enemies!=='undefined' && enemies)? enemies.length : 0) * 5;
  if(heal>0){
        const _beforeHp = this.hp;
        this.hp = Math.min(this.maxHP, this.hp + heal);
        try{ accountOnHeal(this.hp - _beforeHp); }catch(e){}
    createParticles(this.x+this.width/2,this.y+this.height/2,'#c5cae9',28,6);
  } else {
    createParticles(this.x+this.width/2,this.y+this.height/2,'#c5cae9',16,5);
  }

  // Spawn 3 wolves (max 3)
  spawnWolvesNearPlayer(this, 3);

  shakeScreen();
  return true;
}

if(now-this.lastSuper<this.superCooldown||this.isDoingSuper)return false;
    this.lastSuper=now;this.isDoingSuper=true;this.superStartTime=now;this._HitDone=false;

    if(this.type==='jimmy'){this.invulnerable=true;this.shieldActive=true}

    if(this.attackType==='grapple'){
      const sorted=enemies.slice().sort((a,b)=>{
        const da=Math.hypot(a.x-this.x,a.y-this.y);
        const db=Math.hypot(b.x-this.x,b.y-this.y);
        return da-db
      });
      this.superTargets=sorted.slice(0,6);

      // reset pass-through state
      this._superGrapplePassUntil=0;
      this._superGrappleDirX=this.facingRight?1:-1;
      this._superGrappleDirY=0;
    }
    else if(this.attackType==='punch'){
      createParticles(this.x+this.width/2,this.y+this.height/2,'#f39c12',20,6);
    }
    else if(this.attackType==='sword'){
      createParticles(this.x+this.width/2,this.y+this.height/2,'#9b59b6',20,6);
    }

    else if(this.attackType==='salsySword'){
      // Mark up to 3 enemies; marked enemies take double damage for a while
      const sorted=enemies.slice().sort((a,b)=>{
        const da=Math.hypot((a.x+a.width/2)-(this.x+this.width/2),(a.y+a.height/2)-(this.y+this.height/2));
        const db=Math.hypot((b.x+b.width/2)-(this.x+this.width/2),(b.y+b.height/2)-(this.y+this.height/2));
        return da-db;
      });
      const targets=sorted.slice(0,3);
      const until=now+7000;
      targets.forEach(t=>{
        t.salsyMarkUntil=until;
        createParticles(t.x,t.y,'#f1c40f',22,5);
      });
      createParticles(this.x+this.width/2,this.y+this.height/2,'#f1c40f',26,6);
    }

    else if(this.attackType==='lucienBlade'){
      // Lucien SUPER: spawn 5 collectible bonuses around him (NO gold, NO super-recharge).
      // Bonuses are real pickups collectable by the player.
      const allowedTypes = ['heal','atk','speed','shieldPickup','furia','ice'];
      const px = this.x + this.width/2;
      const py = this.y + this.height/2;

      for(let i=0;i<5;i++){
        const a = Math.random()*Math.PI*2;
        const r = 60 + Math.random()*25;
        const t = allowedTypes[Math.floor(Math.random()*allowedTypes.length)];
        const x = Math.max(40, Math.min(canvas.width-40, px + Math.cos(a)*r));
        const y = Math.max(40, Math.min(canvas.height-90, py + Math.sin(a)*r));
        spawnPickup(x, y, t);
        createParticles(x, y, '#80cbc4', 18, 4);
      }
      createParticles(px, py, '#80cbc4', 30, 6);
    }


    else if(this.attackType==='kouvagia'){

      // Kouvagia super: full heal + large knockback + tiny damage + visual FX
      this.hp=this.maxHP;
      this._kouvagiaSuperFxStart=now;
      this._kouvagiaSuperFxUntil=now+900;
      createParticles(this.x+this.width/2,this.y+this.height/2,'#55efc4',60,6);

      const R=360;
      for(let i=0;i<enemies.length;i++){
        const e=enemies[i];
        const dx=(e.x+e.width/2)-(this.x+this.width/2);
        const dy=(e.y+e.height/2)-(this.y+this.height/2);
        const dist=Math.hypot(dx,dy)||1;
        if(dist<=R){
          // tiny damage
          const dmg=3;
          const _final=applyEnemyDamage(e,dmg);
          showDamageNumber(e.x,e.y,_final);
          createParticles(e.x,e.y,'#81ecec',8,4);
          // knockback
          const push=120;
          e.x += (dx/dist)*push;
          e.y += (dy/dist)*push;
        }
      }
      shakeScreen();
    }
else if(this.attackType==='hybrid'){
     
      const dmgPerPulse = Math.round(120 * this.attackBuffMultiplier);
      spawnProjectile({
        x:this.x+this.width/2,y:this.y+this.height/2,
        vx:(this.facingRight?1:-1)*4,vy:0,speed:6,
        damage:dmgPerPulse,ttl:this.superDuration,color:'#f39c12',
        radius:14,friendly:true,aoeRadius:120,homing:true,
        isVoltryxSuper:true,pulseInterval:260,lastPulse:0
      });
      createParticles(this.x+this.width/2,this.y+this.height/2,'#f39c12',26,6);
      shakeScreen();
    }

else if(this.attackType==='tempostormLaser'){
  const cx=canvas.width/2;
  const cy=(canvas.height-30)/2;
  let stolen=0;

  enemies.forEach(e=>{
    // group to exact center
    e.x = cx - e.width/2;
    e.y = cy - e.height/2;

    const removed = Math.max(0, Math.floor(e.hp/2));
    e.hp = Math.max(0, e.hp - removed);
    stolen += removed;

    if(removed>0){
      showDamageNumber(e.x,e.y, removed);
      createParticles(e.x+e.width/2,e.y+e.height/2,'#00b0ff',18,5);
    }
  });

  if(stolen>0){
    const _beforeHp = this.hp;
    this.hp = Math.min(this.maxHP, this.hp + stolen);
    try{ accountOnHeal(this.hp - _beforeHp); }catch(e){}
    createParticles(this.x+this.width/2,this.y+this.height/2,'#00b0ff',30,6);
  }
  createParticles(cx,cy,'#4fc3f7',60,7);
  shakeScreen();
}



    else if(this.attackType==='hecateBow'){
      // Super: heal 5 HP for each enemy currently present
      const heal = Math.max(0, enemies.length) * 5;
      if(heal>0){
        const _beforeHp = this.hp;
        this.hp = Math.min(this.maxHP, this.hp + heal);
        try{ accountOnHeal(this.hp - _beforeHp); }catch(e){}
        createParticles(this.x+this.width/2,this.y+this.height/2,'#c5cae9',28,6);
      } else {
        createParticles(this.x+this.width/2,this.y+this.height/2,'#c5cae9',16,5);
      }

      // NEW: spawn 3 friendly wolves near H√®cate (max 6 on field)
      spawnWolvesNearPlayer(this, 3);

      shakeScreen();
    }
    else if(this.attackType==='magic'){
      // Super: create a huge colorful magic zone at map center.
      // - Expands slowly for 10s
      // - Deals heavy periodic damage to enemies inside
      // - If Marz stays inside, he gains +50% movement speed
      const cx=canvas.width/2;
      const cy=(canvas.height-30)/2;

      magicZone = {
        x:cx,
        y:cy,
        startsAt:now,
        endsAt:now+6500,
        durationMs:10000,
        startRadius:90,
        maxRadius:560,
        radius:90,
        tickMs:180,
        damagePerTick:Math.round(16*this.attackBuffMultiplier*(this.baneSuperAttackMult||1)),
        lastTick:0,
        colors:['#ff00ff','#00e5ff','#fff176','#7c4dff','#18ffff'],
        colorIdx:0
      };

      // burst FX
      createParticles(cx,cy,'#ff00ff',50,7);
      createParticles(cx,cy,'#00e5ff',50,7);
      createParticles(cx,cy,'#fff176',50,7);
      shakeScreen();
    }


    return true;
  }

  endSuper(){
    this.isDoingSuper=false;this._superHitDone=false;this._lastSwordTick=null;
    this.superTargets=[];this.grappleTarget=null;this.isGrappling=false;
    this.vx*=0.5;this.vy*=0.5;this.invulnerable=false;
    if(this.type==='jimmy')this.shieldActive=false
  }


  takeDamage(damage, attacker){
    if(this.invulnerable||(this.pickupShieldUntil&&Date.now()<this.pickupShieldUntil))return;
    if(this.shieldActive&&!this.shieldBroken){
      this.shieldDurability-=1;
      createParticles(this.x,this.y,'#3498db',12,5);
      if(this.shieldDurability<=0){this.shieldBroken=true;this.shieldBrokenTime=Date.now();this.shieldActive=false}
      return;
    }

    // apply damage to Hendel (or any player)
    this.hp-=damage;
    if(!isFinite(this.hp)) this.hp = 0;
    this.hp = Math.max(0, this.hp);
    this.damageTaken++;
    this.combo=0;
    applyScore(-50);
    this._baneSuperOnKill();
    createParticles(this.x,this.y,'#c0392b',12,5);
    shakeScreen();

    // Hendel retaliation: any enemy that hits Hendel is knocked back and takes 30 damage
    if(this.type==='hendel' && attacker && typeof attacker.hp==='number' && attacker.hp>0){
      const pcx=this.x+this.width/2, pcy=this.y+this.height/2;
      const ecx=attacker.x+attacker.width/2, ecy=attacker.y+attacker.height/2;
      let dx=ecx-pcx, dy=ecy-pcy;
      const len=Math.hypot(dx,dy)||1;
      dx/=len; dy/=len;

      // knockback away from Hendel (a bit of distance)
      const kb=140;
      attacker.x += dx*kb;
      attacker.y += dy*kb;
      attacker.x = Math.max(0, Math.min(canvas.width - attacker.width, attacker.x));
      attacker.y = Math.max(0, Math.min(canvas.height - attacker.height, attacker.y));

      // retaliation damage
      const ret=30;
      attacker.hp -= ret;
      showDamageNumber(attacker.x, attacker.y, ret);
      createParticles(attacker.x+attacker.width/2, attacker.y+attacker.height/2, '#8b5a2b', 10, 4);
      createParticles(attacker.x+attacker.width/2, attacker.y+attacker.height/2, '#9e9e9e', 6, 4);

      // kill handling (if retaliation finishes the enemy)
      if(attacker.hp<=0 && enemies){
        const idx=enemies.indexOf(attacker);
        if(idx!==-1){
          createParticles(attacker.x,attacker.y,'#fff176',28,6);
          dropStellarBonusAtIndexIfNeeded(idx);
          enemies.splice(idx,1);
          applyScore(100*currentLevel);
          addKill();
          if(this._baneSuperOnKill) this._baneSuperOnKill();
        }
      }
    }

    if(this.hp<=0 && gameState==='playing') endGame(false);
  }


  _baneSuperOnKill(){
    // Kept for compatibility: Bane SUPER attack buff is now decided at activation
    // based on current Kill count (see superAttack()).
    return;
  }

  _updateBaneSuperState(now){
    if(this.type!=='bane') return;
    if(this.baneSuperUntil && now >= this.baneSuperUntil){
      this.baneSuperUntil = 0;
      // quando la SUPER finisce (dopo la sua durata), l'attacco base diventa pi√π lento: +75% tempo tra i colpi
      if(this._baseCooldown!=null){
        this.cooldown = this._baseCooldown * 0.95;
      }
      this._preBaneSuperCooldown = undefined;
      this._baneSuperAppliedCooldown = false;
      // restore speed only if SUPER was the active boost (avoid downgrading other buffs)
      const superSpeed = this._baseSpeed * 1.25;
      if(this.speed <= superSpeed + 0.0001){
        this.speed = this._baseSpeed;
      }
      this.baneSuperAttackMult = 1;
    }
  }

  draw(){
    const baseImg = images[this.type];
    const evoImg = (this.evolved && imagesEvo && imagesEvo[this.type]) ? imagesEvo[this.type] : null;
    const activeImg = (evoImg && evoImg.complete) ? evoImg : baseImg;

    if(activeImg && activeImg.complete){
      ctx.save();
      // evolution visual (brief glow + scale)
      const evoT = (this._evoFxUntil && Date.now() < this._evoFxUntil) ? (1 - ((this._evoFxUntil - Date.now())/650)) : 1;
      const evoScale = (this._evoFxUntil && Date.now() < this._evoFxUntil) ? (1 + 0.18*(1-evoT)) : 1;
      const evoAlpha = (this._evoFxUntil && Date.now() < this._evoFxUntil) ? (0.75 + 0.25*Math.sin(Date.now()/45)) : 1;
      ctx.globalAlpha = evoAlpha;
      const cx=this.x+this.width/2, cy=this.y+this.height/2;
      ctx.translate(cx,cy);
      ctx.scale(evoScale,evoScale);
      ctx.translate(-cx,-cy);
      if(!this.facingRight){
        ctx.scale(-1,1);
        ctx.drawImage(activeImg,-this.x-this.width,this.y,this.width,this.height)
      }else ctx.drawImage(activeImg,this.x,this.y,this.width,this.height);
      ctx.restore()
    // Hendel hammer VFX (brown handle near Hendel, orange head far)
    if(this.type==='hendel' && this._hammerSwing){
      const H=this._hammerSwing;
      const now=Date.now();
      const t=Math.max(0, Math.min(1, (now - H.start)/H.duration));

      const angStart = H.baseAng + H.arc/2;
      const angEnd   = H.baseAng - H.arc/2;
      const ang = angStart + (angEnd - angStart) * t;

      const cx=this.x+this.width/2;
      const cy=this.y+this.height/2;

      ctx.save();
      ctx.translate(cx,cy);
      ctx.rotate(ang);

      // handle (brown) ‚Äî closer
      ctx.globalAlpha = 0.55;
      ctx.shadowColor = '#000000'; ctx.shadowBlur = 25; ctx.fillStyle = '#b07a56';
      ctx.shadowColor = '#000000'; ctx.shadowBlur = 25; ctx.strokeStyle = '#000';
      ctx.lineWidth = 6;
      ctx.beginPath();
      ctx.rect(H.handleStart, -H.handleW/2, H.handleLen, H.handleW);
      
ctx.shadowColor = '#000000';
ctx.shadowBlur = 25;

ctx.fill();
      ctx.stroke();

      // head (orange) ‚Äî farther
      ctx.globalAlpha = 0.60;
      ctx.shadowColor = '#000000'; ctx.shadowBlur = 25; ctx.fillStyle = '#ff7f1f';
      ctx.shadowColor = '#000000'; ctx.shadowBlur = 25; ctx.strokeStyle = '#000';
      ctx.lineWidth = 7;
      const hs = H.headSize;
      ctx.beginPath();
      ctx.rect(H.headOffset - hs/2, -hs/2, hs, hs);
      
ctx.shadowColor = '#000000';
ctx.shadowBlur = 25;

ctx.fill();
      ctx.stroke();

      ctx.restore();
    }



    // Kaerith VFX (fan stretto e lungo)
    if(this.type==='kaerith' && this._kaerithFlame){
      const F=this._kaerithFlame;
      const now=Date.now();
      const t=Math.max(0, Math.min(1, (now - F.start)/160)); // fade-in veloce
      const cx=this.x+this.width/2, cy=this.y+this.height/2;
      const a0=F.dir - F.angle/2;
      const a1=F.dir + F.angle/2;

      ctx.save();
      ctx.globalAlpha = 0.16 + 0.26*t;
      ctx.fillStyle='rgba(255,120,0,0.95)';
      ctx.beginPath();
      ctx.moveTo(cx,cy);
      ctx.arc(cx,cy,F.range,a0,a1,false);
      ctx.closePath();
      
ctx.shadowColor = '#000000';
ctx.shadowBlur = 25;

ctx.fill();

      ctx.globalAlpha = 0.10 + 0.18*t;
      ctx.strokeStyle='rgba(255,60,0,0.95)';
      ctx.lineWidth=4;
      ctx.beginPath();
      ctx.arc(cx,cy,F.range,a0,a1,false);
      ctx.stroke();
      ctx.restore();
    }


    } else {
      ctx.fillStyle='#3498db';ctx.fillRect(this.x,this.y,this.width,this.height)
    }

    // StellarBonus glow (luminous transparent, 1s ‚Äì only light aura)
    if(this.stellarGlowUntil && Date.now() < this.stellarGlowUntil){
      const cx=this.x+this.width/2, cy=this.y+this.height/2;
      ctx.save();
      ctx.globalCompositeOperation='lighter';
  ctx.shadowColor = 'rgba(255,255,255,0.9)';
  ctx.shadowBlur = 25;

      ctx.globalAlpha = 0.45;
      ctx.shadowColor = '#000000'; ctx.shadowBlur = 25; ctx.fillStyle = 'rgba(255,255,255,0.6)';
      ctx.beginPath();
      ctx.arc(cx, cy, Math.max(this.width,this.height)*0.65, 0, Math.PI*2);
      
ctx.shadowColor = '#000000';
ctx.shadowBlur = 25;

ctx.fill();
      ctx.restore();
    }


    // Salsy mark indicator
    if(this.salsyMarkUntil && Date.now() < this.salsyMarkUntil){
      ctx.save();
      ctx.font='22px "Press Start 2P", monospace';
      ctx.textAlign='center';
      ctx.fillStyle='#f1c40f';
      ctx.fillText('‚öúÔ∏è', this.x+this.width/2, this.y-10);
      ctx.restore();
    }

    if(this.shieldActive&&!this.shieldBroken){
      ctx.beginPath();ctx.strokeStyle='rgba(127,219,255,0.85)';ctx.lineWidth=6;
      ctx.arc(this.x+this.width/2,this.y+this.height/2,Math.max(this.width,this.height),0,Math.PI*2);ctx.stroke();
      ctx.fillStyle='#000000';ctx.fillRect(this.x,this.y-16,this.width,6);
      ctx.fillStyle='#7fdbff';ctx.fillRect(this.x,this.y-16,this.width*(this.shieldDurability/this.shieldMaxDurability),6)
    }

    if(this.attacking&&!this.isGrappling){
      ctx.save();
      if(this.attackType==='punch'){
        const cx=this.x+this.width/2, cy=this.y+this.height/2;
        const dir=this.facingRight?1:-1;
        const punchX=cx + dir*this.range;

        // Rooney: punch beam 360¬∞ + aimbot visual (ruota verso il bersaglio pi√π vicino)
        if(this.type==='rooney'){
          const shaftW = 18;         // thickness of the shaft
          const fistW  = 34;         // thickness of the fist end
          const fistL  = 34;         // length of the fist end

          // trova bersaglio (preferisci quello bloccato dall'attacco, se valido entro range)
          let tx=null, ty=null;
          const pcxR=cx, pcyR=cy;

          if(this._rooneyAimTarget && this._rooneyAimTarget.hp>0){
            const e=this._rooneyAimTarget;
            const ex=e.x+e.width/2, ey=e.y+e.height/2;
            // punta comunque verso il nemico, anche se fuori range
            tx=ex; ty=ey;
          }
if(tx===null){
            let closestDist=Infinity;
            for(const e of enemies){
              const ex=e.x+e.width/2, ey=e.y+e.height/2;
              const dist=Math.hypot(ex-pcxR, ey-pcyR);
              if(dist<=closestDist){ closestDist=dist; tx=ex; ty=ey; this._rooneyAimTarget=e; }
            }
          }
const ang = (tx!==null) ? Math.atan2(ty-cy, tx-cx) : (this.facingRight?0:Math.PI);

          ctx.save();
          ctx.translate(cx, cy);
          ctx.rotate(ang);

          const punchLen = Math.max(20, this.range);
          ctx.fillStyle='rgba(231,76,60,0.88)'; // red punch

          // shaft
          ctx.beginPath();
          ctx.rect(0, -shaftW/2, Math.max(0, punchLen-fistL), shaftW);

          ctx.shadowColor = '#000000';
          ctx.shadowBlur = 25;
          ctx.fill();

          // fist end (flared)
          const endStart = punchLen - fistL;
          ctx.beginPath();
          ctx.moveTo(endStart, -fistW*0.55);
          ctx.lineTo(punchLen,  -fistW*0.35);
          ctx.lineTo(punchLen,   fistW*0.35);
          ctx.lineTo(endStart,   fistW*0.55);
          ctx.closePath();

          ctx.shadowColor = '#000000';
          ctx.shadowBlur = 25;
          ctx.fill();

          ctx.restore();
        }else{
          // default punch telegraph
          ctx.strokeStyle='rgba(230,126,34,0.7)';
          ctx.lineWidth=8;
          ctx.beginPath();
          ctx.moveTo(cx,cy);
          ctx.lineTo(punchX,cy);
          ctx.stroke();
        }
      }else if(this.attackType==='sword'){
        ctx.strokeStyle='rgba(155,89,182,0.6)';ctx.lineWidth=5;
        const angle=this.facingRight?0:Math.PI;const arcWidth=Math.PI*1.2;
        ctx.beginPath();ctx.arc(this.x+this.width/2,this.y+this.height/2,this.range,angle-arcWidth/2,angle+arcWidth/2);ctx.stroke()
      }else if(this.attackType==='salsySword'){
        // Visual telegraph: Salsy fan slash area
        const angle=this.facingRight?0:Math.PI;const arcWidth=Math.PI*1.35;
        ctx.fillStyle='rgba(241,196,15,0.12)';
        ctx.strokeStyle='rgba(241,196,15,0.75)';
        ctx.lineWidth=6;
        ctx.beginPath();
        ctx.moveTo(this.x+this.width/2,this.y+this.height/2);
        ctx.arc(this.x+this.width/2,this.y+this.height/2,this.range,angle-arcWidth/2,angle+arcWidth/2);
        ctx.closePath();
        
ctx.shadowColor = '#000000';
ctx.shadowBlur = 25;

ctx.fill();
        ctx.stroke();
      }else if(this.attackType==='axeattack'){
        // Visual area: Bane axe swing (270¬∞)
        const angle=this.facingRight?0:Math.PI;const arcWidth=Math.PI*1.5;
        ctx.fillStyle='rgba(231,76,60,0.20)';
        ctx.strokeStyle='rgba(231,76,60,0.85)';
        ctx.lineWidth=7;
        ctx.beginPath();
        ctx.moveTo(this.x+this.width/2,this.y+this.height/2);
        ctx.arc(this.x+this.width/2,this.y+this.height/2,this.range,angle-arcWidth/2,angle+arcWidth/2);
        ctx.closePath();
        
ctx.shadowColor = '#000000';
ctx.shadowBlur = 25;

ctx.fill();
        ctx.stroke();
      }else if(this.attackType==='lucienBlade'){
        // Visual area: Lucien 4-hit close-range blade fan
        const angle=this.facingRight?0:Math.PI;const arcWidth=Math.PI*1.05;
        ctx.fillStyle='rgba(200,230,255,0.13)';
        ctx.strokeStyle='rgba(200,230,255,0.82)';
        ctx.lineWidth=6;
        ctx.beginPath();
        ctx.moveTo(this.x+this.width/2,this.y+this.height/2);
        ctx.arc(this.x+this.width/2,this.y+this.height/2,this.range,angle-arcWidth/2,angle+arcWidth/2);
        ctx.closePath();
        
ctx.shadowColor = '#000000';
ctx.shadowBlur = 25;

ctx.fill();
        ctx.stroke();
      }else if(this.attackType==='hybrid'){
        ctx.strokeStyle='rgba(243,156,18,0.6)';ctx.lineWidth=6;
        ctx.beginPath();
        ctx.arc(this.x+this.width/2,this.y+this.height/2,110,0,Math.PI*2);
        ctx.stroke();
      }
      else if(this.attackType==='tempostormLaser'){
        const sx=this.x+this.width/2, sy=this.y+this.height/2;
        const tx = sx + (this.facingRight?1:-1)*this.range;
        const ty = sy;
        ctx.strokeStyle='rgba(79,195,247,0.75)';ctx.lineWidth=7;
        ctx.beginPath();ctx.moveTo(sx,sy);ctx.lineTo(tx,ty);ctx.stroke();
      }
      ctx.restore()
    }

    if(this.isDoingSuper){
      if(this.attackType==='punch' && this.type!=='rooney'){
        ctx.save();ctx.strokeStyle='rgba(243,156,18,0.45)';ctx.lineWidth=12;ctx.beginPath();
        const arcRadius=350;ctx.arc(this.x+this.width/2,this.y+this.height/2,arcRadius,0,Math.PI*2);ctx.stroke();ctx.restore()
      }
      else if(this.attackType==='sword'){
        ctx.save();ctx.strokeStyle='rgba(155,89,182,0.45)';ctx.lineWidth=10;ctx.beginPath();
        const swordRadius=JEFF_SUPER_RADIUS;ctx.arc(this.x+this.width/2,this.y+this.height/2,swordRadius,0,Math.PI*2);ctx.stroke();ctx.restore()
      }
      else if(this.attackType==='grapple'){
        ctx.save();ctx.strokeStyle='rgba(231,76,60,0.45)';ctx.lineWidth=6;
        this.superTargets.forEach(t=>{ctx.beginPath();ctx.arc(t.x+t.width/2,t.y+t.height/2,40,0,Math.PI*2);ctx.stroke()});
        ctx.restore()
      }
      else if(this.attackType==='hybrid'){
        // aura while super is active
        ctx.save();ctx.strokeStyle='rgba(243,156,18,0.35)';ctx.lineWidth=8;
        ctx.beginPath();ctx.arc(this.x+this.width/2,this.y+this.height/2,140,0,Math.PI*2);ctx.stroke();ctx.restore()
      }
            else if(this.attackType==='tempostormLaser'){
        ctx.save();
        ctx.strokeStyle='rgba(0,176,255,0.45)';
        ctx.lineWidth=10;
        ctx.beginPath();
        ctx.arc(canvas.width/2,(canvas.height-30)/2,180,0,Math.PI*2);
        ctx.stroke();
        ctx.restore();
      }
else if(this.attackType==='salsySword'){
        // Show 1-3 target reticles + launch lines during Salsy super
        ctx.save();
        ctx.strokeStyle='rgba(241,196,15,0.75)';
        ctx.fillStyle='rgba(241,196,15,0.20)';
        ctx.lineWidth=5;
        const px=this.x+this.width/2, py=this.y+this.height/2;
        const list=(this.superTargets||[]).slice(0,3);
        list.forEach((t,i)=>{
          const tx=t.x+t.width/2, ty=t.y+t.height/2;
          // dashed aim line
          ctx.setLineDash([10,6]);
          ctx.beginPath();ctx.moveTo(px,py);ctx.lineTo(tx,ty);ctx.stroke();
          ctx.setLineDash([]);
          // reticle
          ctx.beginPath();ctx.arc(tx,ty,26,0,Math.PI*2);ctx.stroke();
          ctx.beginPath();ctx.arc(tx,ty,10,0,Math.PI*2);
ctx.shadowColor = '#000000';
ctx.shadowBlur = 25;

ctx.fill();ctx.stroke();
        });
        ctx.restore();
      }
    }

    if(this.isGrappling&&this.grappleTarget){
      ctx.strokeStyle='rgba(231,76,60,0.8)';ctx.lineWidth=3;ctx.setLineDash([10,5]);
      ctx.beginPath();ctx.moveTo(this.x+this.width/2,this.y+this.height/2);
      ctx.lineTo(this.grappleTarget.x+this.grappleTarget.width/2,this.grappleTarget.y+this.grappleTarget.height/2);
      ctx.stroke();ctx.setLineDash([])
    }

    if(this.isJetpacking){
      ctx.save();
      ctx.fillStyle='rgba(255,215,0,0.9)';
      ctx.beginPath();
      ctx.ellipse(this.x+this.width/2,this.y+this.height+12,18,8,0,0,Math.PI*2);
      
ctx.shadowColor = '#000000';
ctx.shadowBlur = 25;

ctx.fill();
      ctx.restore();
    }

    // === KOUVAGIA: visualizzazione aree attacco + effetto super ===
    if(this.type==='kouvagia'){
      // Area danno durante dash-attacco
      if(this.isDashing && this._kouvagiaDashActive){
        ctx.save();
        ctx.strokeStyle='rgba(232,67,147,0.55)';
        ctx.lineWidth=6;
        ctx.beginPath();
        ctx.arc(this.x+this.width/2,this.y+this.height/2,110,0,Math.PI*2);
        ctx.stroke();
        ctx.restore();
      }

      // Area esplosione finale (breve telegraph)
      if(this._kouvagiaExplosionPending && this.isDashing){
        ctx.save();
        ctx.strokeStyle='rgba(253,121,168,0.45)';
        ctx.lineWidth=6;
        ctx.beginPath();
        ctx.arc(this.x+this.width/2,this.y+this.height/2,165,0,Math.PI*2);
        ctx.stroke();
        ctx.restore();
      }

      // Effetto super: onda espansiva + flash
      const nowFx=Date.now();
      if(this._kouvagiaSuperFxUntil && nowFx < this._kouvagiaSuperFxUntil){
        const t=(nowFx-(this._kouvagiaSuperFxStart||nowFx)) / (this._kouvagiaSuperFxUntil-(this._kouvagiaSuperFxStart||nowFx)+1);
        const r=60 + t*360;
        ctx.save();
        ctx.strokeStyle='rgba(85,239,196,'+(0.9 - t*0.8)+')';
        ctx.lineWidth=12;
        ctx.beginPath();
        ctx.arc(this.x+this.width/2,this.y+this.height/2,r,0,Math.PI*2);
        ctx.stroke();
        // flash leggero
        ctx.fillStyle='rgba(85,239,196,'+(0.12*(1-t))+')';
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.restore();
      }
    }

  }
}

class Enemy{
  constructor(type,level){
    const cfg=levelConfigs[Math.max(0,Math.min(levelConfigs.length-1,level-1))];
    const mult=1+0.15*level;
    this.type=type;
    if(!window._enemyIdSeq) window._enemyIdSeq = 1;
    this._id = window._enemyIdSeq++;
    this.x=Math.random()*(canvas.width-100)+50;
    this.y=Math.random()*(canvas.height-150)+50;
    this.width=Math.round(56*1.2);
    this.height=Math.round(56*1.2);
    this.vx=(Math.random()-0.5)*cfg.enemySpeed*mult;
    this.vy=(Math.random()-0.5)*cfg.enemySpeed*mult;
    this.maxHP=Math.round(cfg.enemyHP*(1+0.25*level));
    this.hp=this.maxHP;
    const baseDamage=Math.round(cfg.enemyDamage*(1+0.20*level));
    this.damage=(level>=7)?Math.round(baseDamage*0.8):baseDamage;
    this.speed=cfg.enemySpeed*mult;
    if(level===8)this.speed*=0.925;
    // Modalit√† FACILE: nemici pi√π lenti (-10%) e meno danno (-20%)
    if(difficultyMode==='easy'){
      this.vx*=0.90; this.vy*=0.90;
      this.speed*=0.90;
      this.damage=Math.round(this.damage*0.8);
    }
    this.lastAttack=0;this.attackCooldown=2000;this.spawnFreezeUntil=Date.now()+500;
    // Special enemies
    if(this.type==='veleno'){
      this.attackCooldown=1400;
      this.poisonDuration=6000;
      this.poisonTickDamage=2;
    }
    if(this.type==='oneyes'){
      this.attackCooldown=1600;
      this.keepAway=300;
      this.preferRange=520;
    }
    if(this.type==='boss4'){
      this.width=Math.round(240*1.2);
      this.height=Math.round(240*1.2);

      // Override scaling: boss has fixed stats
      this.maxHP=900;
      this.hp=this.maxHP;

      this.damage=30;          // fan damage
      this.ringDamage=20;      // ring damage
      this.speed=4.2;
      this.vx=(Math.random()-0.5)*this.speed;
      this.vy=(Math.random()-0.5)*this.speed;

      this.attackCooldown=1100;
      this.fanRange=260;
      this.fanHalfAngle=Math.PI/2; // 180¬∞ total
      this.swingUntil=0;
      this.swingAngle=0;
          this.ringEvery=2000;
      this.nextRingAt=Date.now()+600;
    }
}
  update(player){
    if(Date.now()<this.spawnFreezeUntil)return;
    // Global stun (e.g., Hendel hammer): freeze AI/movement briefly
    if(this.stunnedUntil && Date.now() < this.stunnedUntil){
      this.vx = 0; this.vy = 0;
      return;
    }
    player = getPreferredTarget(this, player);
    const now=Date.now();

    // COSMO slow (from Marchio Cosmico)
    if(this._cosmoSlowUntil){
      if(now < this._cosmoSlowUntil){
        if(this._cosmoOrigSpeed==null) this._cosmoOrigSpeed = this.speed;
        this.speed = (this._cosmoOrigSpeed||this.speed) * (this._cosmoSlowFactor || 0.55);
      }else{
        if(this._cosmoOrigSpeed!=null) this.speed = this._cosmoOrigSpeed;
        this._cosmoSlowUntil = 0;
      }
    }

    const cx=this.x+this.width/2;
    const cy=this.y+this.height/2;
    const px=player.x+player.width/2;
    const py=player.y+player.height/2;

    let dx=px-cx;
    let dy=py-cy;
    let dist=Math.hypot(dx,dy)||1;

    // Default: chase
    let nx=dx/dist;
    let ny=dy/dist;

    // OneEyes: keep distance + shoot lasers
    if(this.type==='oneyes'){
      // keep away if too close
      if(dist < (this.keepAway||300)){
        nx = -nx; ny = -ny;
      } else if(dist > (this.preferRange||520)){
        // slightly approach if too far
        // nx,ny already towards player
      } else {
        // strafe / small drift
        const t = nx; nx = -ny*0.7; ny = t*0.7;
      }

      this.vx = nx*this.speed;
      this.vy = ny*this.speed;

      // shoot laser (1s duration), with higher cooldown
      if(dist>220 && (now-this.lastAttack)>this.attackCooldown){
        const angle=Math.atan2(dy,dx);
        spawnLaser({
          owner:this,
          x:cx, y:cy,
          angle,
          length:650,
          width:18,
          ttl:1000,
          damage:15,
          kind:'oneyes',
          chargeMs:0
        });
        createParticles(cx,cy,'#74b9ff',16,4);
        this.lastAttack=now;
      }
    }

    // Boss20: fan (180¬∞) + expanding ring that damages and pulls
    else if(this.type==='boss4'){
      // chase
      this.vx = nx*this.speed;
      this.vy = ny*this.speed;


      // ring wave every 2 seconds (independent from attack)
      const bcx=this.x+this.width/2;
      const bcy=this.y+this.height/2;
      if(now >= (this.nextRingAt||0)){
        if(typeof spawnBossRing==='function'){
          spawnBossRing({x:bcx,y:bcy,damage:(this.ringDamage||20),maxR:600,ttl:950,pull:2.2,owner:this});
        }
        this.nextRingAt = now + (this.ringEvery||2000);
      }

      // fan attack
      const cx=this.x+this.width/2;
      const cy=this.y+this.height/2;
      if(dist <= (this.fanRange||260) && (now-this.lastAttack)>this.attackCooldown && !player.isDashing){
        const ang=Math.atan2(dy,dx);
        this.swingAngle=ang;
        this.swingUntil=now+240;

        // cone hit check
        const px=player.x+player.width/2;
        const py=player.y+player.height/2;
        const distP=Math.hypot(px-cx, py-cy);
        if(distP <= (this.fanRange||260)){
          // smallest signed angle diff
          let diff = Math.atan2(Math.sin(ang - Math.atan2(py-cy, px-cx)), Math.cos(ang - Math.atan2(py-cy, px-cx)));
          diff = Math.abs(diff);
          if(diff <= (this.fanHalfAngle||Math.PI/2)){
            player.takeDamage(this.damage, this);
            createParticles(player.x,player.y,'#e17055',16,4);
          }
        }
        shakeScreen();
        this.lastAttack=now;
      }
    }

    // Veleno: melee + non-stack poison

    else {
      this.vx = nx*this.speed;
      this.vy = ny*this.speed;

      // melee attack
      if(dist<60 && (now-this.lastAttack)>this.attackCooldown && !player.isDashing){
        if(this.type==='veleno'){
          player.takeDamage(15, this);
          // apply poison only if not already poisoned (non-stackable)
          if(!player.poisonUntil || now >= player.poisonUntil){
            player.poisonUntil = now + (this.poisonDuration||6000);
            player.poisonTickLast = now;
            player.poisonTickDamage = this.poisonTickDamage||2;
            createParticles(player.x,player.y,'#00b894',26,4);
          } else {
            // hit without re-applying poison
            createParticles(player.x,player.y,'#00b894',10,3);
          }
        } else {
          player.takeDamage(this.damage, this);
        }
        this.lastAttack=now;
      }
    }

    this.x+=this.vx;this.y+=this.vy;
    // boundaries
    if(this.x<0)this.x=0;if(this.x+this.width>canvas.width)this.x=canvas.width-this.width;
    if(this.y<0)this.y=0;if(this.y+this.height>canvas.height-30)this.y=canvas.height-30-this.height;
  }
  draw(){
    const imgKey = (this.type==='boss' || this.type==='boss1') ? 'boss1' : this.type;
    const img = enemyImages[imgKey];
    if(img && img.complete){
      ctx.drawImage(img,this.x,this.y,this.width,this.height);
    } else {
      const colors={slime:'#2ecc71',drone:'#95a5a6',mech:'#e67e22',shadow:'#9b59b6',boss:'#e74c3c',shooter:'#95a5a6',attacker:'#e67e22',boss2:'#e74c3c',boss3:'#e74c3c'};
      ctx.fillStyle=colors[this.type]||'#e74c3c';
      ctx.fillRect(this.x,this.y,this.width,this.height);
        }
    // Boss20 fan visual
    try{
      const now=Date.now();
      if(this.type==='boss4' && this.swingUntil && now < this.swingUntil){
        const cx=this.x+this.width/2;
        const cy=this.y+this.height/2;
        const r=(this.fanRange||260);
        ctx.save();
        ctx.globalAlpha = 0.22;
        ctx.shadowColor = '#000000'; ctx.shadowBlur = 25; ctx.fillStyle = 'rgba(255,255,0,0.9)';
        ctx.beginPath();
        ctx.moveTo(cx,cy);
        ctx.arc(cx,cy,r, (this.swingAngle||0)-(this.fanHalfAngle||Math.PI/2), (this.swingAngle||0)+(this.fanHalfAngle||Math.PI/2));
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }
    }catch(e){}
    const hpPercent=this.hp/this.maxHP;
    ctx.fillStyle='#333';ctx.fillRect(this.x,this.y-10,this.width,5);
    ctx.fillStyle=hpPercent>0.5?'#2ecc71':hpPercent>0.25?'#f39c12':'#e74c3c';
    ctx.fillRect(this.x,this.y-10,this.width*hpPercent,5);
    // MARK INDICATOR: black dot above marked enemies (Salsy mark / Cosmo mark)
    try{
      const now=Date.now();
      const isMarked = (this.salsyMarkUntil && now < this.salsyMarkUntil) || (!!this._cosmoMark);
      if(isMarked){
        ctx.save();
        ctx.shadowColor = '#000000'; ctx.shadowBlur = 25; ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(this.x+this.width/2, this.y-18, 5, 0, Math.PI*2);
        
ctx.shadowColor = '#000000';
ctx.shadowBlur = 25;

ctx.fill();
        ctx.restore();
      }
    }catch(e){}
  }
}

class ShooterEnemy extends Enemy{
  constructor(type,level){super(type,level);this.shootCooldown=Math.max(600,1800-level*40);this.lastShoot=0;this.bulletSpeed=5+level*0.15}
  update(player){
    if(Date.now()<this.spawnFreezeUntil)return;
    if(this.stunnedUntil && Date.now() < this.stunnedUntil){
      this.vx = 0; this.vy = 0;
      return;
    }
    player = getPreferredTarget(this, player);
    const dx=(player.x+player.width/2)-(this.x+this.width/2);
    const dy=(player.y+player.height/2)-(this.y+this.height/2);
    const dist=Math.hypot(dx,dy);
    if(dist<220){const nx=dx/(dist||1);const ny=dy/(dist||1);this.vx=-nx*this.speed;this.vy=-ny*this.speed}
    else if(dist>360){const nx=dx/(dist||1);const ny=dy/(dist||1);this.vx=nx*this.speed;this.vy=ny*this.speed}
    else{this.vx*=0.9;this.vy*=0.9}
    this.x+=this.vx;this.y+=this.vy;
    if(this.x<0)this.x=0;if(this.x+this.width>canvas.width)this.x=canvas.width-this.width;
    if(this.y<0)this.y=0;if(this.y+this.height>canvas.height-30)this.y=canvas.height-30-this.height;
    if(Date.now()-this.lastShoot>this.shootCooldown){
      this.lastShoot=Date.now();
      const len=Math.hypot(dx,dy)||1;
      const vx=(dx/len)*this.bulletSpeed;const vy=(dy/len)*this.bulletSpeed;
      spawnProjectile({
        x:this.x+this.width/2,y:this.y+this.height/2,
        vx,vy,damage:Math.max(1,Math.round(this.damage*0.6)),ttl:4000,
        color:'#ffd54f',radius:6,friendly:false,source:this
      })
    }
  }
  draw(){
    const img = enemyImages['shooter'];
    if(img && img.complete) ctx.drawImage(img,this.x,this.y,this.width,this.height);
    else super.draw();
    const hpPercent=this.hp/this.maxHP;
    ctx.fillStyle='#333';ctx.fillRect(this.x,this.y-10,this.width,5);
    ctx.fillStyle=hpPercent>0.5?'#2ecc71':hpPercent>0.25?'#f39c12':'#e74c3c';
    ctx.fillRect(this.x,this.y-10,this.width*hpPercent,5);

    // MARK INDICATOR: black dot above marked enemies (Salsy mark / Cosmo mark)
    try{
      const now=Date.now();
      const isMarked = (this.salsyMarkUntil && now < this.salsyMarkUntil) || (!!this._cosmoMark);
      if(isMarked){
        ctx.save();
        ctx.shadowColor = '#000000'; ctx.shadowBlur = 25; ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(this.x+this.width/2, this.y-18, 5, 0, Math.PI*2);
        
ctx.shadowColor = '#000000';
ctx.shadowBlur = 25;

ctx.fill();
        ctx.restore();
      }
    }catch(e){}  }
}


class ArcherEnemy extends Enemy{
  constructor(type,level){
    super(type,level);
    this.shootCooldown=Math.max(650, 1250 - level*18);
    this.lastShoot=0;
    this.arrowSpeed=9.2 + level*0.20;
    this.keepMin=520; // very far
    this.keepMax=700;
  }
  update(player){
    if(Date.now()<this.spawnFreezeUntil)return;
    if(this.stunnedUntil && Date.now() < this.stunnedUntil){
      this.vx = 0; this.vy = 0;
      return;
    }
    player = getPreferredTarget(this, player);
    const now=Date.now();
    const dx=(player.x+player.width/2)-(this.x+this.width/2);
    const dy=(player.y+player.height/2)-(this.y+this.height/2);
    const dist=Math.hypot(dx,dy)||1;

    // Keep far distance
    if(dist < this.keepMin){
      const nx=dx/dist, ny=dy/dist;
      this.vx = -nx*this.speed*1.05;
      this.vy = -ny*this.speed*1.05;
    } else if(dist > this.keepMax){
      const nx=dx/dist, ny=dy/dist;
      this.vx = nx*this.speed*0.95;
      this.vy = ny*this.speed*0.95;
    } else {
      this.vx*=0.90; this.vy*=0.90;
    }

    this.x+=this.vx; this.y+=this.vy;
    if(this.x<0)this.x=0;if(this.x+this.width>canvas.width)this.x=canvas.width-this.width;
    if(this.y<0)this.y=0;if(this.y+this.height>canvas.height-30)this.y=canvas.height-30-this.height;

    if(now-this.lastShoot>this.shootCooldown){
      this.lastShoot=now;
      const nx=dx/dist, ny=dy/dist;
      const vx=nx*this.arrowSpeed;
      const vy=ny*this.arrowSpeed;
      spawnProjectile({
        x:this.x+this.width/2,
        y:this.y+this.height/2,
        vx, vy,
        friendly:false,
        source:this,
        damage:Math.max(8, Math.round(this.damage*0.85)),
        ttl:3200,
        color:'#e0e0e0',
        radius:4,
        shape:'rect',
        w:18,
        h:4,
        angle:Math.atan2(vy,vx),
        onHitPlayer:(pl)=>{ if(pl && typeof pl.applySlow==='function') pl.applySlow(0.20, 2500); }
      });
    }
  }
  draw(){
    const img = enemyImages['archer'];
    if(img && img.complete) ctx.drawImage(img,this.x,this.y,this.width,this.height);
    else super.draw();
    const hpPercent=this.hp/this.maxHP;
    ctx.fillStyle='#333';ctx.fillRect(this.x,this.y-10,this.width,5);
    ctx.fillStyle=hpPercent>0.5?'#2ecc71':hpPercent>0.25?'#f39c12':'#e74c3c';
    ctx.fillRect(this.x,this.y-10,this.width*hpPercent,5);

    // MARK INDICATOR: black dot above marked enemies (Salsy mark / Cosmo mark)
    try{
      const now=Date.now();
      const isMarked = (this.salsyMarkUntil && now < this.salsyMarkUntil) || (!!this._cosmoMark);
      if(isMarked){
        ctx.save();
        ctx.shadowColor = '#000000'; ctx.shadowBlur = 25; ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(this.x+this.width/2, this.y-18, 5, 0, Math.PI*2);
        
ctx.shadowColor = '#000000';
ctx.shadowBlur = 25;

ctx.fill();
        ctx.restore();
      }
    }catch(e){}  }
}

class GlacialEnemy extends Enemy{
  constructor(type,level){
    super(type,level);
    this.attackCooldown=Math.max(2100, 3400 - level*35);
    this.lastAttack=0;
    this.coneDuration=2000;
    this.coneRange=430;
    this.coneAngle=Math.PI/6; // 30¬∞ total
    this.coneActiveUntil=0;
    this.coneDir=0;
    this._coneInsideMs=0;
    this._coneLastCheck=0;
    this._coneLastTick=0;
    this._lastRegenAt=0;
    this.keepMin=280;
    this.keepMax=440;
  }
  update(player){
    if(Date.now()<this.spawnFreezeUntil)return;
    if(this.stunnedUntil && Date.now() < this.stunnedUntil){
      this.vx = 0; this.vy = 0;
      return;
    }
    player = getPreferredTarget(this, player);
    const now=Date.now();

    // Regen: if not hit for 5s, heal 15 (can repeat every 5s)
    const lastHit=this._lastHitAt||0;
    if(now-lastHit>=5000 && now-(this._lastRegenAt||0)>=5000 && this.hp<this.maxHP){
      this.hp=Math.min(this.maxHP, this.hp+15);
      this._lastRegenAt=now;
      createParticles(this.x+this.width/2,this.y+this.height/2,'#74b9ff',12,4);
    }

    const dx=(player.x+player.width/2)-(this.x+this.width/2);
    const dy=(player.y+player.height/2)-(this.y+this.height/2);
    const dist=Math.hypot(dx,dy)||1;

    // Keep mid distance
    if(dist < this.keepMin){
      const nx=dx/dist, ny=dy/dist;
      this.vx = -nx*this.speed*1.08;
      this.vy = -ny*this.speed*1.08;
    } else if(dist > this.keepMax){
      const nx=dx/dist, ny=dy/dist;
      this.vx = nx*this.speed*0.92;
      this.vy = ny*this.speed*0.92;
    } else {
      this.vx*=0.92; this.vy*=0.92;
    }

    this.x+=this.vx; this.y+=this.vy;
    if(this.x<0)this.x=0;if(this.x+this.width>canvas.width)this.x=canvas.width-this.width;
    if(this.y<0)this.y=0;if(this.y+this.height>canvas.height-30)this.y=canvas.height-30-this.height;

    // Start cone attack
    if(now-this.lastAttack>this.attackCooldown){
      this.lastAttack=now;
      this.coneActiveUntil=now+this.coneDuration;
      this.coneDir=Math.atan2(dy,dx);
      this._coneInsideMs=0;
      this._coneLastCheck=now;
      this._coneLastTick=0;
    }

    // Cone damage while active
    if(this.coneActiveUntil && now < this.coneActiveUntil){
      const dt = now - (this._coneLastCheck || now);
      this._coneLastCheck = now;

      // check player inside cone
      const px=player.x+player.width/2, py=player.y+player.height/2;
      const ex=this.x+this.width/2, ey=this.y+this.height/2;
      const vx=px-ex, vy=py-ey;
      const pdist=Math.hypot(vx,vy)||1;
      const ang=Math.atan2(vy,vx);
      let diff=Math.abs(ang-this.coneDir);
      if(diff>Math.PI) diff=2*Math.PI-diff;

      const inside = (pdist<=this.coneRange) && (diff <= (this.coneAngle/2));

      if(inside){
        this._coneInsideMs += dt;
        // damage ticks every 250ms, increasing while inside
        if(!this._coneLastTick) this._coneLastTick = now;
        if(now - this._coneLastTick >= 250){
          this._coneLastTick = now;
          const insideSec = this._coneInsideMs/1000;
          const base = Math.max(3, Math.round(this.damage*0.20));
          const ramp = Math.round(insideSec * 2.2); // gradual increase
          const dmg = Math.min(22, base + ramp);
          player.takeDamage(dmg, this);
          createParticles(player.x,player.y,'#b2bec3',8,3);
        }
      } else {
        this._coneInsideMs = 0;
      }
    }
  }
  draw(){
    const img = enemyImages['glacial'];
    if(img && img.complete) ctx.drawImage(img,this.x,this.y,this.width*1.5,this.height*1.5);
    else super.draw();

    // Cone visual
    const now=Date.now();
    if(this.coneActiveUntil && now < this.coneActiveUntil){
      const cx=this.x+this.width/2, cy=this.y+this.height/2;
      const a0=this.coneDir - this.coneAngle/2;
      const a1=this.coneDir + this.coneAngle/2;
      ctx.save();
      ctx.globalAlpha=0.28;
      ctx.fillStyle='rgba(180,220,255,0.9)';
      ctx.beginPath();
      ctx.moveTo(cx,cy);
      ctx.arc(cx,cy,this.coneRange,a0,a1,false);
      ctx.closePath();
      
ctx.shadowColor = '#000000';
ctx.shadowBlur = 25;

ctx.fill();
      ctx.globalAlpha=0.12;
      ctx.strokeStyle='rgba(180,220,255,0.9)';
      ctx.lineWidth=4;
      ctx.beginPath();
      ctx.moveTo(cx,cy);
      ctx.arc(cx,cy,this.coneRange,a0,a1,false);
      ctx.closePath();
      ctx.stroke();
      ctx.restore();
    }

    const hpPercent=this.hp/this.maxHP;
    ctx.fillStyle='#333';ctx.fillRect(this.x,this.y-10,this.width,5);
    ctx.fillStyle=hpPercent>0.5?'#2ecc71':hpPercent>0.25?'#f39c12':'#e74c3c';
    ctx.fillRect(this.x,this.y-10,this.width*hpPercent,5);

    // MARK INDICATOR: black dot above marked enemies (Salsy mark / Cosmo mark)
    try{
      const now=Date.now();
      const isMarked = (this.salsyMarkUntil && now < this.salsyMarkUntil) || (!!this._cosmoMark);
      if(isMarked){
        ctx.save();
        ctx.shadowColor = '#000000'; ctx.shadowBlur = 25; ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(this.x+this.width/2, this.y-18, 5, 0, Math.PI*2);
        
ctx.shadowColor = '#000000';
ctx.shadowBlur = 25;

ctx.fill();
        ctx.restore();
      }
    }catch(e){}  }
}


class AttackReturnEnemy extends Enemy{
  constructor(type,level){super(type,level);this.homeX=this.x;this.homeY=this.y;this.state='idle';this.attackRange=60;this.attackCooldown=2200;this.lastAttackTime=0;this.attackSpeed=this.speed*2.5}
  update(player){
    if(Date.now()<this.spawnFreezeUntil)return;
    if(this.stunnedUntil && Date.now() < this.stunnedUntil){
      this.vx = 0; this.vy = 0;
      return;
    }
    player = getPreferredTarget(this, player);
    const dx=(player.x+player.width/2)-(this.x+this.width/2);
    const dy=(player.y+player.height/2)-(this.y+this.height/2);
    const distToPlayer=Math.hypot(dx,dy);
    if(this.state==='idle'){
      const wanderX=Math.sin(Date.now()/1000+this.homeX)*0.3;const wanderY=Math.cos(Date.now()/1000+this.homeY)*0.3;
      this.vx=wanderX*this.speed;this.vy=wanderY*this.speed;
      if(distToPlayer<220&&Date.now()-this.lastAttackTime>this.attackCooldown)this.state='attack'
    }
    else if(this.state==='attack'){
      const nx=dx/(distToPlayer||1);const ny=dy/(distToPlayer||1);
      this.vx=nx*this.attackSpeed;this.vy=ny*this.attackSpeed;
      if(distToPlayer<this.attackRange){player.takeDamage(this.damage, this);this.lastAttackTime=Date.now();this.state='returning'}
    }
    else if(this.state==='returning'){
      const hx=this.homeX-this.x;const hy=this.homeY-this.y;const distHome=Math.hypot(hx,hy);
      if(distHome>6){
        const nx=hx/(distHome||1);const ny=hy/(distHome||1);
        this.vx=nx*this.speed;this.vy=ny*this.speed
      }else{this.vx=0;this.vy=0;this.state='idle'}
    }
    this.x+=this.vx;this.y+=this.vy;
    if(this.x<0)this.x=0;if(this.x+this.width>canvas.width)this.x=canvas.width-this.width;
    if(this.y<0)this.y=0;if(this.y+this.height>canvas.height-30)this.y=canvas.height-30-this.height;
  }
  draw(){
    const img = enemyImages['attacker'];
    if(img && img.complete) ctx.drawImage(img,this.x,this.y,this.width,this.height);
    else super.draw();
    const hpPercent=this.hp/this.maxHP;
    ctx.fillStyle='#333';ctx.fillRect(this.x,this.y-10,this.width,5);
    ctx.fillStyle=hpPercent>0.5?'#2ecc71':hpPercent>0.25?'#f39c12':'#e74c3c';
    ctx.fillRect(this.x,this.y-10,this.width*hpPercent,5);

    // MARK INDICATOR: black dot above marked enemies (Salsy mark / Cosmo mark)
    try{
      const now=Date.now();
      const isMarked = (this.salsyMarkUntil && now < this.salsyMarkUntil) || (!!this._cosmoMark);
      if(isMarked){
        ctx.save();
        ctx.shadowColor = '#000000'; ctx.shadowBlur = 25; ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(this.x+this.width/2, this.y-18, 5, 0, Math.PI*2);
        
ctx.shadowColor = '#000000';
ctx.shadowBlur = 25;

ctx.fill();
        ctx.restore();
      }
    }catch(e){}  }
}

class BossEnemy extends Enemy{
  constructor(type,level){
    super(type,level);
    this.phase=0;
    this.superCooldown=12000;
    this.lastSuper=0;
    this.superActive=false;
    this.superStart=0;
    this.superDuration=3000;
    this.bulletTimer=0;
    this.attackCooldown=1800;
    this.lastAttack=0;
    this.width=Math.round(200*1.2);
    this.height=Math.round(200*1.2);
  }
  update(player){
    if(Date.now()<this.spawnFreezeUntil)return;
    if(this.stunnedUntil && Date.now() < this.stunnedUntil){
      this.vx = 0; this.vy = 0;
      return;
    }
    player = getPreferredTarget(this, player);
    const cx=this.x+this.width/2, cy=this.y+this.height/2;
    const px=player.x+player.width/2, py=player.y+player.height/2;
    const dx=px-cx; const dy=py-cy; const dist=Math.hypot(dx,dy);
    const attackRange=60;
    const hitRange = attackRange + Math.max(this.width,this.height)*0.35;
    // Range effettivo: include dimensioni del nemico per evitare "zone sicure" ai bordi (clamp)
    if(dist>attackRange){
      const nx=dx/(dist||1);const ny=dy/(dist||1);
      this.vx=nx*this.speed;this.vy=ny*this.speed;
    } else {

      this.vx*=0.9;this.vy*=0.9;
            if(Date.now()-this.lastAttack>this.attackCooldown&&!player.isDashing){
        // Se siamo clamped contro un bordo, potremmo non arrivare mai a dist<=attackRange puro.
        // Usiamo hitRange per consentire il colpo quando siamo realisticamente "a contatto".
        if( (aabbDist2(this.x,this.y,this.width,this.height, player.x,player.y,player.width,player.height) <= hitRange*hitRange) ){
          player.takeDamage(this.damage, this);
          this.lastAttack=Date.now();
        }
      }
    }
    this.x+=this.vx;this.y+=this.vy;
    if(this.x<0)this.x=0;if(this.x+this.width>canvas.width)this.x=canvas.width-this.width;
    if(this.y<0)this.y=0;if(this.y+this.height>canvas.height-30)this.y=canvas.height-30-this.height;
    if(Date.now()-this.lastSuper>this.superCooldown){
      this.lastSuper=Date.now();this.superActive=true;this.superStart=Date.now()
    }
    if(this.superActive&&Date.now()-this.superStart>this.superDuration)this.superActive=false;
  }
  draw(){
    const key = (this.type==='boss' || this.type==='boss1') ? 'boss1' : (this.type==='boss2' ? 'boss2' : (this.type==='boss3' ? 'boss3' : this.type));
    const img = enemyImages[key];
    if(img && img.complete) ctx.drawImage(img,this.x,this.y,this.width,this.height);
    else super.draw();
    const hpPercent=this.hp/this.maxHP;
    ctx.fillStyle='#333';ctx.fillRect(this.x,this.y-10,this.width,5);
    ctx.fillStyle=hpPercent>0.5?'#2ecc71':hpPercent>0.25?'#f39c12':'#e74c3c';
    ctx.fillRect(this.x,this.y-10,this.width*hpPercent,5);

    // MARK INDICATOR: black dot above marked enemies (Salsy mark / Cosmo mark)
    try{
      const now=Date.now();
      const isMarked = (this.salsyMarkUntil && now < this.salsyMarkUntil) || (!!this._cosmoMark);
      if(isMarked){
        ctx.save();
        ctx.shadowColor = '#000000'; ctx.shadowBlur = 25; ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(this.x+this.width/2, this.y-18, 5, 0, Math.PI*2);
        
ctx.shadowColor = '#000000';
ctx.shadowBlur = 25;

ctx.fill();
        ctx.restore();
      }
    }catch(e){}  }
}
class Boss5Enemy extends Enemy{
  constructor(type,level){
    super(type,level);

    // Dimensioni boss
    this.width=Math.round(245*1.2);
    this.height=Math.round(245*1.2);

    // Stat fisse richieste
    this.maxHP=800;
    this.hp=800;

    // "Non troppo veloce"
    this.speed=2.99*0.75; // ~1.69 (leggermente pi√π veloce)

    // Danno base (usato solo per eventuale contatto)
    this.damage=50;

    // --- Attacco: colpo ad ascia a ventaglio 80¬∞ (sweep sinistra->destra) ---
    this.fanRange=470;                 // raggio del ventaglio
    this.fanAngleDeg=142;               // ampiezza ventaglio
    this.swingDuration=1000;           // sweep lento (ms)
    this.swingCooldown=1000;           // cooldown un po' pi√π corto
    this.lastSwing=Date.now()-1800;    // piccolo offset
    this.swingActive=false;
    this.swingStart=0;
    this.swingCenterAngle=0;
    this.swingStartAngle=0;
    this.swingEndAngle=0;
    this.lastSwingTick=0;

    // --- Passiva: ogni 28s respinge + cura 50 ---
    this.passiveInterval=20000;
    this.nextPassive=Date.now()+this.passiveInterval;
    this.passiveFxUntil=0;

    // Area della passiva/super (raggio)
    this.passiveRadius=750; // aumentata
  }

  startSwingTowards(player){
    const cx=this.x+this.width/2, cy=this.y+this.height/2;
    const px=player.x+player.width/2, py=player.y+player.height/2;
    const baseAng=Math.atan2(py-cy, px-cx);

    const half=(this.fanAngleDeg*Math.PI/180)/2;
    this.swingCenterAngle=baseAng;
    // parte dall'estremit√† sinistra del ventaglio e arriva a destra
    this.swingStartAngle=baseAng-half;
    this.swingEndAngle=baseAng+half;

    this.swingActive=true;
    this.swingStart=Date.now();
    this.lastSwingTick=0;

    // piccolo telegraph: particelle
    createParticles(cx,cy,'#e74c3c',26,6);
  }

  doPassive(player){
    const now=Date.now();
    this.nextPassive = now + this.passiveInterval;

    // FX visivo
    const cx=this.x+this.width/2, cy=this.y+this.height/2;
    this.passiveFxUntil = now + 650;
    createParticles(cx,cy,'#00e5ff',55,8);
    shakeScreen();

    // Cura boss
    this.hp = Math.min(this.maxHP, this.hp + 80);

    // Effetto sul player SOLO se dentro l'area della super/passiva
    const px=player.x+player.width/2, py=player.y+player.height/2;
    const dx=px-cx, dy=py-cy;
    const dist=Math.hypot(dx,dy)||1;

    if(dist <= (this.passiveRadius||420)){
      // Knockback player (senza danno)
      const nx=dx/dist, ny=dy/dist;
      const pushDist=240; // "tanti pixel"
      player.x += nx*pushDist;
      player.y += ny*pushDist;

      // Slow: -50% velocit√† per 2s
      if(player && typeof player.applySlow==='function'){
        player.applySlow(0.60, 3200);
      }

      // clamp in arena
      player.x=Math.max(0, Math.min(canvas.width-player.width, player.x));
      player.y=Math.max(0, Math.min(canvas.height-player.height, player.y));
    }
  }

  applySwingDamage(player, now){
    // tick damage durante lo sweep, senza colpire mentre il player √® in dash
    if(player.isDashing) return;
    if(player.invulnerableUntil && Date.now() < player.invulnerableUntil) return;
    if(player.invincibleUntil && Date.now() < player.invincibleUntil) return;
    if(this.lastSwingTick && (now-this.lastSwingTick)<240) return;

    const cx=this.x+this.width/2, cy=this.y+this.height/2;
    const px=player.x+player.width/2, py=player.y+player.height/2;
    const dx=px-cx, dy=py-cy;
    const dist=Math.hypot(dx,dy);

    if(dist>this.fanRange) return;

    // angolo player
    const ang=Math.atan2(dy,dx);

    // calcola dove siamo nello sweep
    const t=Math.max(0, Math.min(1, (now-this.swingStart)/this.swingDuration));
    const cur=this.swingStartAngle + (this.swingEndAngle-this.swingStartAngle)*t;

    // Controllo robusto "dentro l'arco coperto" (direzione: swingStartAngle -> cur, CCW con wrap)
    const TAU = Math.PI*2;
    const to0 = (a)=>((a%TAU)+TAU)%TAU;
    const a0 = to0(ang);
    const s0 = to0(this.swingStartAngle);
    const c0 = to0(cur);

    let inside=false;
    if(s0<=c0){
      inside = (a0>=s0 && a0<=c0);
    } else {
      // wrap-around
      inside = (a0>=s0 || a0<=c0);
    }


    if(inside){
      this.lastSwingTick=now;
      player.takeDamage(18, this);
    }
  }

  update(player){
    if(Date.now()<this.spawnFreezeUntil)return;
    if(this.stunnedUntil && Date.now() < this.stunnedUntil){
      this.vx = 0; this.vy = 0;
      return;
    }
    player = getPreferredTarget(this, player);

    const now=Date.now();
    const cx=this.x+this.width/2, cy=this.y+this.height/2;
    const px=player.x+player.width/2, py=player.y+player.height/2;
    const dx=px-cx, dy=py-cy;
    const dist=Math.hypot(dx,dy)||1;

    // Passiva (ogni 28s)
    if(now>=this.nextPassive){
      this.doPassive(player);
    }

    // Movimento: inseguimento leggero, ma non troppo aggressivo durante lo swing
    if(!this.swingActive){
      const nx=dx/dist, ny=dy/dist;
      const prefer=210; // distanza "comoda"
      if(dist>prefer){
        this.vx=nx*this.speed;
        this.vy=ny*this.speed;
      }else{
        // drift lento per non essere statico
        this.vx*=0.92;
        this.vy*=0.92;
      }
    }else{
      // durante lo swing resta pi√π "fermo"
      this.vx*=0.85;
      this.vy*=0.85;
    }

    this.x+=this.vx; this.y+=this.vy;

    // clamp arena
    this.x=Math.max(20, Math.min(canvas.width-this.width-20, this.x));
    this.y=Math.max(40, Math.min(canvas.height-this.height-20, this.y));

    // Avvia swing se pronto e player in range
    if(!this.swingActive && dist<=this.fanRange && (now-this.lastSwing)>=this.swingCooldown){
      this.lastSwing=now;
      this.startSwingTowards(player);
    }

    // gestione swing attivo
    if(this.swingActive){
      this.applySwingDamage(player, now);
      if(now-this.swingStart>=this.swingDuration){
        this.swingActive=false;
      }
    }

    // contatto ravvicinato (solo se non in dash) - leggero
    const hitRangeTouch = 55 + Math.max(this.width,this.height)*0.25;
    if( (aabbDist2(this.x,this.y,this.width,this.height, player.x,player.y,player.width,player.height) <= hitRangeTouch*hitRangeTouch) && !player.isDashing && !this.swingActive){
      if(!this._lastTouch) this._lastTouch=0;
      if(now-this._lastTouch>900){
        player.takeDamage(14, this);
        this._lastTouch=now;
      }
    }
  }

  draw(){
    const img = enemyImages.boss5;
    if(img && img.complete) ctx.drawImage(img,this.x,this.y,this.width,this.height);
    else super.draw();

    // HP bar
    const hpPercent=this.hp/this.maxHP;
    ctx.fillStyle='#333';ctx.fillRect(this.x,this.y-10,this.width,5);
    ctx.fillStyle=hpPercent>0.5?'#2ecc71':hpPercent>0.25?'#f39c12':'#e74c3c';
    ctx.fillRect(this.x,this.y-10,this.width*hpPercent,5);

    // MARK INDICATOR: black dot above marked enemies (Salsy mark / Cosmo mark)
    try{
      const now=Date.now();
      const isMarked = (this.salsyMarkUntil && now < this.salsyMarkUntil) || (!!this._cosmoMark);
      if(isMarked){
        ctx.save();
        ctx.shadowColor = '#000000'; ctx.shadowBlur = 25; ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(this.x+this.width/2, this.y-18, 5, 0, Math.PI*2);
        
ctx.shadowColor = '#000000';
ctx.shadowBlur = 25;

ctx.fill();
        ctx.restore();
      }
    }catch(e){}
    const now=Date.now();
    const cx=this.x+this.width/2, cy=this.y+this.height/2;

    // FX passiva
    if(now<this.passiveFxUntil){
      ctx.save();
      ctx.globalAlpha=0.45;
      ctx.lineWidth=6;
      ctx.strokeStyle='rgba(0,229,255,0.85)';
      ctx.beginPath();
      ctx.arc(cx,cy, (this.passiveRadius||this.width*0.75), 0, Math.PI*2);
      ctx.stroke();
      ctx.restore();
    }

    // Disegna il ventaglio durante lo swing (telegraph)
    if(this.swingActive){
      const t=Math.max(0, Math.min(1, (now-this.swingStart)/this.swingDuration));
      const cur=this.swingStartAngle + (this.swingEndAngle-this.swingStartAngle)*t;

      ctx.save();
      ctx.globalAlpha=0.18;
      ctx.fillStyle='#e74c3c';
      ctx.beginPath();
      ctx.moveTo(cx,cy);
      ctx.arc(cx,cy, this.fanRange, this.swingStartAngle, cur, false);
      ctx.closePath();
      
ctx.shadowColor = '#000000';
ctx.shadowBlur = 25;

ctx.fill();

      ctx.globalAlpha=0.65;
      ctx.lineWidth=4;
      ctx.strokeStyle='rgba(231,76,60,0.9)';
      ctx.beginPath();
      ctx.arc(cx,cy, this.fanRange, this.swingStartAngle, this.swingEndAngle, false);
      ctx.stroke();
      ctx.restore();
    }
  }
}


function spawnEnemiesForLevel(level){
  enemies.length=0;
  const lvl = Math.max(1, Math.min(level, levelConfigs.length));
  const cfg=levelConfigs[lvl-1];
  // Bestiario: segna il tipo di nemico/boss come gi√† sfidato (sblocco globale)
  markEnemySeen(cfg.enemyType);

  const count=cfg.enemyCount;
  for(let i=0;i<count;i++){
    let e;
    if(cfg.enemyType==='shooter') e=new ShooterEnemy(cfg.enemyType,lvl);
    else if(cfg.enemyType==='attacker') e=new AttackReturnEnemy(cfg.enemyType,lvl);
    else if(cfg.enemyType==='archer') e=new ArcherEnemy(cfg.enemyType,lvl);
    else if(cfg.enemyType==='glacial') e=new GlacialEnemy(cfg.enemyType,lvl);
    else if(cfg.enemyType==='boss1' || cfg.enemyType==='boss2' || cfg.enemyType==='boss3') e=new BossEnemy(cfg.enemyType,lvl);
    else if(cfg.enemyType==='boss5') e=new Boss5Enemy(cfg.enemyType,lvl);
    else e=new Enemy(cfg.enemyType,lvl);
    enemies.push(e);
  }
  spawnPickupsForLevel(lvl);
}

function updateBackgroundForLevel(level){
  // Levels 1-6: default bg, Levels 7-15: dark bg, Levels 16-20: final bg, Levels 21+: ice bg
  let tier=0;
  if(level>=21) tier=3;
  else if(level>=16) tier=2;
  else if(level>=7) tier=1;

  const applyTier=()=>{
    if(tier===3){
      bgDark.style.backgroundImage=`url('${URL_ICE}')`;
      bgDefault.style.opacity='0';
      bgDark.style.opacity='1';
    }
    else if(tier===2){
      bgDark.style.backgroundImage=`url('${URL_FINAL}')`;
      bgDefault.style.opacity='0';
      bgDark.style.opacity='1';
    } else if(tier===1){
      bgDark.style.backgroundImage=`url('${URL_DARK}')`;
      bgDefault.style.opacity='0';
      bgDark.style.opacity='1';
    } else {
      bgDefault.style.opacity='1';
      bgDark.style.opacity='0';
    }
    _bgTier=tier;
  };

  // Dissolvenza: quando si entra nella "fase finale" (dal 15 -> 16) o cambia tier
  if(fadeOverlay && tier!==_bgTier){
    fadeOverlay.style.opacity='1';
    setTimeout(()=>{
      applyTier();
      setTimeout(()=>{ fadeOverlay.style.opacity='0'; }, 80);
    }, 380);
  } else {
    applyTier();
  }
}

function startGame(){
  const etherUI = document.getElementById('etherHud');
  if(etherUI) etherUI.style.display='none';

  currentLevel=1;score=0;kills=0;matchKills=0;matchHealMissionCount=0;timer=levelConfigs[0].time;
  runUsedSuper=false; runTookDamage=false;
  player=new Player(selectedCharacter||'jimmy');
  enemies=[];particles=[];projectiles=[];lasers=[];tempBeams=[];pickups=[];wolves=[];
  spawnEnemiesForLevel(currentLevel);
  updateBackgroundForLevel(currentLevel);
  document.getElementById('mainMenu').style.display='none';
  const ss=document.getElementById('startScreen');
  if(ss) ss.style.display='none';
  document.getElementById('uiOverlay').style.display='block';
  document.getElementById('scoreDisplay').style.display='block';
  document.getElementById('killsDisplay').style.display='block';
  const tw=document.getElementById('timerWrap'); if(tw) tw.style.display='flex';
  document.getElementById('timerDisplay').style.display='block';
  document.getElementById('levelDisplay').style.display='block';
  document.getElementById('superCooldown').style.display='block';
  gameState='playing';
}

function endGame(won){
  const etherUI = document.getElementById('etherHud');
  if(etherUI) etherUI.style.display='flex';

  if(gameState!=='playing') return;
  gameState='ended';
  document.getElementById('endScreen').style.display='block';
  const kd=document.getElementById('killsDisplay'); if(kd) kd.style.display='none';
  document.getElementById('endTitle').textContent=won?'VICTORY':'GAME OVER';
  document.getElementById('endMessage').textContent=`Score Finale: ${score}`;
  document.getElementById('endSub').textContent=`Hai raggiunto il Livello ${currentLevel}`;
  
  // XP battaglia: livello raggiunto * 2 (assegnato quando si torna al menu / si riprova)
  pendingBattleXp = Math.max(0, Math.floor((currentLevel||0) * 2));
  const xpEl = document.getElementById('endXpEarned');
  if(xpEl) xpEl.textContent = `XP Ottenuti: ${pendingBattleXp}`;
const rec=records[selectedCharacter]||0;
  if(score>rec){records[selectedCharacter]=score;saveRecords(); try{ syncMissionsFromStats(); saveAccount(); }catch(e){} }
  document.getElementById('recordMessage').textContent=`Record Personaggio: ${records[selectedCharacter]||0}`;
}

function nextLevel(){

// Easy mode sustain: after clearing a level, heal between levels
const clearedLevel = currentLevel;
if(difficultyMode==='easy' && player){
  const healAmt = (clearedLevel % 5 === 0) ? (player.maxHP) : (player.maxHP * 0.25);
  const _beforeHp = player.hp;
  player.hp = Math.min(player.maxHP, (clearedLevel % 5 === 0) ? player.maxHP : (player.hp + healAmt));
  try{ accountOnHeal(player.hp - _beforeHp); }catch(e){}

}
  if(currentLevel < levelConfigs.length){
    currentLevel++;

// Missioni legate ai livelli (check quando avanzi)
try{
  for(const m of accountState.missions){
    if(m.claimed) continue;
    if(m.type==='reachLevel'){
      const tgt = m.levelTarget||20;
      if(currentLevel > tgt) m.progress = m.target;
    }
    if(m.type==='noSuperToLevel'){
      const tgt = m.levelTarget||15;
      if(currentLevel > tgt && !runUsedSuper) m.progress = m.target;
    }
    if(m.type==='noDamageToLevel'){
      const tgt = m.levelTarget||15;
      if(currentLevel > tgt && !runTookDamage) m.progress = m.target;
    }
  }
  saveAccount();
}catch(e){}

    // missione: supera il livello 10 (quando entri nel livello 11 o oltre)
    try{
      for(const m of accountState.missions){
        if(m.claimed) continue;
        if(m.type==='bossLevel' && (m.levelTarget||10)===10){
          if(currentLevel > 10){
            m.progress = m.target; // completed
          }
        }
      }
      saveAccount();
    }catch(e){}
    spawnEnemiesForLevel(currentLevel);
    timer=levelConfigs[Math.max(0,currentLevel-1)].time;
    updateBackgroundForLevel(currentLevel);
  } else {
    endGame(true);
  }
}


function drawKaerithFireOverlay(now){
  if(!player || player.type!=='kaerith' || !player._kaerithFireUntil || now>=player._kaerithFireUntil) return;

  // overlay fiamme: flicker + embers
  const t = 1 - Math.max(0, Math.min(1, (player._kaerithFireUntil - now)/9000));
  ctx.save();
  ctx.globalAlpha = 0.18 + 0.10*Math.sin(now/70);
  ctx.shadowColor = '#000000'; ctx.shadowBlur = 25; ctx.fillStyle = '#ff3d00';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // ‚Äúlingue‚Äù di fuoco stilizzate (righe verticali random)
  ctx.globalAlpha = 0.10 + 0.06*Math.sin(now/55);
  for(let i=0;i<22;i++){
    const x = (Math.random()*canvas.width)|0;
    const h = 120 + Math.random()*260;
    const w = 14 + Math.random()*26;
    const y = canvas.height - h;
    ctx.fillRect(x,y,w,h);
  }

  // embers
  ctx.globalAlpha = 0.22;
  ctx.shadowColor = '#000000'; ctx.shadowBlur = 25; ctx.fillStyle = '#ffd180';
  for(let i=0;i<28;i++){
    const x = (Math.random()*canvas.width)|0;
    const y = (Math.random()*canvas.height)|0;
    ctx.fillRect(x,y,2,2);
  }
  ctx.restore();
}


/* ===== VISUAL FX: Rooney Area (zona quadrata) + Cosmo Shot (hitscan) ===== */
window.rooneyAreaFX = window.rooneyAreaFX || [];
function addRooneyAreaFX(cx, cy, half){
  try{
    const now=Date.now();
    // pre-generate some crack segments for a stable look
    const cracks=[];
    for(let i=0;i<10;i++){
      const x1 = cx + (Math.random()*2-1)*half*0.95;
      const y1 = cy + (Math.random()*2-1)*half*0.95;
      const x2 = cx + (Math.random()*2-1)*half*0.95;
      const y2 = cy + (Math.random()*2-1)*half*0.95;
      cracks.push([x1,y1,x2,y2, 0.35+Math.random()*0.65]);
    }
    window.rooneyAreaFX.push({cx,cy,half,start:now,ttl:650,cracks});
  }catch(e){}
}
function drawRooneyAreaFX(now){
  const arr = window.rooneyAreaFX;
  if(!arr || !arr.length) return;
  now = now || Date.now();
  for(let i=arr.length-1;i>=0;i--){
    const fx=arr[i];
    const t = (now - fx.start) / (fx.ttl||650);
    if(t>=1){ arr.splice(i,1); continue; }

    const easeIn = Math.min(1, t/0.18);
    const easeOut = 1 - Math.max(0, (t-0.65)/0.35);
    const a = Math.max(0, Math.min(1, easeIn*easeOut));

    const pulse = 0.5 + 0.5*Math.sin((now-fx.start)/70);
    const pad = (1-a)*18;
    const left = fx.cx - fx.half - pad;
    const top  = fx.cy - fx.half - pad;
    const size = fx.half*2 + pad*2;

    ctx.save();
    ctx.globalAlpha = 0.28*a;
    ctx.shadowColor = '#000000'; ctx.shadowBlur = 25; ctx.fillStyle = 'rgba(255,40,40,0.30)';
    ctx.fillRect(left, top, size, size);

    ctx.globalAlpha = (0.85*a);
    ctx.lineWidth = 6 + 3*pulse;
    ctx.shadowColor = 'rgba(255,0,0,0.65)';
    ctx.shadowBlur = 22;
    ctx.shadowColor = '#000000'; ctx.shadowBlur = 25; ctx.strokeStyle = 'rgba(255,60,60,0.95)';
    ctx.setLineDash([10, 8]);
    ctx.strokeRect(left, top, size, size);
    // inner glow
    ctx.globalAlpha = 0.45*a;
    ctx.setLineDash([]);
    ctx.lineWidth = 3 + 2*pulse;
    ctx.shadowColor = '#000000'; ctx.shadowBlur = 25; ctx.strokeStyle = 'rgba(255,0,0,0.55)';
    ctx.strokeRect(left+10, top+10, size-20, size-20);
    ctx.setLineDash([]);

    // inner "cracks"
    ctx.globalAlpha = 0.55*a;
    ctx.lineWidth = 1.8;
    ctx.shadowColor = '#000000'; ctx.shadowBlur = 25; ctx.strokeStyle = 'rgba(40,0,0,0.9)';
    for(const seg of (fx.cracks||[])){
      ctx.globalAlpha = 0.45*a*seg[4];
      ctx.beginPath();
      ctx.moveTo(seg[0], seg[1]);
      ctx.lineTo(seg[2], seg[3]);
      ctx.stroke();
    }

    // dust ring
    ctx.globalAlpha = 0.18*a;
    ctx.shadowColor = '#000000'; ctx.shadowBlur = 25; ctx.strokeStyle = 'rgba(255,120,120,0.85)';
    ctx.lineWidth = 2;
    ctx.strokeRect(left+6, top+6, size-12, size-12);

    ctx.restore();
  }
}

window.cosmoShots = window.cosmoShots || [];
function addCosmoShot(x1,y1,x2,y2){
  try{
    window.cosmoShots.push({x1,y1,x2,y2,start:Date.now(),ttl:140});
  }catch(e){}
}
function drawCosmoShots(now){
  const arr = window.cosmoShots;
  if(!arr || !arr.length) return;
  now = now || Date.now();
  for(let i=arr.length-1;i>=0;i--){
    const s=arr[i];
    const t=(now-s.start)/(s.ttl||140);
    if(t>=1){ arr.splice(i,1); continue; }
    const a = Math.max(0, 1-t);
    const wob = Math.sin((now-s.start)/26)*2.2;

    ctx.save();
    ctx.globalAlpha = 0.85*a;
    ctx.lineCap='round';

    // outer glow
    ctx.strokeStyle='rgba(139,211,255,0.65)';
    ctx.lineWidth = 10 + wob;
    ctx.beginPath();
    ctx.moveTo(s.x1,s.y1);
    ctx.lineTo(s.x2,s.y2);
    ctx.stroke();

    // core
    ctx.globalAlpha = 0.95*a;
    ctx.strokeStyle='rgba(255,255,255,0.92)';
    ctx.lineWidth = 3.2;
    ctx.beginPath();
    ctx.moveTo(s.x1,s.y1);
    ctx.lineTo(s.x2,s.y2);
    ctx.stroke();

    // endpoint spark
    ctx.globalAlpha = 0.65*a;
    ctx.fillStyle='rgba(255,255,255,0.95)';
    ctx.beginPath();
    ctx.arc(s.x2, s.y2, 5 + 2*Math.sin((now-s.start)/18), 0, Math.PI*2);
    
ctx.shadowColor = '#000000';
ctx.shadowBlur = 25;

ctx.fill();

    ctx.restore();
  }
}


/* ===== COSMO SYSTEMS: Marchio Cosmico + Singolarit√† ===== */
window.cosmoSingularity = null;

function _cosmoRecalcDmgMult(){
  if(!player || player.type!=='cosmo') return;
  const now=Date.now();
  if(!player._cosmoStacks) player._cosmoStacks = [];
  // drop expired
  player._cosmoStacks = player._cosmoStacks.filter(t=>t>now);
  const stacks = Math.max(0, Math.min(3, player._cosmoStacks.length));
  player._cosmoDmgMult = 1 + 0.05*stacks;
}

function cosmoOnMarkExplode(){
  if(!player || player.type!=='cosmo') return;
  const now=Date.now();
  // +5% dmg for 2s (stack max 3)
  if(!player._cosmoStacks) player._cosmoStacks = [];
  player._cosmoStacks.push(now+2000);
  while(player._cosmoStacks.length>3) player._cosmoStacks.shift();
  _cosmoRecalcDmgMult();

  // small super cooldown refund: subtract 4% from lastSuper timestamp
  try{
    const refund = Math.round((player.superCooldown||24000) * 0.04);
    player.lastSuper -= refund;
  }catch(e){}
}

function updateCosmoMarks(now){
  now = now || Date.now();
  for(const e of enemies){
    const m = e._cosmoMark;
    if(!m) continue;

    if(m.triggerNow || now >= (m.explodeAt||0)){
      const isMini = !!m.mini;
      const burst = !!m.triggerNow;
      const baseExpl = isMini ? 26 : 58;
      const dmg = baseExpl * (burst ? 1.6 : 1.0) * (player && player.type==='cosmo' ? (player.attackBuffMultiplier||1) * (player._cosmoDmgMult||1) : 1);
      const dealt = applyEnemyDamage(e, dmg);
      createParticles(e.x+e.width/2, e.y+e.height/2, '#000000', isMini?16:28, 6);
      showDamageNumber(e.x, e.y, dealt);

      // slow
      e._cosmoSlowFactor = 0.55;
      e._cosmoSlowUntil = now + (burst ? 1200 : 600);

      // chain: apply a mini-mark to nearby enemies (no infinite)
      if(!isMini){
        for(const other of enemies){
          if(other===e) continue;
          const dx=(other.x+other.width/2)-(e.x+e.width/2);
          const dy=(other.y+other.height/2)-(e.y+e.height/2);
          const dist=Math.hypot(dx,dy);
          if(dist<=180 && !other._cosmoMark){
            other._cosmoMark = { applied: now, explodeAt: now+650, mini:true };
          }
        }
      }

      // passive trigger
      cosmoOnMarkExplode();

      // clear
      e._cosmoMark = null;
    }
  }
}

function spawnCosmoSingularity(px, py, dirX, dirY){
  const len=Math.hypot(dirX,dirY)||1;
  const ax=dirX/len, ay=dirY/len;
  const sp=1.8;
  window.cosmoSingularity = {
    active:true,
    born:Date.now(),
    until:Date.now()+7000,
    x:px, y:py,
    vx:ax*sp, vy:ay*sp,
    speed:sp,
    r:34,
    pullR:Math.hypot(canvas.width, canvas.height)+40,
    dps:7,
    lastTick:Date.now(),
    absorbed:0,
    absorbedSet:{}
  };
}

function updateCosmoSingularity(now){
  const orb = window.cosmoSingularity;
  if(!orb || !orb.active) return;

  // move
  orb.x += orb.vx;
  orb.y += orb.vy;

  // bounce off walls
  if(orb.x < orb.r){ orb.x = orb.r; orb.vx = Math.abs(orb.vx); }
  if(orb.x > canvas.width-orb.r){ orb.x = canvas.width-orb.r; orb.vx = -Math.abs(orb.vx); }
  if(orb.y < orb.r){ orb.y = orb.r; orb.vy = Math.abs(orb.vy); }
  if(orb.y > canvas.height-orb.r){ orb.y = canvas.height-orb.r; orb.vy = -Math.abs(orb.vy); }

  // pull + damage tick
  const now2 = now || Date.now();
  for(const e of enemies){
    const ex=e.x+e.width/2, ey=e.y+e.height/2;
    const dx=orb.x-ex, dy=orb.y-ey;
    const dist=Math.hypot(dx,dy);

    // Strong global attraction: field reaches the whole arena.
    // (Set dynamically in case canvas size changes.)
    orb.pullR = Math.hypot(canvas.width, canvas.height) + 40;
    if(dist<=orb.pullR){
      const t = Math.max(0, 1 - dist/orb.pullR);
      // Always-on pull even at long range, with aggressive ramp-up near the center.
      // Enemies can still move, but the drag + ramp makes the center eventually win.
      let pull = 0.12 + Math.pow(t, 1.32) * 3.2;
      if (pull > 3.7) pull = 3.7;
      e.x += (dx/(dist||1))*pull;
      e.y += (dy/(dist||1))*pull;
      // drag inside the field (simulated resistance)
      if(e.vx!=null){ e.vx *= 0.975; e.vy *= 0.975; }
// absorbed count (once per enemy)
      if(dist <= orb.r+40 && !orb.absorbedSet[e._id]){
        orb.absorbedSet[e._id] = true;
        orb.absorbed += 1;
      }

      // DoT every ~220ms
      if(!orb.lastTick) orb.lastTick = now2;
      if(now2 - orb.lastTick >= 220){
        orb.lastTick = now2;
        const dealt=applyEnemyDamage(e, orb.dps);
        if(dealt>0) showDamageNumber(e.x,e.y,dealt);
      }
    }
  }

  // end -> explosion
  if(now2 >= orb.until){
    const base = 110;
    const bonus = Math.min(420, orb.absorbed * 35);
    const aoe = 260;
    for(let i=enemies.length-1;i>=0;i--){
      const e=enemies[i];
      const ex=e.x+e.width/2, ey=e.y+e.height/2;
      const d=Math.hypot(ex-orb.x, ey-orb.y);
      if(d<=aoe){
        const dealt=applyEnemyDamage(e, base+bonus*(1-d/aoe));
        createParticles(ex,ey,'#000000',28,7);
        showDamageNumber(e.x,e.y,dealt);
      }
    }
    createParticles(orb.x,orb.y,'#b8e6ff',90,8);
    shakeAmount = Math.max(shakeAmount, 12);
    orb.active=false;
  }
}

function drawCosmoSingularity(){
  const orb = window.cosmoSingularity;
  if(!orb || !orb.active) return;
  const now = Date.now();
  const pulse = 0.5 + 0.5*Math.sin(now/120);

  ctx.save();
  ctx.globalAlpha = 0.95;

  // central black sphere with "black luminous" pulsating glow
  const glow = 14 + 18*pulse;
  ctx.shadowColor = 'rgba(0,0,0,0.92)';
  ctx.shadowBlur = glow;

  // subtle dark aura (still only central sphere visible ‚Äî no big circumference)
  const grad = ctx.createRadialGradient(orb.x, orb.y, Math.max(2, orb.r*0.25), orb.x, orb.y, orb.r + 18);
  grad.addColorStop(0, 'rgba(0,0,0,0.95)');
  grad.addColorStop(0.6, 'rgba(0,0,0,0.75)');
  grad.addColorStop(1, 'rgba(0,0,0,0)');

  ctx.shadowColor = '#000000'; ctx.shadowBlur = 25; ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.arc(orb.x, orb.y, orb.r + 4*pulse, 0, Math.PI*2);
  
ctx.shadowColor = '#000000';
ctx.shadowBlur = 25;

ctx.fill();

  // solid core
  ctx.shadowBlur = 0;
  ctx.shadowColor = '#000000'; ctx.shadowBlur = 25; ctx.fillStyle = 'rgba(0,0,0,1)';
  ctx.beginPath();
  ctx.arc(orb.x, orb.y, Math.max(6, orb.r - 6 + 2*pulse), 0, Math.PI*2);
  
ctx.shadowColor = '#000000';
ctx.shadowBlur = 25;

ctx.fill();

  ctx.restore();
}

function updateCosmoTrails(now){
  if(!window.cosmoTrails || !window.cosmoTrails.length) return;
  now = now || Date.now();
  for(let i=window.cosmoTrails.length-1;i>=0;i--){
    const t=window.cosmoTrails[i];
    if(now>=t.until){ window.cosmoTrails.splice(i,1); continue; }
    if(now - (t.lastTick||0) >= 120){
      t.lastTick = now;
      for(const e of enemies){
        const ex=e.x+e.width/2, ey=e.y+e.height/2;
        const d=Math.hypot(ex-t.x, ey-t.y);
        if(d<=90){
          const dealt=applyEnemyDamage(e, 4);
          if(dealt>0) showDamageNumber(e.x,e.y,dealt);
        }
      }
    }
  }
}
function drawCosmoTrails(){
  if(!window.cosmoTrails || !window.cosmoTrails.length) return;
  const now=Date.now();
  ctx.save();
  for(const t of window.cosmoTrails){
    const a = Math.max(0, (t.until-now)/500);
    ctx.globalAlpha = 0.35*a;
    ctx.shadowColor = '#000000'; ctx.shadowBlur = 25; ctx.fillStyle = 'rgba(184,230,255,0.85)';
    ctx.beginPath();
    ctx.arc(t.x, t.y, 55, 0, Math.PI*2);
    
ctx.shadowColor = '#000000';
ctx.shadowBlur = 25;

ctx.fill();
  }
  ctx.restore();
}
function gameLoop(){
  requestAnimationFrame(gameLoop);
  if(gameState!=='playing')return;
  const now=Date.now();

  if(now-lastSecondTick>1000){
    lastSecondTick=now;
    timer--;
    if(timer<=0){
      timer=0;
      endGame(false);
return;
    }
  }

  if(player) player.update();
    updateHendelCrush();
  enemies.forEach(e=>{e.update(player)});
  updateCosmoMarks(now);
  updateCosmoSingularity(now);
  updateCosmoTrails(now);
  updateWolves();
  // Marz Super zone tick damage/expansion
  updateMagicZone(now);
  updatePdorOrbs(now);
  updateParticles();
  updateIraFX();
  updateProjectiles();
  updateLasers();
  updateTempBeams();
  updateFuriaWaves();
  updateBossRings(now);
  if(player) updatePickups(player);

  for(let i=enemies.length-1;i>=0;i--){
    if(enemies[i].hp<=0){
      dropStellarBonusAtIndexIfNeeded(i);
      const dead=enemies.splice(i,1)[0];
      applyScore(100*currentLevel);
      addKill(); createParticles(dead.x,dead.y,'#fff176',30,6);
    }
  }

  if(enemies.length===0){
    if(!levelAdvanceLock){
      levelAdvanceLock=true;

      // Evolution trigger: after defeating Boss at Level 15 (boss3), only Jimmy/Rooney/Jeff evolve permanently from Level 16 onward
      const canEvolve = player && (player.type==='jimmy' || player.type==='rooney' || player.type==='jeff');
      if(gameState==='playing' && currentLevel===15 && canEvolve && !player.evolved){
        triggerEvolutionThenNextLevel(player.type);
      } else {
        setTimeout(()=>{
          if(gameState==='playing') nextLevel();
          levelAdvanceLock=false;
        }, 200);
      }
    }
  }

  ctx.clearRect(0,0,canvas.width,canvas.height);
  if(shakeAmount>0){
    const sx=(Math.random()-0.5)*shakeAmount;const sy=(Math.random()-0.5)*shakeAmount;
    ctx.save();ctx.translate(sx,sy);shakeAmount*=0.9
  } else ctx.save();

    drawKaerithFireOverlay(now);

  // draw Marz Super zone behind entities
  drawMagicZone(now);
  drawPdorOrbs(now);
  drawCosmoSingularity();
  drawCosmoTrails();
  drawRooneyAreaFX(now);
  enemies.forEach(e=>e.draw());
  drawBossRings(now);
  drawWolves();
  if(player) player.draw();
  drawCosmoShots(now);
  drawProjectiles();
  drawLasers();
  drawTempBeams();
  drawFuriaWaves();
  drawIraFX();
  drawParticles();
  drawHendelCrush();
    drawPickups();

  ctx.restore();

  // IRA screen tint flash
  if(iraScreenFlash>0){
    ctx.save();
    ctx.globalAlpha = Math.min(0.35, iraScreenFlash/40);
    ctx.shadowColor = '#000000'; ctx.shadowBlur = 25; ctx.fillStyle = '#7a0019';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.restore();
  }

  if(player){
    document.getElementById('hpText').textContent=Math.max(0,Math.round(player.hp));
    document.getElementById('hpFill').style.width=Math.max(0,Math.round((player.hp/player.maxHP)*100))+'%';
  } else {
    document.getElementById('hpText').textContent='0';
    document.getElementById('hpFill').style.width='0%';
  }

  document.getElementById('scoreDisplay').textContent=`Score: ${score}`;
  const kEl=document.getElementById('killsDisplay'); if(kEl) kEl.textContent=`Kill: ${kills}`;
  document.getElementById('timerDisplay').textContent=timer;
  document.getElementById('levelDisplay').textContent=`Level ${currentLevel}`;
  const superReady=(Date.now()-player.lastSuper>=player.superCooldown)?'Ready':Math.ceil((player.superCooldown-(Date.now()-player.lastSuper))/1000)+'s';
  document.getElementById('superCooldown').textContent=`Super: ${superReady}`;

// ===== BONUS TIMER HUD (dentro interfaccia di gioco) =====
const bonusBox=document.getElementById('bonusTimers');
if(bonusBox){
  const nowT=Date.now();
  const rows=[];

  const add=(label,until,color)=>{
    if(until && until>nowT){
      const t=Math.ceil((until-nowT)/1000);
      rows.push('<span style="color:'+color+'">'+label+': '+t+'s</span>');
    }
  };

  add('SCUDO', player.pickupShieldUntil, '#7fdfff');   // azzurro chiaro
  add('SPEED', player.speedBuffUntil, '#3498db');      // blu
  add('<span class="ira-glow">IRA</span>', player.baneSuperUntil, '#ff9800'); // arancione (Bane)
  add('FURIA', player.furiaHealUntil, '#ff00ff');      // fucsia
  add('ATK', player.attackBuffUntil, '#ff3b3b');       // rosso
  add('POISON', player.poisonUntil, '#4b0082');        // viola scuro

  if(rows.length){
    bonusBox.style.display='block';
    bonusBox.innerHTML=rows.join('<br>');
  }else{
    bonusBox.style.display='none';
    bonusBox.innerHTML='';
  }
}
// ===============================================
  if(player.attackBuffUntil) document.getElementById('atkBuffDisplay').textContent=Math.max(0,Math.ceil((player.attackBuffUntil-Date.now())/1000))+'s';
  else document.getElementById('atkBuffDisplay').textContent='0s';
}


function showEvoBanner(name){
  const el=document.getElementById('evoBanner');
  const txt=document.getElementById('evoBannerText');
  if(!el||!txt) return;
  txt.textContent = `${name.toUpperCase()} EVOLUTO!`;
  el.classList.remove('show');
  // force reflow to restart animation
  void el.offsetWidth;
  el.style.display='block';
  el.classList.add('show');
  setTimeout(()=>{ el.classList.remove('show'); el.style.display='none'; }, 980);
}

function triggerEvolutionThenNextLevel(charType){
  if(!player) return;
  // evolve + FX
  player.evolve();
  showEvoBanner(player.type);
  createParticles(player.x+player.width/2, player.y+player.height/2, '#fff176', 50, 6);
  shakeScreen();

  // delay a bit so the player sees the evolution, then go to next level
  setTimeout(()=>{
    if(gameState==='playing') nextLevel();
    levelAdvanceLock=false;
  }, 620);
}

window.addEventListener('keydown',e=>{
  if(e.repeat) return; // evita conteggi multipli per pressione prolungata
  const k=e.key.toLowerCase();
  keys[k]=true;
  if(k==='j'&&gameState==='playing'){ if(player && player.type!=='kaerith'){ player.attack(); } }
  if(k==='k'&&gameState==='playing'){
    const ok = player && player.superAttack && player.superAttack();
    if(ok){ try{ accountOnSuperUsed(); }catch(e){} }
  }
  if(k===' '&&gameState==='playing'){player.dodge()}
});
window.addEventListener('keyup',e=>{keys[e.key.toLowerCase()]=false;});

document.querySelectorAll('.character-card').forEach(card=>{
  card.addEventListener('click',()=>{
    const char=card.getAttribute('data-char');
    if(char==='tempostorm' && !allPrevAbove85k()){
      updateTempostormUnlockUI();
      return;
    }
    if(char==='voltryx' && !allThreeAbove50k()){
      // keep disabled
      updateVoltryxUnlockUI();
      return;
    }
    if(char==='kouvagia' && !voltryxAbove51k()){
      updateKouvagiaUnlockUI();
      return;
    }
    if(char==='salsy' && !allPrevAbove70k()){
      updateSalsyUnlockUI();
      return;
    }
    if(char==='marz' && !allPrevAboveMarz80k()){
      updateMarzUnlockUI();
      return;
    }
    if(char==='hecate' && !allPrevAboveHecate85k()){
      updateHecateUnlockUI();
      return;
    }
    if(char==='lucien' && !lucienUnlocked()){
      updateLucienUnlockUI();
      return;
    }
    if(char==='pdor' && !pdorUnlocked()){
      updatePdorUnlockUI();
      // show lock message popup
      const lockBox=document.getElementById('lockMessage');
      const lockText=document.getElementById('lockText');
      if(lockBox && lockText){
        lockText.innerText = "Personaggio BLOCCATO\nsi sblocca facendo 50.000\ncon marcus e lucien";
        lockBox.style.display='block';
      }
      return;
    }

    if(char==='bane' && !baneUnlocked()){
      updateBaneUnlockUI();
      // show lock message popup
      const lockBox=document.getElementById('lockMessage');
      const lockText=document.getElementById('lockText');
      if(lockBox && lockText){
        lockText.innerText = "Personaggio BLOCCATO\nSblocca facendo 50.000\ncon PDOR";
        lockBox.style.display='block';
      }
      
    if(char==='hendel' && !hendelUnlocked()){
      updateHendelUnlockUI();
      // show lock message popup
      const lockBox=document.getElementById('lockMessage');
      const lockText=document.getElementById('lockText');
      if(lockBox && lockText){
        lockText.innerText = "personaggio BLOCCATO  si sblocca facendo 50.000 con Bane";
        lockBox.style.display='block';
      }
      return;
    }

    // COSMO purchase unlock (1000 Ether)
    if(char==='cosmo' && !isCharPurchased('cosmo')){
      // Cosmo is purchasable with Ether fragments (no generic "Personaggio BLOCCATO" popup)
      showCosmoShopModal();
      return;
    }
          };
      

torAll('.character-card').forEach(c=>c.classList.remove('selected'));
    card.classList.add('selected');
    selectedCharacter=char;
    updateMenuStatsDisplay(selectedCharacter);
  });
});

function updateMenuStatsDisplay(char){
  const s=characterStats[char];
  if(!s)return;
  if(char==='cosmo'){
    document.getElementById(`menu-hp-${char}`).textContent=s.hp;
    document.getElementById(`menu-dmg-${char}`).textContent='Marchio + Supernova';
    return;
  }
  document.getElementById(`menu-hp-${char}`).textContent=s.hp;
  document.getElementById(`menu-dmg-${char}`).textContent=
    char==='voltryx' ? `${Math.round(34*SUPER_DAMAGE_MULT)} (ranged AoE), ${50}x2 (melee)` :
    (char==='salsy' ? '33x2' :
     (char==='tempostorm' ? '40 (+30 se resta nel laser)' : (char==='marz' ? '40 / 50 / 60' : (char==='hecate' ? 'Freccia: colpo forte + 3 frecce' : (char==='lucien' ? '15x4' : (char==='pdor' ? 'Dardo: 50 (chain x5)' : (char==='bane' ? '‚Äî' : s.damage)))))));

}

/* === Start screen: choose difficulty mode === */
(function(){
  const startScreen=document.getElementById('startScreen');
  const mainMenu=document.getElementById('mainMenu');
  const hardBtn=document.getElementById('modeHardBtn');
  const easyBtn=document.getElementById('modeEasyBtn');
  if(startScreen && mainMenu){
    // default view
    startScreen.style.display='block';
    mainMenu.style.display='none';
    if(menuTopLeft) menuTopLeft.style.display='none';
    if(menuTopLeft) menuTopLeft.setAttribute('aria-hidden','true');
    gameState='start';
  }
  function goToMenu(mode){
    setDifficulty(mode);
    if(startScreen) startScreen.style.display='none';
    if(mainMenu) mainMenu.style.display='block';
    if(menuTopLeft) menuTopLeft.style.display='flex';
    if(menuTopLeft) menuTopLeft.setAttribute('aria-hidden','false');
    gameState='menu';
    updateMenuRecordsDisplay();
    try{ applyBronzeCharBorders(); }catch(e){}
  }
  if(hardBtn) hardBtn.addEventListener('click', ()=>goToMenu('hard'));
  if(easyBtn) easyBtn.addEventListener('click', ()=>goToMenu('easy'));
  window.goToMenu = goToMenu;
})();

// ===== MAIN MENU: back to difficulty + settings modal =====
(function(){
  const startScreen = document.getElementById('startScreen');
  const mainMenu = document.getElementById('mainMenu');
  const menuTopLeft = document.getElementById('menuTopLeft');

  const backBtn = document.getElementById('menuBackBtn');
  const setBtn  = document.getElementById('menuSettingsBtn');

  const modal   = document.getElementById('menuSettingsModal');
  const closeBtn= document.getElementById('menuSettingsCloseBtn');

  if(backBtn){
    backBtn.addEventListener('click', ()=>{
      // close small popups if open
      try{
        const lockBox=document.getElementById('lockMessage');
        if(lockBox) lockBox.style.display='none';
      }catch(e){}
      try{
        const cosmo=document.getElementById('cosmoShopModal');
        if(cosmo) cosmo.style.display='none';
      }catch(e){}
      if(mainMenu) mainMenu.style.display='none';
      if(menuTopLeft) menuTopLeft.style.display='none';
      if(menuTopLeft) menuTopLeft.setAttribute('aria-hidden','true');
      if(startScreen) startScreen.style.display='block';
      if(typeof gameState !== 'undefined') gameState='start';
    });
  }

  function showSettings(){
    if(!modal) return;
    modal.style.display='flex';
    modal.classList.add('show');
    modal.setAttribute('aria-hidden','false');
    if(closeBtn) closeBtn.focus();
  }
  function hideSettings(){
    if(!modal) return;
    modal.style.display='none';
    modal.classList.remove('show');
    modal.setAttribute('aria-hidden','true');
    if(setBtn) setBtn.focus();
  }

  if(setBtn) setBtn.addEventListener('click', (e)=>{ e.preventDefault(); showSettings(); });
  if(closeBtn) closeBtn.addEventListener('click', (e)=>{ e.preventDefault(); hideSettings(); });
  if(modal) modal.addEventListener('click', (e)=>{ if(e.target === modal) hideSettings(); });

  document.addEventListener('keydown', (e)=>{
    if(e.key === 'Escape' && modal && modal.style.display === 'flex'){
      hideSettings();
    }
  });
})();



document.getElementById('startBtn').addEventListener('click',()=>{
  const menuTopLeft = document.getElementById('menuTopLeft');
  if(menuTopLeft){ menuTopLeft.style.display='none'; menuTopLeft.setAttribute('aria-hidden','true'); }
  if(!selectedCharacter)selectedCharacter='jimmy';
  updateMenuRecordsDisplay();
  startGame();
});

const extraCharsBtn=document.getElementById('extraCharsBtn');
const extraCharacterSelect=document.getElementById('extraCharacterSelect');
if(extraCharsBtn && extraCharacterSelect){
  extraCharsBtn.addEventListener('click', ()=>{
    const isOpen = extraCharacterSelect.style.display !== 'none';
    extraCharacterSelect.style.display = isOpen ? 'none' : 'block';
  });
}


document.getElementById('restartBtn').addEventListener('click',()=>{
  // assegna XP della battaglia prima di riprovare
  if(pendingBattleXp>0){
    try{ showXpFloat(`+${pendingBattleXp} XP`); }catch(e){}
    try{ applyAccountXp(pendingBattleXp); }catch(e){}
    pendingBattleXp=0;
  }
  document.getElementById('endScreen').style.display='none';
  startGame();
});
document.getElementById('menuBtn').addEventListener('click',()=>{
  const kd=document.getElementById('killsDisplay'); if(kd) kd.style.display='none';

  // chiudi end screen subito (ma resta la fly anim sopra)
  document.getElementById('endScreen').style.display='none';
  document.getElementById('mainMenu').style.display='block';
  gameState='menu';
  updateMenuRecordsDisplay();

  const xpGain = pendingBattleXp||0;
  if(xpGain>0){
    flyXpToAccountBtn(xpGain, ()=>{
      try{ applyAccountXp(xpGain); }catch(e){}
      pendingBattleXp=0;
    });
  }
});

function populateMenuStatsAll(){
  updateMenuStatsDisplay('jimmy');
  updateMenuStatsDisplay('rooney');
  updateMenuStatsDisplay('jeff');
  updateMenuStatsDisplay('voltryx');
  updateMenuStatsDisplay('kouvagia');
  updateMenuStatsDisplay('salsy');
  updateMenuStatsDisplay('tempostorm');
  updateMenuStatsDisplay('marz');
  updateMenuStatsDisplay('hecate');
  updateMenuStatsDisplay('marcus');
  updateMenuStatsDisplay('lucien');
  updateMenuStatsDisplay('pdor');
  updateMenuStatsDisplay('bane');
  updateMenuStatsDisplay('hendel');
}
populateMenuStatsAll();
updateMenuRecordsDisplay();
updateVoltryxUnlockUI();

gameLoop();
// --- Guida: apertura/chiusura e gestione stato di gioco ---
(function(){
  const guideImgBtn = document.getElementById('guideImgBtn');
  const guideModal = document.getElementById('guideModal');
  const guideClose = document.getElementById('guideClose');
  if(!guideImgBtn || !guideModal || !guideClose) return;
  let gameStateBeforeGuide = undefined;
  function showGuide(){
    guideModal.style.display = 'flex';
  updateGuideUnlockUI();
    guideModal.setAttribute('aria-hidden','false');
    if(typeof gameState !== 'undefined') gameStateBeforeGuide = gameState;
    gameState = 'menu';
    guideClose.focus();
    window._guideOpen = true;
  }
  function hideGuide(){
    guideModal.style.display = 'none';
    guideModal.setAttribute('aria-hidden','true');
    if(typeof gameStateBeforeGuide !== 'undefined') gameState = gameStateBeforeGuide;
    guideImgBtn.focus();
    window._guideOpen = false;
  }
  guideImgBtn.addEventListener('click', function(e){ e.preventDefault(); showGuide(); });
  guideClose.addEventListener('click', function(e){ e.preventDefault(); hideGuide(); });
  guideModal.addEventListener('click', function(e){ if(e.target === guideModal) hideGuide(); });
  document.addEventListener('keydown', function(e){
    if(e.key === 'Escape' && guideModal.style.display === 'flex') hideGuide();
  });
  const guideImg = document.getElementById('guideImg');
  if(guideImg) guideImg.addEventListener('dragstart', function(ev){ ev.preventDefault(); });
})();

// --- Bestiario: apertura/chiusura e gestione stato di gioco ---
(function(){
  const btn = document.getElementById('enemyGuideImgBtn');
  const modal = document.getElementById('enemyGuideModal');
  const close = document.getElementById('enemyGuideClose');
  if(!btn || !modal || !close) return;

  let gameStateBefore = undefined;

  function show(){
    // aggiorna sbloccati e costruisci UI
    try{ enemySeen = loadEnemySeen(); }catch(e){}
    buildEnemyGuideUI();

    modal.style.display='flex';
    modal.setAttribute('aria-hidden','false');
    if(typeof gameState !== 'undefined') gameStateBefore = gameState;
    gameState='menu';
    close.focus();
    window._enemyGuideOpen = true;
  }
  function hide(){
    modal.style.display='none';
    modal.setAttribute('aria-hidden','true');
    if(typeof gameStateBefore !== 'undefined') gameState = gameStateBefore;
    btn.focus();
    window._enemyGuideOpen = false;
  }

  btn.addEventListener('click', function(e){ e.preventDefault(); show(); });
  close.addEventListener('click', function(e){ e.preventDefault(); hide(); });
  modal.addEventListener('click', function(e){ if(e.target === modal) hide(); });
  document.addEventListener('keydown', function(e){
    if(e.key === 'Escape' && modal.style.display === 'flex') hide();
  });

  const img = document.getElementById('enemyGuideImg');
  if(img) img.addEventListener('dragstart', function(ev){ ev.preventDefault(); });
})();


// ===== FURIA WAVES (visual + damage) =====
let furiaWaves=[];
// A wave is: {x,y,start,delay,duration,maxR,damage,doneDamage}
function spawnFuriaWaves(x,y){
  const waves=[
    {delay:0,   maxR:190, duration:620, damage:20},
    {delay:420, maxR:300, duration:760, damage:20},
    {delay:880, maxR:430, duration:920, damage:20},
  ];
  const now=Date.now();
  for(const w of waves){
    furiaWaves.push({
      x,y,
      start: now + w.delay,
      delay:w.delay,
      duration:w.duration,
      maxR:w.maxR,
      damage:w.damage,
      doneDamage:false
    });
  }
  // extra punch
  shakeAmount = Math.max(shakeAmount, 10);
  for(let i=0;i<3;i++) createParticles(x+(Math.random()-0.5)*30,y+(Math.random()-0.5)*30,'#ff00ff',22,5);
}

function updateFuriaWaves(){
  const now=Date.now();
  furiaWaves = furiaWaves.filter(w=>{
    // not started yet
    if(now < w.start) return true;

    const t = (now - w.start);
    const prog = Math.max(0, Math.min(1, t / w.duration));
    const r = w.maxR * prog;

    // Apply damage once, early in the wave (so it feels immediate)
    if(!w.doneDamage && prog >= 0.15){
      w.doneDamage=true;

      // strong particles ring
      for(let i=0;i<26;i++){
        const a = (Math.PI*2)*(i/26);
        createParticles(w.x + Math.cos(a)*Math.min(r+18, w.maxR), w.y + Math.sin(a)*Math.min(r+18, w.maxR), '#ff00ff', 2, 4);
      }

      for(let i=enemies.length-1;i>=0;i--){
        const e=enemies[i];
        const d=Math.hypot((e.x+e.width/2)-w.x,(e.y+e.height/2)-w.y);
        if(d<=w.maxR){
          const _final=applyEnemyDamage(e, w.damage);
          showDamageNumber(e.x,e.y,_final);
          createParticles(e.x,e.y,'#ff4dff',14,5);
          if(e.hp<=0){
            createParticles(e.x,e.y,'#fff176',30,6);
            dropStellarBonusAtIndexIfNeeded(i);
            enemies.splice(i,1);
            applyScore(100*currentLevel);
          addKill(); }
        }
      }
    }

    // keep until finished
    return t <= w.duration;
  });
}

function drawFuriaWaves(){
  const now=Date.now();
  for(const w of furiaWaves){
    if(now < w.start) continue;
    const t = (now - w.start);
    const prog = Math.max(0, Math.min(1, t / w.duration));
    const r = w.maxR * prog;

    // fade out near end
    const fade = (prog < 0.75) ? 1 : Math.max(0, 1 - ((prog-0.75)/0.25));
    const alpha = 0.55 * fade;

    // Outer ring
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.lineWidth = 10;
    ctx.shadowColor = '#000000'; ctx.shadowBlur = 25; ctx.strokeStyle = 'rgba(255,0,255,0.95)';
    ctx.beginPath();
    ctx.arc(w.x, w.y, r, 0, Math.PI*2);
    ctx.stroke();

    // Glow ring
    ctx.globalAlpha = alpha*0.35;
    ctx.lineWidth = 22;
    ctx.beginPath();
    ctx.arc(w.x, w.y, r, 0, Math.PI*2);
    ctx.stroke();

    // Core ripple
    ctx.globalAlpha = alpha*0.25;
    ctx.lineWidth = 6;
    ctx.shadowColor = '#000000'; ctx.shadowBlur = 25; ctx.strokeStyle = 'rgba(255,180,255,0.9)';
    ctx.beginPath();
    ctx.arc(w.x, w.y, Math.max(0, r*0.65), 0, Math.PI*2);
    ctx.stroke();
    ctx.restore();
  }
}


// --- MARCUS UNLOCK: at least one character record >= 70000 ---
function updateMarcusUnlock(){
  const badge=document.getElementById('marcusLockBadge');
  const card=document.getElementById('card-marcus');
  if(!badge||!card) return;

  let maxRecord=0;
  document.querySelectorAll('.record-badge').forEach(r=>{
    const v=parseInt(r.textContent.replace(/[^0-9]/g,''))||0;
    if(v>maxRecord) maxRecord=v;
  });

  if(maxRecord>=70000){
    card.classList.remove('disabled');
    if(badge) badge.style.display='none';
  }
}
setInterval(updateMarcusUnlock,500);
setInterval(updateLucienUnlockUI,500);


// --- Ensure MARCUS selection behaves like others ---
document.querySelectorAll('.char-grid button[data-target]').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    const target = btn.dataset.target;
    const card = document.getElementById('card-'+target);
    if(!card || card.classList.contains('disabled')) return;

    document.querySelectorAll('.character-card').forEach(c=>c.classList.remove('selected'));
    card.classList.add('selected');
    selectedCharacter = target;
  });
});



/* ===== Account Menu Handlers ===== */
function openAccountMenu(){
  try{
    const mm=document.getElementById("mainMenu");
    const am=document.getElementById("accountMenu");
    if(mm) mm.style.display="none";
    if(am) am.style.display="block";
    refreshAccountUi(false);
  }catch(e){}
}
function closeAccountMenu(){
  try{
    const mm=document.getElementById("mainMenu");
    const am=document.getElementById("accountMenu");
    if(am) am.style.display="none";
    if(mm) mm.style.display="block";
    refreshAccountUi(false);
  }catch(e){}
}




function openAccountRoadMenu(){
  try{
    const am=document.getElementById("accountMenu");
    const rm=document.getElementById("accountRoadMenu");
    if(am) am.style.display="none";
    if(rm) rm.style.display="block";
    refreshAccountRoadUi();
    buildAccountRoad();
    scrollRoadToCurrent();
  }catch(e){}
}
function closeAccountRoadMenu(){
  try{
    const am=document.getElementById("accountMenu");
    const rm=document.getElementById("accountRoadMenu");
    if(rm) rm.style.display="none";
    if(am) am.style.display="block";
    refreshAccountUi(false);
  }catch(e){}
}

function refreshAccountRoadUi(){
  const lv=document.getElementById("roadMenuLevel");
  const xp=document.getElementById("roadMenuXp");
  const need=document.getElementById("roadMenuXpNeed");
  const bar=document.getElementById("roadXpBar");
  if(lv) lv.textContent=String(accountState.level);
  if(xp) xp.textContent=String(accountState.xp);
  if(need) need.textContent=String(accountState.xpNeed);
  if(bar){
    const pct = Math.max(0, Math.min(100, (accountState.xp / Math.max(1, accountState.xpNeed))*100));
    bar.style.width = pct + "%";
  }
}

function buildAccountRoad(){
  const track=document.getElementById("accountRoadTrack");
  if(!track) return;

  // remove old nodes (keep line)
  [...track.querySelectorAll(".road-node")].forEach(n=>n.remove());

  // how many levels to show now (can be extended later)
  const maxShow = Math.max(30, accountState.level + 10);

  for(let lv=1; lv<=maxShow; lv++){
    const node=document.createElement("div");
    node.className="road-node " + (lv < accountState.level ? "done" : (lv===accountState.level ? "current" : "locked"));
    node.dataset.level = String(lv);

    const t=document.createElement("div");
    t.className="rn-lv";
    t.textContent = "LV " + lv;

    const r=document.createElement("div");
    r.className="rn-reward";
    // placeholder rewards: you will customize later
    r.textContent = (lv===accountState.level ? " " : (lv < accountState.level ? "" : "???"));

    node.appendChild(t);
    node.appendChild(r);
    track.appendChild(node);
  }
}

function scrollRoadToCurrent(){
  const sc=document.getElementById("accountRoadScroll");
  const cur=document.querySelector("#accountRoadTrack .road-node.current");
  if(!sc || !cur) return;
  const left = cur.offsetLeft - (sc.clientWidth/2) + (cur.clientWidth/2);
  sc.scrollLeft = Math.max(0, left);
}

function getUnlockedCharacterKeys(){
  const cards=[...document.querySelectorAll('.character-card[data-char]')];
  const keys = cards
    .filter(c=>c && c.dataset && c.dataset.char && !(c.classList && c.classList.contains('disabled')) )
    .map(c=>String(c.dataset.char||"").trim())
    .filter(k=>k && !k.startsWith("extra"));

  // unique
  return [...new Set(keys)];
}


function renderSkinMenu(){
  const sc=document.getElementById("skinScroller");
  if(!sc) return;

  const keys=getUnlockedCharacterKeys();
  sc.innerHTML="";

  if(keys.length===0){
    sc.innerHTML = `<div style="padding:10px;color:#ddd;font-size:16px;opacity:0.9;">Nessun personaggio sbloccato ancora.</div>`;
    return;
  }

  keys.forEach((k)=>{
    // name from character card if available
    let name=k.toUpperCase();
    const h3=document.querySelector(`.character-card[data-char="${k}"] h3`);
    if(h3 && h3.textContent) name=h3.textContent.trim();

    // image source
    let src="";
    try{
      if(typeof images!=="undefined" && images && images[k] && images[k].src) src=images[k].src;
    }catch(e){}

    const card=document.createElement("div");
    card.className="skin-card";
    const imgHtml = src ? `<img alt="${name}" src="${src}"/>` : `<div class="skin-img-missing" aria-hidden="true">?</div>`;
    card.innerHTML = `
      ${imgHtml}
      <div class="skin-name">${name}</div>
      <div class="skin-sub">Sbloccato</div>
    `;
    sc.appendChild(card);
  });
}

function openSkinMenu(){
  try{
    const mm=document.getElementById("mainMenu");
    const sm=document.getElementById("skinMenu");
    if(mm) mm.style.display="none";
    if(sm) sm.style.display="block";
    renderSkinMenu();
  }catch(e){}
}
function closeSkinMenu(){
  try{
    const mm=document.getElementById("mainMenu");
    const sm=document.getElementById("skinMenu");
    if(sm) sm.style.display="none";
    if(mm) mm.style.display="block";
  }catch(e){}
}
document.addEventListener("DOMContentLoaded", ()=>{
  document.addEventListener('keydown', (e)=>{ if(e.key==='Escape' || e.key==='h' || e.key==='H'){ if(gameState==='playing') openPauseMenu(); else if(gameState==='paused') resumeFromPause(); }});
  const pauseBtn=document.getElementById('pauseBtn');
  const pauseContinue=document.getElementById('pauseContinueBtn');
  const pauseMenu=document.getElementById('pauseMenuBtn');
  if(pauseBtn) pauseBtn.addEventListener('click', openPauseMenu);
  if(pauseContinue) pauseContinue.addEventListener('click', resumeFromPause);
  if(pauseMenu) pauseMenu.addEventListener('click', exitToMenuFromPause);
  const btn=document.getElementById("accountLevelBtn");
  const back=document.getElementById("accountBackBtn");
  const sortBtn=document.getElementById("missionsSortBtn");
  const roadBtn=document.getElementById("accountRoadBtn");
  

  const skinBtn=document.getElementById("skinBtn");
  const skinBack=document.getElementById("skinBackBtn");
  if(skinBtn) skinBtn.addEventListener("click", openSkinMenu);
  if(skinBack) skinBack.addEventListener("click", closeSkinMenu);
if(btn) btn.addEventListener("click", openAccountMenu);
  if(roadBtn) roadBtn.addEventListener("click", openAccountRoadMenu);
  if(back) back.addEventListener("click", closeAccountMenu);
  if(sortBtn) sortBtn.addEventListener("click", ()=>{
    missionsSortMode = (missionsSortMode==="completion") ? "difficulty" : "completion";
    sortBtn.textContent = (missionsSortMode==="completion") ? "‚Üï Ordine: pi√π vicine" : "‚Üï Ordine: difficolt√†";
    renderMissions();
  });
  normalizeAccountProgress(false);
  refreshAccountUi(false);
});


function renderUnlockButton(character){
    if(character.locked){
        return `<button onclick="unlockCharacter('${character.id}')">
                SBLOCCA (1000 Frammenti d'Etere)
                </button>`;
    }
    return "";
}


function showCosmoShopModal(){
  const modal = document.getElementById('cosmoShopModal');
  if(!modal) return;
  const hint = document.getElementById('cosmoShopHint');
  const buyBtn = document.getElementById('cosmoShopBuyBtn');
  const okBtn = document.getElementById('cosmoShopOkBtn');
  const closeBtn = document.getElementById('cosmoShopCloseBtn');

  // If already purchased, never show
  if(isCharPurchased && isCharPurchased('cosmo')) return;

  if(hint){
    hint.textContent = '';
  }

  const close = ()=>{
    try{ modal.style.display='none'; modal.classList.remove('show'); }catch(e){}
  };

  if(closeBtn) closeBtn.onclick = close;
  if(okBtn) okBtn.onclick = close;

  if(buyBtn){
    buyBtn.style.display = 'inline-block';
    buyBtn.onclick = ()=>{
      const ok = tryPurchaseCosmo();
      if(ok){
        // Close and auto-select Cosmo
        close();
        try{
          // Mark selected in compact grid, if present
          document.querySelectorAll('.char-grid button').forEach(b=>b.classList.remove('selected'));
          const bcos = document.querySelector('.char-grid button[data-target="cosmo"]');
          if(bcos) bcos.classList.add('selected');
        }catch(e){}
        try{
          selectedCharacter = 'cosmo';
          updateMenuStatsDisplay('cosmo');
        }catch(e){}
      }else{
        if(hint) hint.textContent = "Frammenti insufficienti: servono 1000.";
      }
    };
  }

  modal.style.display='flex';
  modal.classList.add('show');
}

</script>
</div>
<script>
/* ================================
   KEYBOARD INPUT (WASD + ARROWS)
   ================================ */
function normalizeKey(key) {
  switch (key) {
    case 'ArrowUp': return 'w';
    case 'ArrowDown': return 's';
    case 'ArrowLeft': return 'a';
    case 'ArrowRight': return 'd';
    default: return key.toLowerCase();
  }
}

window.addEventListener('keydown', e => {
  const k = normalizeKey(e.key);
  keys[k] = true;
});

window.addEventListener('keyup', e => {
  const k = normalizeKey(e.key);
  keys[k] = false;
});

// --- MARCUS UNLOCK: at least one character record >= 70000 ---
function updateMarcusUnlock(){
  const badge=document.getElementById('marcusLockBadge');
  const card=document.getElementById('card-marcus');
  if(!badge||!card) return;

  let maxRecord=0;
  document.querySelectorAll('.record-badge').forEach(r=>{
    const v=parseInt(r.textContent.replace(/[^0-9]/g,''))||0;
    if(v>maxRecord) maxRecord=v;
  });

  if(maxRecord>=70000){
    card.classList.remove('disabled');
    if(badge) badge.style.display='none';
  }
}
setInterval(updateMarcusUnlock,500);


// --- Ensure MARCUS selection behaves like others ---
document.querySelectorAll('.char-grid button[data-target]').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    const target = btn.dataset.target;
    const card = document.getElementById('card-'+target);
    if(!card || card.classList.contains('disabled')) return;

    document.querySelectorAll('.character-card').forEach(c=>c.classList.remove('selected'));
    card.classList.add('selected');
    selectedCharacter = target;
  });
});


function renderUnlockButton(character){
    if(character.locked){
        return `<button onclick="unlockCharacter('${character.id}')">
                SBLOCCA (1000 Frammenti d'Etere)
                </button>`;
    }
    return "";
}

</script>


<script>
(function(){
  try{ window.selectedCharacter = window.selectedCharacter || null; }catch(e){ window.selectedCharacter = null; }
  function clearSelected(){ document.querySelectorAll('.character-card').forEach(c=>c.classList.remove('selected')); }
  document.querySelectorAll('.character-card').forEach(card=>{
    card.addEventListener('click', function(e){
      if(card.classList.contains('disabled')) return;
      clearSelected();
      card.classList.add('selected');
      var ch = card.dataset && card.dataset.char ? card.dataset.char : null;
      if(ch) window.selectedCharacter = ch;
      var legacy = document.getElementById('card-' + ch);
      if(legacy && legacy !== card){ legacy.classList.add('selected'); }
    });
  });
  document.addEventListener('DOMContentLoaded', function(){
    if(window.selectedCharacter){
      var el = document.querySelector('.character-card[data-char="' + window.selectedCharacter + '"]');
      if(el) el.classList.add('selected');
    }
  });
})();

// --- MARCUS UNLOCK: at least one character record >= 70000 ---
function updateMarcusUnlock(){
  const badge=document.getElementById('marcusLockBadge');
  const card=document.getElementById('card-marcus');
  if(!badge||!card) return;

  let maxRecord=0;
  document.querySelectorAll('.record-badge').forEach(r=>{
    const v=parseInt(r.textContent.replace(/[^0-9]/g,''))||0;
    if(v>maxRecord) maxRecord=v;
  });

  if(maxRecord>=70000){
    card.classList.remove('disabled');
    if(badge) badge.style.display='none';
  }
}
setInterval(updateMarcusUnlock,500);


// --- Ensure MARCUS selection behaves like others ---
document.querySelectorAll('.char-grid button[data-target]').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    const target = btn.dataset.target;
    const card = document.getElementById('card-'+target);
    if(!card || card.classList.contains('disabled')) return;

    document.querySelectorAll('.character-card').forEach(c=>c.classList.remove('selected'));
    card.classList.add('selected');
    selectedCharacter = target;
  });
});


function renderUnlockButton(character){
    if(character.locked){
        return `<button onclick="unlockCharacter('${character.id}')">
                SBLOCCA (1000 Frammenti d'Etere)
                </button>`;
    }
    return "";
}

</script>


<script>
document.querySelectorAll('.char-grid button[data-target]').forEach(b=>{
  b.addEventListener('click',()=>{
    const card=document.querySelector('#card-'+b.dataset.target);
    if(card && !card.classList.contains('disabled')){
      card.click();
    }
  });
});

// --- MARCUS UNLOCK: at least one character record >= 70000 ---
function updateMarcusUnlock(){
  const badge=document.getElementById('marcusLockBadge');
  const card=document.getElementById('card-marcus');
  if(!badge||!card) return;

  let maxRecord=0;
  document.querySelectorAll('.record-badge').forEach(r=>{
    const v=parseInt(r.textContent.replace(/[^0-9]/g,''))||0;
    if(v>maxRecord) maxRecord=v;
  });

  if(maxRecord>=70000){
    card.classList.remove('disabled');
    if(badge) badge.style.display='none';
  }
}
setInterval(updateMarcusUnlock,500);


// --- Ensure MARCUS selection behaves like others ---
document.querySelectorAll('.char-grid button[data-target]').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    const target = btn.dataset.target;
    const card = document.getElementById('card-'+target);
    if(!card || card.classList.contains('disabled')) return;

    document.querySelectorAll('.character-card').forEach(c=>c.classList.remove('selected'));
    card.classList.add('selected');
    selectedCharacter = target;
  });
});


function renderUnlockButton(character){
    if(character.locked){
        return `<button onclick="unlockCharacter('${character.id}')">
                SBLOCCA (1000 Frammenti d'Etere)
                </button>`;
    }
    return "";
}

</script>


<div id="lockMessage" style="
  position:fixed;
  left:50%;top:50%;
  transform:translate(-50%,-50%);
  background:rgba(0,0,0,0.9);
  border:3px solid #f39c12;
  padding:18px 22px;
  font-family:'Press Start 2P', cursive;
  font-size:12px;
  color:#fff;
  z-index:999;
  display:none;
  text-align:center;
  box-shadow:0 0 25px rgba(0,0,0,0.8);
">
  <div id="lockText"></div>
  <div style="margin-top:12px;">
    <button id="lockCloseBtn" style="
      background:#e74c3c;
      border:none;
      padding:8px 14px;
      font-family:'Press Start 2P', cursive;
      cursor:pointer;
      color:#fff;
      font-size:11px;
    ">OK</button>
    <button id="lockBuyBtn" style="
      background:#2ecc71;
      border:none;
      padding:8px 14px;
      font-family:'Press Start 2P', cursive;
      cursor:pointer;
      color:#06110a;
      font-size:11px;
      margin-left:10px;
      display:none;
    ">COMPRA</button>

  </div>
</div>


<!-- Auto-open / scroll fixes for extra characters (added by assistant) -->
<script>
(function(){
  const extraCharsBtn=document.getElementById('extraCharsBtn');
  const extraCharacterSelect=document.getElementById('extraCharacterSelect');
  // Helper to ensure an element is visible (display:block) and scrolled into view
  function openAndScrollTo(el){
    if(!el) return;
    if(window.getComputedStyle(el).display === 'none') el.style.display = 'block';
    setTimeout(()=>{ try{ el.scrollIntoView({behavior:'smooth', block:'nearest', inline:'center'}); }catch(e){} },60);
  }

  if(extraCharsBtn && extraCharacterSelect){
    extraCharsBtn.addEventListener('click', ()=>{
      const isOpen = extraCharacterSelect.style.display === 'block';
      extraCharacterSelect.style.display = isOpen ? 'none' : 'block';
      if(!isOpen){
        setTimeout(()=>{ try{ extraCharacterSelect.scrollIntoView({behavior:'smooth', block:'nearest', inline:'center'}); 
          const first = extraCharacterSelect.querySelector('.character-card');
          if(first) first.focus && first.focus(); }catch(e){} },80);
      }
    });

    // When clicking compact selector buttons, if the target card lives inside the extraCharacterSelect,
    // open that panel and scroll to it so selection is visible (handles Marcus/H√®cate cases).
    document.querySelectorAll('.char-grid button[data-target]').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        try{
          const target = btn.dataset.target;
          const card = document.getElementById('card-'+target);
          if(card && extraCharacterSelect && extraCharacterSelect.contains(card)){
            // open and scroll to target card
            extraCharacterSelect.style.display = 'block';
            setTimeout(()=>{ try{ card.scrollIntoView({behavior:'smooth', block:'nearest', inline:'center'}); }catch(e){} },80);
          }
        }catch(e){}
      });
    });
  }
})();

function renderUnlockButton(character){
    if(character.locked){
        return `<button onclick="unlockCharacter('${character.id}')">
                SBLOCCA (1000 Frammenti d'Etere)
                </button>`;
    }
    return "";
}

</script>


<!-- ===== SAFE MARCUS PATCH (non-invasiva) ===== -->
<script>
(function(){

// ------------------ GLOBAL ------------------
window.marcusSuper = null;

// ------------------ CHARACTER STATS ADD ------------------
if(typeof characterStats!=='undefined' && !characterStats.marcus){
  characterStats.marcus = {
    hp:340,
    speed:5.4,
    damage:20,
    range:720,
    cooldown:650,
    name:'Marcus',
    attackType:'marcusStream',
    superCooldown: 25000,
    superDuration:10000
  };
}

// ------------------ PROJECTILE PATCH ------------------
const _updateProjectiles = updateProjectiles;
updateProjectiles = function(){
  _updateProjectiles();
  const now = Date.now();
  if(!window.projectiles) return;

  for(const p of projectiles){
    if(p.meta && p.meta.marcus){
      const t = (now - p.created) / 1000;
      const freq = (p.meta && p.meta.freq) ? p.meta.freq : 1.0;
      const amp = (p.meta && p.meta.amp) ? p.meta.amp : 14;
      const phase = (p.meta && p.meta.phase) ? p.meta.phase : 0;
      const off = Math.sin(t * freq + phase) * amp;
      const len = Math.hypot(p.vx, p.vy) || 1;
      const perpX = -p.vy / len;
      const perpY = p.vx / len;
      p.x += perpX * off * 0.6;
      p.y += perpY * off * 0.6;
      p.x += p.vx * 0.06;
      p.y += p.vy * 0.06;
    }
  }
};

// (Removed old heal-on-hit logic)



// ------------------ PLAYER ATTACK PATCH ------------------
const _playerAttack = Player.prototype.attack;
Player.prototype.attack = function(){

  if(this.type==='pdor'){
    const now = Date.now();
    if(!this._pdorLastShot) this._pdorLastShot = 0;
    const cd = 420; // slower cadence between darts
    if(now - this._pdorLastShot < cd) return false;
    this._pdorLastShot = now;

    const cx = this.x + this.width/2;
    const cy = this.y + this.height/2;

    // auto-aim to closest enemy
    let target=null, best=999999;
    for(const e of enemies){
      const d=Math.hypot((e.x+e.width/2)-cx,(e.y+e.height/2)-cy);
      if(d<best){best=d;target=e;}
    }

    let ang = target
      ? Math.atan2((target.y+target.height/2)-cy,(target.x+target.width/2)-cx)
      : (this.facingRight?0:Math.PI);

    const speed = 9;
    const vx = Math.cos(ang)*speed;
    const vy = Math.sin(ang)*speed;

    const baseDmg = Math.round((this.damage||50) * (this.attackBuffMultiplier||1));

    spawnProjectile({
      x:cx,
      y:cy,
      vx,vy,speed,
      damage:baseDmg,
      ttl:1600,
      color:'#000000',
      radius:10,
      friendly:true,
      shape:'rect',
      w:35,
      h:10,
      angle:ang,
      meta:{ pdorChain:true, hitsLeft:5, hitRefs:[] }
    });
    createParticles(cx,cy,'#000000',10,4);
    return true;
  }


  if(this.type==='marcus'){

    const now = Date.now();
    if(!this._marcusLastShot) this._marcusLastShot = 0;

    const cd = 500; // cooldown (nerf: slower attacks)
    if(now - this._marcusLastShot < cd) return false;
    this._marcusLastShot = now;
    // ---- HEAL ON ATTACK (1% current HP, integer, min 1) ----
    const healAmount = Math.max(1, Math.floor(this.hp * 0.01));
    const _beforeHp = this.hp;
    this.hp = Math.min(this.maxHP, this.hp + healAmount);
    try{ accountOnHeal(this.hp - _beforeHp); }catch(e){}


    const cx = this.x + this.width/2;
    const cy = this.y + this.height/2;

    // auto-aim
    let target=null, best=999999;
    for(const e of enemies){
      const d=Math.hypot(e.x-cx,e.y-cy);
      if(d<best){best=d;target=e;}
    }

    let baseAngle = target
      ? Math.atan2((target.y+target.height/2)-cy,(target.x+target.width/2)-cx)
      : (this.facingRight?0:Math.PI);

    // TRUE STREAMS ‚Üí ONE long projectile each
    const spread=[-0.25,0,0.25];
    const speed = 6;

    for(const s of spread){

      const ang=baseAngle+s;

      spawnProjectile({
        x:cx,
        y:cy,
        vx:Math.cos(ang)*speed,
        vy:Math.sin(ang)*speed,
        damage:Math.round(20*this.attackBuffMultiplier*(this.baneSuperAttackMult||1)),
        ttl:900,            // long life = looks like beam/flow
        color:'#b19cff',
        radius:10,          // thicker = stream feeling
        friendly:true,
        meta:{marcus:true, phase:Math.random()*Math.PI*2}, wave:true, amp:16, freq:1.0
      });
    }

    return true;
  }
    
  if(this.type==='hendel'){
    const now=Date.now();
    if(now - this.lastAttack < this.cooldown || this.isDoingSuper) return false;
    this.lastAttack = now;
    this.attacking=true; this.attackTime=now;

    // auto-aim verso il nemico pi√π vicino (se presente)
    if(enemies && enemies.length){
      const pcx=this.x+this.width/2, pcy=this.y+this.height/2;
      let best=null, bestD=Infinity;
      for(const e of enemies){
        const ecx=e.x+e.width/2, ecy=e.y+e.height/2;
        const d=(ecx-pcx)*(ecx-pcx) + (ecy-pcy)*(ecy-pcy);
        if(d<bestD){bestD=d; best=e;}
      }
      if(best){
        const ecx=best.x+best.width/2, ecy=best.y+best.height/2;
        let dx=ecx-pcx, dy=ecy-pcy;
        const len=Math.hypot(dx,dy)||1;
        dx/=len; dy/=len;
        this.aimX=dx; this.aimY=dy;
        this.facingRight = dx>=0;
      }
    }

    // NEW BASE ATTACK (J): hammer sweep clockwise 75¬∞ ‚Äî damage 100 on hit
    const baseAng = Math.atan2(this.aimY||0, this.aimX||1);
    const arc = 75 * Math.PI / 180;

    this._hammerSwing = {
      start: now,
      duration: 260,
      baseAng,
      arc,
      // geometry (in local space: +x = forward)
      handleStart: 22,
      handleLen: 118,
      handleW: 30,
      headOffset: 196,
      headSize: 120,
      hitSet: new WeakSet(),
      hitDone: false
    };

    const cx=this.x+this.width/2, cy=this.y+this.height/2;
    createParticles(cx,cy,'#bdbdbd',14,5);
    shakeScreen();
    return true;
  }
return _playerAttack.call(this);
};

// ------------------ SUPER PATCH ------------------


const _super = Player.prototype.superAttack;
Player.prototype.superAttack = function(){

  if(this.type==='pdor'){
    const now=Date.now();
    const sc = (this.superCooldown!=null)?this.superCooldown:16000;
    if(this.lastSuper && (now - this.lastSuper) < sc) return false;
    this.lastSuper = now;

    // Spawn 7 random luminous orbiting rings for 8 seconds.
    startPdorOrbs(this, now);
    shakeScreen();
    return true;
  }

  if(this.type==='marcus'){
    const now=Date.now();
    // enforce cooldown (25s) ‚Äî fallback to 25000 if this.superCooldown is not set
    const sc = (this.superCooldown!=null)?this.superCooldown:25000;
    if(this.lastSuper && (now - this.lastSuper) < sc) return false;
    this.lastSuper = now;
    marcusSuper={endsAt:now+6500};
    this.pickupShieldUntil=now+6500;
    this.invulnerable=true;
    return true;
  }
  return _super.call(this);
};

// ------------------ ENEMY CONFUSION ------------------
// Marcus Super should "stun/confuse" ALL enemies (including Shooter/Attacker/Boss classes that override update).
// The old patch only wrapped Enemy.prototype.update, so subclasses with their own update() were immune.
function _applyMarcusConfusion(enemy){
  if(!(marcusSuper && Date.now() < marcusSuper.endsAt)) return false;

  // Confusion: wander randomly, no attacks, no AI.
  const s = enemy.speed || 2;
  enemy.vx = (Math.random()-0.5) * s * 2.0;
  enemy.vy = (Math.random()-0.5) * s * 2.0;
  enemy.x += enemy.vx;
  enemy.y += enemy.vy;

  // clamp within arena
  if(enemy.x < 0) enemy.x = 0;
  if(enemy.x + enemy.width > canvas.width) enemy.x = canvas.width - enemy.width;
  if(enemy.y < 0) enemy.y = 0;
  if(enemy.y + enemy.height > canvas.height - 50) enemy.y = canvas.height - 50 - enemy.height;

  return true;
}

(function patchAllEnemyUpdatesForMarcusSuper(){
  const wrappers = [];
  function wrap(proto){
    if(!proto || typeof proto.update !== 'function') return;
    const original = proto.update;
    // avoid double-wrapping
    if(original && original.__marcusWrapped) return;
    const wrapped = function(playerRef){
      if(_applyMarcusConfusion(this)) return;
      return original.call(this, playerRef);
    };
    wrapped.__marcusWrapped = true;
    proto.update = wrapped;
  }

  // Base + all known subclasses in this file
  wrap(Enemy && Enemy.prototype);
  wrap(typeof ShooterEnemy!=='undefined' && ShooterEnemy.prototype);
  wrap(typeof ArcherEnemy!=='undefined' && ArcherEnemy.prototype);
  wrap(typeof GlacialEnemy!=='undefined' && GlacialEnemy.prototype);
  wrap(typeof AttackReturnEnemy!=='undefined' && AttackReturnEnemy.prototype);
  wrap(typeof BossEnemy!=='undefined' && BossEnemy.prototype);
  wrap(typeof Boss5Enemy!=='undefined' && Boss5Enemy.prototype);
})();

})();

/* ==== COMPACT CHARACTER SELECT LOGIC ==== */
document.addEventListener('DOMContentLoaded', ()=>{
  const btns = document.querySelectorAll('.charBtn, .characterBtn, .selectCharBtn, .char-button');
  btns.forEach(b=>{
    b.addEventListener('click', ()=>{
      btns.forEach(x=>x.classList.remove('selected'));
      b.classList.add('selected');
    });
  });
});


function renderUnlockButton(character){
    if(character.locked){
        return `<button onclick="unlockCharacter('${character.id}')">
                SBLOCCA (1000 Frammenti d'Etere)
                </button>`;
    }
    return "";
}

</script>

<!-- Injected JS: compact grid selection behaviour -->
<script>
document.addEventListener('DOMContentLoaded', function(){
  const grid = document.querySelector('.char-grid');
  if(!grid) return;
  const gridButtons = Array.from(grid.querySelectorAll('button')).filter(b => !b.classList.contains('empty') && !b.disabled);
  // Initialize: if any button has attribute data-selected="true", mark it selected
  let initial = gridButtons.find(b => b.getAttribute('data-selected') === 'true');
  if(!initial){
    // Try to match window.selectedCharacter if available
    try{
      if(window.selectedCharacter){
        initial = gridButtons.find(b => b.getAttribute('data-target') === window.selectedCharacter);
      }
    }catch(e){}
  }
  if(initial) {
    gridButtons.forEach(b=>b.classList.remove('selected'));
    initial.classList.add('selected');
  }

  gridButtons.forEach(btn=>{
    btn.addEventListener('click', function(e){
      // toggle selection: selecting one at a time
      gridButtons.forEach(b=>b.classList.remove('selected'));
      btn.classList.add('selected');

      // update global variable if present
      try{ window.selectedCharacter = btn.getAttribute('data-target'); }catch(e){}

      // also sync with the larger character-card list (visual cue)
      const target = btn.getAttribute('data-target');
      if(target){
        document.querySelectorAll('.character-card').forEach(c=>c.classList.remove('selected'));
        const card = document.querySelector('.character-card[data-char="'+target+'"]');
        if(card) card.classList.add('selected');
      }
    });

    // keyboard accessibility: allow selection with Enter or Space
    btn.addEventListener('keydown', function(e){
      if(e.key === 'Enter' || e.key === ' '){
        e.preventDefault();
        btn.click();
      }
    });
  });
});

function renderUnlockButton(character){
    if(character.locked){
        return `<button onclick="unlockCharacter('${character.id}')">
                SBLOCCA (1000 Frammenti d'Etere)
                </button>`;
    }
    return "";
}

</script>


<!-- === LOCKED COMPACT BUTTON LOGIC PATCH (added) === -->
<script>
document.addEventListener('DOMContentLoaded', function(){

  const gridButtons = document.querySelectorAll('.char-grid button[data-target]');

  function syncLockedState(){
    gridButtons.forEach(btn=>{
      const id = btn.dataset.target;
      const card = document.getElementById('card-'+id);
      if(!card) return;

      if(card.classList.contains('disabled')){
        btn.classList.add('locked');
        btn.classList.remove('selected');
        btn.disabled = false; // still clickable to show lock message
      }else{
        btn.classList.remove('locked');
      }
    });
  }

  // initial sync
  syncLockedState();

  // re-check every 500ms (covers unlocks like Marcus)
  setInterval(syncLockedState, 500);

  // block selection glow for locked
  gridButtons.forEach(btn=>{
    btn.addEventListener('click', function(e){
      if(btn.classList.contains('locked')){
        btn.classList.remove('selected');
        return; // do not allow orange selection
      }
    }, true);
  });
});

function renderUnlockButton(character){
    if(character.locked){
        return `<button onclick="unlockCharacter('${character.id}')">
                SBLOCCA (1000 Frammenti d'Etere)
                </button>`;
    }
    return "";
}

</script>


<!-- AUTO-START ON COMPACT SELECTION: selects character and starts battle when clicking the compact name+emoji button -->

<script>
document.addEventListener('DOMContentLoaded', function(){
  try{
    const compactButtons = document.querySelectorAll('.char-grid button[data-target]');
    compactButtons.forEach(btn=>{
      btn.addEventListener('click', function(e){
        try{
          const id = btn.dataset.target;
          if(!id) return;
          const card = document.getElementById('card-' + id);
          // Only allow selection if card exists and is not disabled/locked
          if(card && !card.classList.contains('disabled')){
            // set selection in global
            window.selectedCharacter = id;
            // visual: remove previous selected markers
            document.querySelectorAll('.char-grid button').forEach(b=>b.classList.remove('selected'));
            btn.classList.add('selected');
            document.querySelectorAll('.character-card').forEach(c=>c.classList.remove('selected'));
            card.classList.add('selected');
            // update displays if existing functions are available
            if(typeof updateMenuRecordsDisplay === 'function') try{ updateMenuRecordsDisplay(); }catch(e){}
            if(typeof updateMenuStatsDisplay === 'function') try{ updateMenuStatsDisplay(id); }catch(e){}
            // do NOT start the game automatically; user must press INIZIA BATTAGLIA
          } else {
            // Optionally show a brief locked feedback if a function exists
            if(typeof showLockedFeedback === 'function') try{ showLockedFeedback(id); }catch(e){}
          }
        }catch(err){}
      });
    });
  }catch(e){}
});

function renderUnlockButton(character){
    if(character.locked){
        return `<button onclick="unlockCharacter('${character.id}')">
                SBLOCCA (1000 Frammenti d'Etere)
                </button>`;
    }
    return "";
}

</script>



<script>
document.addEventListener('DOMContentLoaded', function(){
  function syncCompactRecords(){
    document.querySelectorAll('.record-badge').forEach(r=>{
      const id = r.id.replace('record-','');
      const btn = document.getElementById('btnrec-'+id);
      if(btn){
        const val = parseInt(r.textContent.replace(/[^0-9]/g,''))||0;
        btn.textContent = 'R: ' + val;
      }
    });
  }

  // initial + periodic sync
  syncCompactRecords();
  setInterval(syncCompactRecords, 500);

  // if existing update function exists, hook it
  if(typeof updateMenuRecordsDisplay === 'function'){
    const old = updateMenuRecordsDisplay;
    window.updateMenuRecordsDisplay = function(){
      old();
      syncCompactRecords();
    }
  }
});

function renderUnlockButton(character){
    if(character.locked){
        return `<button onclick="unlockCharacter('${character.id}')">
                SBLOCCA (1000 Frammenti d'Etere)
                </button>`;
    }
    return "";
}

</script>


<script>
document.addEventListener('DOMContentLoaded', function(){

  const totalEl = document.getElementById('totalScoreDisplay');

  
  function updateVisibility(){
    if(typeof gameState !== 'undefined' && gameState === 'playing'){
      totalEl.style.display = 'none';
    }else{
      totalEl.style.display = 'block';
    }
  }

  function updateTotalScore(){
    let total = 0;
    document.querySelectorAll('.record-badge').forEach(r=>{
      const v = parseInt(r.textContent.replace(/[^0-9]/g,'')) || 0;
      total += v;
    });
    if(totalEl) totalEl.textContent = 'PUNTEGGIO TOTALE: ' + total;
  

// Sync nel sistema missioni (MITICA totalScore) usando il totale record-badge
try{
  if(typeof accountState !== 'undefined' && accountState && accountState.stats){
    accountState.stats.totalScore = total;
    if(Array.isArray(accountState.missions)){
      for(const mm of accountState.missions){
        if(!mm.claimed && mm.type==='totalScore'){
          mm.progress = total;
        }
      }
    }
    if(typeof saveAccount === 'function') saveAccount();
  }
}catch(e){}

}

  updateTotalScore();
  setInterval(()=>{updateTotalScore();updateVisibility();}, 300);

  if(typeof updateMenuRecordsDisplay === 'function'){
    const old = updateMenuRecordsDisplay;
    window.updateMenuRecordsDisplay = function(){
      old();
      updateTotalScore();
    }
  }
});

function renderUnlockButton(character){
    if(character.locked){
        return `<button onclick="unlockCharacter('${character.id}')">
                SBLOCCA (1000 Frammenti d'Etere)
                </button>`;
    }
    return "";
}

</script>


<!-- Level Up Overlay -->
<div id="levelUpOverlay" style="display:none;">
  <div class="lu-card">
    <div class="lu-title">LEVEL UP!</div>
    <div class="lu-sub">Sei salito al livello</div>
    <div class="lu-level" id="levelUpNewLevel">2</div>
  </div>
</div>


<div id="pauseOverlay">
  <div id="pauseBox">
    <div class="pause-title">PAUSA</div>
    <div class="pause-actions">
      <button id="pauseContinueBtn">CONTINUA</button>
      <button id="pauseMenuBtn">TORNA AL MENU</button>
    </div>
  </div>
</div>



<script>
/* ===== Frammento d'Etere (Currency) ===== */
const ETHER_KEY="pf_ether";
const ETHER_CLAIMS_KEY="pf_ether_claims_v1"; // per-level claims for road
function etherRewardForLevel(lv){
  // Early level overrides
  if (lv === 1) return 0;
  if (lv === 2) return 100;
  if (lv === 3) return 100;
  if (lv === 4) return 100;

  lv = Math.max(1, Math.floor(Number(lv)||1));

  // Milestone overrides (richieste dall'utente)
  if (lv === 10) return 400;
  if (lv === 15) return 500;
  if (lv === 20) return 750;
  if (lv === 25) return 1000;


  /*
    Progressione "marcata" richiesta:
    - lvl 5 = 300 (milestone)
    - lvl 6 ‚âà 200 (normale)
    - lvl 30 = 1500 (milestone)
    - crescita sempre pi√π forte salendo (curva convessa) + bonus ogni 5 livelli.

    Modello:
      base(lv)  = 200 + k*(lv-6)^2          (convesso)
      bonus(lv) = A + B*(t-1)^2  solo se lv%5==0, t=lv/5
      reward    = round(base + bonus)
  */
  const k = 1.5625;       // intensit√† crescita base (tarata per lvl30 ~ 1100 di base)
  const A = 98.4375;      // bonus milestone al livello 5 (tarato per arrivare a 300)
  const B = 12.064;       // crescita del bonus milestone (quadratica)

  const base = 200 + k * Math.pow(lv - 6, 2);

  let bonus = 0;
  if(lv % 5 === 0){
    const t = lv / 5;              // 1 al lvl5, 2 al lvl10, ...
    bonus = A + B * Math.pow(t - 1, 2);
  }

  return Math.round(((base + bonus) / 10)) * 10;
}

let ether=parseInt(localStorage.getItem(ETHER_KEY))||0;
let etherClaims={};
try{ etherClaims = JSON.parse(localStorage.getItem(ETHER_CLAIMS_KEY)||"{}") || {}; }catch(e){ etherClaims = {}; }

const etherEl=document.getElementById("etherCount");
const etherHud=document.getElementById("etherHud");

function saveEther(){ try{ localStorage.setItem(ETHER_KEY,String(ether)); }catch(e){} }
function saveEtherClaims(){ try{ localStorage.setItem(ETHER_CLAIMS_KEY, JSON.stringify(etherClaims)); }catch(e){} }
function updateEther(){ if(etherEl) etherEl.textContent=String(ether); }
updateEther();

/* ===== PERSONAGGI ACQUISTABILI CON ETERE ===== */
const CHAR_PURCHASES_KEY = "pf_char_purchases_v1";
function loadCharPurchases(){
  try{ return JSON.parse(localStorage.getItem(CHAR_PURCHASES_KEY) || "{}") || {}; }
  catch(e){ return {}; }
}
function saveCharPurchases(obj){
  try{ localStorage.setItem(CHAR_PURCHASES_KEY, JSON.stringify(obj||{})); }catch(e){}
}
let charPurchases = loadCharPurchases();
function isCharPurchased(id){ return !!(charPurchases && charPurchases[id]); }

function unlockCosmoUI(){
  try{
    const card=document.getElementById('card-cosmo');
    const badge=document.getElementById('cosmoLockBadge');
    if(card) card.classList.remove('disabled');
    if(badge) badge.style.display='none';
  }catch(e){}
}
function refreshCosmoPurchaseState(){
  if(isCharPurchased('cosmo')) unlockCosmoUI();
}
refreshCosmoPurchaseState();

function tryPurchaseCosmo(){
  const COST = 1000;
  if(isCharPurchased('cosmo')) return true;
  if((ether||0) < COST) return false;

  ether = Math.max(0, Math.floor(ether||0) - COST);
  saveEther();
  updateEther();

  charPurchases = charPurchases || {};
  charPurchases.cosmo = true;
  saveCharPurchases(charPurchases);
  try{ if(typeof setCosmoUnlocked==='function') setCosmoUnlocked(); }catch(e){}
      unlockCosmoUI();
  return true;
}

/* ===== BONUS ETERE: +50 per ogni personaggio con RECORD >= 50.000 (una sola volta per personaggio) ===== */
const ETHER_RECORD50K_CLAIMS_KEY = "pf_ether_record50k_claims_v1";

function loadRecord50kClaims(){
  try{ return JSON.parse(localStorage.getItem(ETHER_RECORD50K_CLAIMS_KEY) || "{}") || {}; }
  catch(e){ return {}; }
}
function saveRecord50kClaims(claims){
  try{ localStorage.setItem(ETHER_RECORD50K_CLAIMS_KEY, JSON.stringify(claims||{})); }catch(e){}
}

function grantEtherForRecord50k(){
  try{
    const claims = loadRecord50kClaims();
    let recs = {};
    try{ recs = JSON.parse(localStorage.getItem(RECORDS_KEY) || "{}") || {}; }catch(e){ recs = {}; }

    let add = 0;
    for(const k in recs){
      const v = Math.max(0, Math.floor(Number(recs[k]) || 0));
      if(v >= 50000 && !claims[k]){
        claims[k] = true;
        add += 50;
      }
    }

    if(add > 0){
      ether = Math.max(0, Math.floor(ether||0)) + add;
      saveEther();
      saveRecord50kClaims(claims);
      updateEther();

      // piccolo feedback visivo sul HUD
      try{
        const float=document.createElement("div");
        float.textContent="+"+add;
        float.style.position="fixed";
        const r = etherEl ? etherEl.getBoundingClientRect() : {left:20, top:20, width:0, height:0};
        float.style.left=(r.left + r.width/2)+"px";
        float.style.top=(r.top - 10)+"px";
        float.style.transform="translate(-50%,-50%)";
        float.style.color="#7fffd4";
        float.style.fontFamily="'Press Start 2P', cursive";
        float.style.fontSize="14px";
        float.style.textShadow="1px 1px 2px #000";
        float.style.zIndex="99999";
        float.style.pointerEvents="none";
        float.style.opacity="1";
        float.style.transition="transform 650ms ease, opacity 650ms ease";
        document.body.appendChild(float);
        requestAnimationFrame(()=>{ float.style.transform="translate(-50%,-80px)"; float.style.opacity="0"; });
        setTimeout(()=>{ try{ float.remove(); }catch(e){} }, 700);
      }catch(e){}
    }
  }catch(e){}
}

/* ===== BONUS ETERE: +75 per ogni personaggio con RECORD > 75.000 (una sola volta per personaggio) ===== */
const ETHER_RECORD75K_CLAIMS_KEY = "pf_ether_record75k_claims_v1";

function loadRecord75kClaims(){
  try{ return JSON.parse(localStorage.getItem(ETHER_RECORD75K_CLAIMS_KEY) || "{}") || {}; }
  catch(e){ return {}; }
}
function saveRecord75kClaims(claims){
  try{ localStorage.setItem(ETHER_RECORD75K_CLAIMS_KEY, JSON.stringify(claims||{})); }catch(e){}
}

function grantEtherForRecord75k(){
  try{
    const claims = loadRecord75kClaims();
    let recs = {};
    try{ recs = JSON.parse(localStorage.getItem(RECORDS_KEY) || "{}") || {}; }catch(e){ recs = {}; }

    let add = 0;
    for(const k in recs){
      const v = Math.max(0, Math.floor(Number(recs[k]) || 0));
      if(v > 75000 && !claims[k]){
        claims[k] = true;
        add += 75;
      }
    }

    if(add > 0){
      ether = Math.max(0, Math.floor(ether||0)) + add;
      saveEther();
      saveRecord75kClaims(claims);
      updateEther();

      // piccolo feedback visivo sul HUD
      try{
        const float=document.createElement("div");
        float.textContent="+"+add;
        float.style.position="fixed";
        const r = etherEl ? etherEl.getBoundingClientRect() : {left:20, top:20, width:0, height:0};
        float.style.left=(r.left + r.width/2)+"px";
        float.style.top=(r.top - 10)+"px";
        float.style.transform="translate(-50%,-50%)";
        float.style.color="#7fffd4";
        float.style.fontFamily="'Press Start 2P', cursive";
        float.style.fontSize="14px";
        float.style.textShadow="1px 1px 2px #000";
        float.style.zIndex="99999";
        float.style.pointerEvents="none";
        float.style.opacity="1";
        float.style.transition="transform 650ms ease, opacity 650ms ease";
        document.body.appendChild(float);
        requestAnimationFrame(()=>{ float.style.transform="translate(-50%,-80px)"; float.style.opacity="0"; });
        setTimeout(()=>{ try{ float.remove(); }catch(e){} }, 700);
      }catch(e){}
    }
  }catch(e){}
}

/* ===== BONUS ETERE: +100 per ogni personaggio con RECORD > 100.000 (una sola volta per personaggio) ===== */
const ETHER_RECORD100K_CLAIMS_KEY = "pf_ether_record100k_claims_v1";

function loadRecord100kClaims(){
  try{ return JSON.parse(localStorage.getItem(ETHER_RECORD100K_CLAIMS_KEY) || "{}") || {}; }
  catch(e){ return {}; }
}
function saveRecord100kClaims(claims){
  try{ localStorage.setItem(ETHER_RECORD100K_CLAIMS_KEY, JSON.stringify(claims||{})); }catch(e){}
}

function grantEtherForRecord100k(){
  try{
    const claims = loadRecord100kClaims();
    let recs = {};
    try{ recs = JSON.parse(localStorage.getItem(RECORDS_KEY) || "{}") || {}; }catch(e){ recs = {}; }

    let add = 0;
    for(const k in recs){
      const v = Math.max(0, Math.floor(Number(recs[k]) || 0));
      if(v > 100000 && !claims[k]){
        claims[k] = true;
        add += 100;
      }
    }

    if(add > 0){
      ether = Math.max(0, Math.floor(ether||0)) + add;
      saveEther();
      saveRecord100kClaims(claims);
      updateEther();

      // piccolo feedback visivo sul HUD
      try{
        const float=document.createElement("div");
        float.textContent="+"+add;
        float.style.position="fixed";
        const r = etherEl ? etherEl.getBoundingClientRect() : {left:20, top:20, width:0, height:0};
        float.style.left=(r.left + r.width/2)+"px";
        float.style.top=(r.top - 10)+"px";
        float.style.transform="translate(-50%,-50%)";
        float.style.color="#7fffd4";
        float.style.fontFamily="'Press Start 2P', cursive";
        float.style.fontSize="14px";
        float.style.textShadow="1px 1px 2px #000";
        float.style.zIndex="99999";
        float.style.pointerEvents="none";
        float.style.opacity="1";
        float.style.transition="transform 650ms ease, opacity 650ms ease";
        document.body.appendChild(float);
        requestAnimationFrame(()=>{ float.style.transform="translate(-50%,-80px)"; float.style.opacity="0"; });
        setTimeout(()=>{ try{ float.remove(); }catch(e){} }, 700);
      }catch(e){}
    }
  }catch(e){}
}

// run subito + ogni volta che i record si aggiornano in menu
grantEtherForRecord50k();
grantEtherForRecord75k();
grantEtherForRecord100k();
if(typeof updateMenuRecordsDisplay === "function"){
  const _oldUMRD = updateMenuRecordsDisplay;
  window.updateMenuRecordsDisplay = function(){
    _oldUMRD();
    grantEtherForRecord50k();
    grantEtherForRecord75k();
    grantEtherForRecord100k();
  };
}


function markClaimed(level){
  etherClaims[String(level)] = true;
  saveEtherClaims();
}

/* Animazione: icona dal nodo -> HUD + count-up */
function animateEtherFromNode(nodeEl, amount){
  try{
    // floating "+amount"
    const float=document.createElement("div");
    float.textContent="+"+amount;
    float.style.position="fixed";
    float.style.color="#7fffd4";
    float.style.fontFamily="'Press Start 2P', cursive";
    float.style.fontSize="14px";
    float.style.textShadow="0 0 12px rgba(127,255,212,0.55), 1px 1px 2px #000";
    float.style.pointerEvents="none";
    float.style.zIndex=99999;
    document.body.appendChild(float);

    const nRect=nodeEl.getBoundingClientRect();
    float.style.left = (nRect.left + nRect.width*0.5) + "px";
    float.style.top  = (nRect.top + 6) + "px";
    float.style.transform = "translateX(-50%)";
    float.style.animation="xpPop 750ms ease forwards";
    setTimeout(()=>{ try{ float.remove(); }catch(e){} }, 800);

    // fly icon
    const icon=document.createElement("img");
    icon.src="https://i.postimg.cc/pXChR57C/unnamed.png";
    icon.alt="Etere";
    icon.style.position="fixed";
    icon.style.width="22px";
    icon.style.height="22px";
    icon.style.imageRendering="pixelated";
    icon.style.zIndex=999999;
    icon.style.left = (nRect.left + nRect.width*0.5 - 11) + "px";
    icon.style.top  = (nRect.top  + nRect.height*0.5 - 11) + "px";
    icon.style.filter="drop-shadow(0 0 10px rgba(127,255,212,0.45))";
    icon.style.transition="transform 520ms ease, left 520ms ease, top 520ms ease, opacity 520ms ease";
    document.body.appendChild(icon);

    const hRect = etherHud ? etherHud.getBoundingClientRect() : {left:window.innerWidth-40, top:20, width:30, height:30};
    requestAnimationFrame(()=>{
      icon.style.left = (hRect.left + 6) + "px";
      icon.style.top  = (hRect.top + 6) + "px";
      icon.style.transform = "scale(1.35)";
      icon.style.opacity = "0.15";
    });
    setTimeout(()=>{ try{ icon.remove(); }catch(e){} }, 560);

    // HUD pop
    if(etherHud){
      etherHud.style.transition="transform 160ms ease, filter 160ms ease";
      etherHud.style.transform="scale(1.10)";
      etherHud.style.filter="drop-shadow(0 0 12px rgba(127,255,212,0.55))";
      setTimeout(()=>{
        etherHud.style.transform="scale(1.00)";
        etherHud.style.filter="none";
      },180);
    }
  }catch(e){}
}

/* Public claim function for road nodes */
function claimEtherForLevel(level, nodeEl){
  level = Math.max(1, Math.floor(level||1));
  if(etherClaims[String(level)]) return false;

  // eligibility: allow claim only up to current account level
  const maxEligible = (typeof accountState !== "undefined" && accountState && typeof accountState.level==="number")
    ? Math.max(1, Math.floor(accountState.level))
    : 1;

  if(level > maxEligible) return false;

  const reward = etherRewardForLevel(level); ether += reward;
  saveEther();
  markClaimed(level);
  updateEther();
  animateEtherFromNode(nodeEl || etherHud, reward);
  return true;
}

/* Hook: upgrade buildAccountRoad so nodes show reward + clickable claim */
(function hookRoad(){
  const tryHook=()=>{
    if(typeof buildAccountRoad!=="function") return false;
    const oldBuild = buildAccountRoad;
    window.buildAccountRoad = function(){
      oldBuild();

      const track=document.getElementById("accountRoadTrack");
      if(!track) return;

      const maxEligible = (typeof accountState !== "undefined" && accountState && typeof accountState.level==="number")
        ? Math.max(1, Math.floor(accountState.level))
        : 1;

      track.querySelectorAll(".road-node").forEach(node=>{
        const lv = parseInt(node.dataset.level||"0")||0;
        const rewardEl = node.querySelector(".rn-reward");
        const claimed = !!etherClaims[String(lv)];
        const eligible = lv>0 && lv<=maxEligible;

        // reward label: show icon + number, or ‚úì if claimed
        if(rewardEl){
          if(claimed){
            rewardEl.innerHTML = "‚úì";
            rewardEl.style.color = "#2ecc71";
            rewardEl.style.textShadow = "0 0 10px rgba(46,204,113,0.35)";
          }else if(eligible){
            rewardEl.innerHTML = `<span style="display:inline-flex;align-items:center;gap:6px;">
              <img src="https://i.postimg.cc/pXChR57C/unnamed.png" style="width:16px;height:16px;image-rendering:pixelated;">
              <span style="color:#7fffd4;">${etherRewardForLevel(lv)}</span>
            </span>`;
          }else{
            // show reward amount even if not yet eligible (muted)
            rewardEl.innerHTML = `<span style="display:inline-flex;align-items:center;gap:6px;opacity:0.55;">
              <img src="https://i.postimg.cc/pXChR57C/unnamed.png" style="width:16px;height:16px;image-rendering:pixelated;filter:grayscale(1);opacity:0.7;">
              <span style="color:#bfeee6;">${etherRewardForLevel(lv)}</span>
            </span>`;
          }
}

        // clickable claim styling
        node.style.cursor = (!claimed && eligible) ? "pointer" : "default";
        node.title = claimed ? "Gi√† riscattato" : (eligible ? "Clicca per riscattare Frammenti d'Etere" : "Non ancora disponibile");

        // prevent double listeners
        node.onclick = null;
        node.addEventListener("click", (ev)=>{
          ev.preventDefault();
          ev.stopPropagation();
          if(claimed || !eligible) return;
          const ok = claimEtherForLevel(lv, node);
          if(ok){
            // refresh just this node UI quickly
            try{
              if(rewardEl){
                rewardEl.innerHTML="‚úì";
                rewardEl.style.color="#2ecc71";
                rewardEl.style.textShadow="0 0 10px rgba(46,204,113,0.35)";
              }
              node.style.cursor="default";
              node.classList.add("done");
            }catch(e){}
          }
        }, {passive:false});
      });
    };
    return true;
  };

  if(!tryHook()){
    // retry after DOM ready
    document.addEventListener("DOMContentLoaded", ()=>{ tryHook(); });
  }
})();

/* Road button glow: verde se c'√® almeno 1 ricompensa riscattabile */
function hasAnyClaimableEther(){
  try{
    const maxEligible = (typeof accountState !== "undefined" && accountState && typeof accountState.level==="number")
      ? Math.max(1, Math.floor(accountState.level))
      : 1;
    for(let lv=1; lv<=maxEligible; lv++){
      if(!etherClaims[String(lv)]) return true;
    }
  }catch(e){}
  return false;
}
function updateRoadBtnGlow(){
  const btn=document.getElementById("accountRoadBtn");
  if(!btn) return;
  const on = hasAnyClaimableEther();
  btn.classList.toggle("ready-claim", !!on);
  btn.title = on ? "üèÜ Percorso livelli (ricompense disponibili!)" : "üèÜ Percorso livelli";
}
updateRoadBtnGlow();
setInterval(updateRoadBtnGlow, 650);


function renderUnlockButton(character){
    if(character.locked){
        return `<button onclick="unlockCharacter('${character.id}')">
                SBLOCCA (1000 Frammenti d'Etere)
                </button>`;
    }
    return "";
}

</script>

<script>
/* ===== Etere Info Popup: click su icona/numero ===== */
document.addEventListener('DOMContentLoaded', function(){
  const modal = document.getElementById('etherInfoModal');
  const closeBtn = document.getElementById('etherInfoCloseBtn');
  const hud = document.getElementById('etherHud');
  const icon = document.getElementById('etherHudIcon');
  const count = document.getElementById('etherCount');

  function openModal(){
    if(!modal) return;
    modal.classList.add('show');
    modal.style.display='flex';
    modal.setAttribute('aria-hidden','false');
  }
  function closeModal(){
    if(!modal) return;
    modal.classList.remove('show');
    modal.style.display='none';
    modal.setAttribute('aria-hidden','true');
  }

  function bind(el){
    if(!el) return;
    el.style.cursor = 'pointer';
    el.addEventListener('click', function(e){
      e.preventDefault();
      e.stopPropagation();
      openModal();
    });
  }

  bind(hud);
  bind(icon);
  bind(count);

  if(closeBtn) closeBtn.addEventListener('click', closeModal);

  // click fuori dal box chiude
  if(modal){
    modal.addEventListener('click', function(e){
      if(e.target === modal) closeModal();
    });
  }

  // ESC chiude
  document.addEventListener('keydown', function(e){
    if(e.key === 'Escape') closeModal();
  });
});

function renderUnlockButton(character){
    if(character.locked){
        return `<button onclick="unlockCharacter('${character.id}')">
                SBLOCCA (1000 Frammenti d'Etere)
                </button>`;
    }
    return "";
}

</script>

<script>
/* ===== Total Score Info Popup ===== */
document.addEventListener('DOMContentLoaded', function(){
  const modal = document.getElementById('totalScoreInfoModal');
  const closeBtn = document.getElementById('totalScoreInfoCloseBtn');
  const trigger = document.getElementById('totalScoreDisplay');

  function openModal(){
    if(!modal) return;
    modal.classList.add('show');
    modal.style.display='flex';
    modal.setAttribute('aria-hidden','false');
  }
  function closeModal(){
    if(!modal) return;
    modal.classList.remove('show');
    modal.style.display='none';
    modal.setAttribute('aria-hidden','true');
  }

  if(trigger){
    trigger.addEventListener('click', function(e){
      e.preventDefault();
      e.stopPropagation();
      openModal();
    });
  }
  if(closeBtn) closeBtn.addEventListener('click', closeModal);

  if(modal){
    modal.addEventListener('click', function(e){
      if(e.target === modal) closeModal();
    });
  }
  document.addEventListener('keydown', function(e){
    if(e.key === 'Escape') closeModal();
  });
});

function renderUnlockButton(character){
    if(character.locked){
        return `<button onclick="unlockCharacter('${character.id}')">
                SBLOCCA (1000 Frammenti d'Etere)
                </button>`;
    }
    return "";
}

</script>

<script id="cosmo-buy-logic-patch">
document.addEventListener("DOMContentLoaded", function(){

  function updateCosmoBuyButton(){
    const btn = document.getElementById("cosmoShopBuyBtn");
    const etherEl = document.getElementById("etherCount");
    if(!btn || !etherEl) return;

    const ether = parseInt(etherEl.textContent || "0");
    if(ether < 1000){
      btn.classList.add("disabled");
      btn.disabled = true;
    }else{
      btn.classList.remove("disabled");
      btn.disabled = false;
    }
  }

  const modal = document.getElementById("cosmoShopModal");
  if(modal){
    const observer = new MutationObserver(updateCosmoBuyButton);
    observer.observe(modal, {attributes:true, attributeFilter:["style","class"]});
  }

  const etherEl = document.getElementById("etherCount");
  if(etherEl){
    const observer2 = new MutationObserver(updateCosmoBuyButton);
    observer2.observe(etherEl, {childList:true});
  }

  updateCosmoBuyButton();
});
</script>

</body>



<script>
const unlockMessages = {
  voltryx: "Personaggio BLOCCATO\nSblocca facendo 45.000 punti\ncon Jimmy, Rooney e Jeff",
  kouvagia: "Personaggio BLOCCATO\nSblocca facendo 50.000 punti\ncon Voltryx",
  salsy: "Personaggio BLOCCATO\nSblocca facendo 60.000 punti\ncon tutti i personaggi precedenti",
  tempostorm: "Personaggio BLOCCATO\nSblocca facendo 65.000 punti\ncon tutti i personaggi precedenti",
  marz: "Personaggio BLOCCATO\nSblocca facendo 70.000 punti\ncon tutti i personaggi precedenti",
  hecate: "Personaggio BLOCCATO\nSblocca facendo 75.000 punti\ncon tutti i personaggi precedenti",
  lucien: "Personaggio BLOCCATO\nSblocca facendo un record con Marcus\nsuperiore a 25.000",
  pdor: "Personaggio BLOCCATO\nsi sblocca facendo 50.000\ncon marcus e lucien",
  bane: "Personaggio BLOCCATO\nSblocca facendo 50.000\ncon PDOR",
  hendel: "personaggio BLOCCATO  si sblocca facendo 50.000 con Bane",
  kaerith: "Personaggio BLOCCATO\nsi sblocca facendo 40.000 con Hendel"
  ,
  cosmo: "Personaggio BLOCCATO Sblocca acquistandolo con 1000 Frammenti d'Etere"
};

const lockBox = document.getElementById('lockMessage');
const lockText = document.getElementById('lockText');
document.getElementById('lockCloseBtn').onclick = ()=>{ try{ lockBox.style.display='none'; }catch(e){} try{ const b=document.getElementById('lockBuyBtn'); if(b){ b.style.display='none'; b.onclick=null; } }catch(e){} try{ if(lockText) lockText.innerText=''; }catch(e){} };

document.querySelectorAll('.char-grid button[data-target]').forEach(btn=>{
  btn.addEventListener('click',()=>{
    const id = btn.dataset.target;
    const card = document.getElementById('card-'+id);
    if(card && card.classList.contains('disabled') && !(id==='cosmo' && isCharPurchased('cosmo'))){
      lockText.innerText = unlockMessages[id] || "Personaggio BLOCCATO\nSblocca facendo un record di 70.000 con un personaggio";

      // show purchase button only for Cosmo
      const buyBtn=document.getElementById('lockBuyBtn');
      if(buyBtn){
        buyBtn.style.display = (id==='cosmo') ? 'inline-block' : 'none';
        if(id==='cosmo'){
          buyBtn.textContent='COMPRA (1000)';
          buyBtn.onclick = ()=>{
            const ok = tryPurchaseCosmo();
            if(ok){
              try{ lockBox.style.display='none'; }catch(e){}
              try{
                const card2=document.getElementById('card-cosmo');
                if(card2){
                  document.querySelectorAll('.character-card').forEach(c=>c.classList.remove('selected'));
                  card2.classList.add('selected');
                  selectedCharacter='cosmo';
                  updateMenuStatsDisplay('cosmo');
                }
              }catch(e){}
            }else{
              lockText.innerText = "Etere insufficiente Servono 1000 frammenti";
            }
          };
        }
      }

      lockBox.style.display = 'block';
    }
  });
});

// --- MARCUS UNLOCK: at least one character record >= 70000 ---
function updateMarcusUnlock(){
  const badge=document.getElementById('marcusLockBadge');
  const card=document.getElementById('card-marcus');
  if(!badge||!card) return;

  let maxRecord=0;
  document.querySelectorAll('.record-badge').forEach(r=>{
    const v=parseInt(r.textContent.replace(/[^0-9]/g,''))||0;
    if(v>maxRecord) maxRecord=v;
  });

  if(maxRecord>=70000){
    card.classList.remove('disabled');
    if(badge) badge.style.display='none';
  }
}
setInterval(updateMarcusUnlock,500);


// --- Ensure MARCUS selection behaves like others ---
document.querySelectorAll('.char-grid button[data-target]').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    const target = btn.dataset.target;
    const card = document.getElementById('card-'+target);
    if(!card || card.classList.contains('disabled')) return;

    document.querySelectorAll('.character-card').forEach(c=>c.classList.remove('selected'));
    card.classList.add('selected');
    selectedCharacter = target;
  });
});


function renderUnlockButton(character){
    if(character.locked){
        return `<button onclick="unlockCharacter('${character.id}')">
                SBLOCCA (1000 Frammenti d'Etere)
                </button>`;
    }
    return "";
}

</script>


<!-- === COSMO PURCHASE POPUP FIX (v39) === -->
<script>
document.addEventListener('DOMContentLoaded', function(){
  const COSMO_PURCHASE_KEY = "pf_purchase_cosmo_v1";
  const COSMO_COST = 1000;

  function isCosmoUnlocked(){
  try{
    // Prefer the unified purchases registry if present
    if(typeof isCharPurchased === 'function'){
      try{ if(isCharPurchased('cosmo')) return true; }catch(e){}
    }
    // Fallback to legacy key (if any)
    return localStorage.getItem(COSMO_PURCHASE_KEY) === "1";
  }catch(e){
    return false;
  }
}

function setCosmoUnlocked(){
    try{ localStorage.setItem(COSMO_PURCHASE_KEY, "1"); }catch(e){}
  }

  function applyCosmoUI(){
    const card = document.getElementById('card-cosmo');
    const badge = document.getElementById('cosmoLockBadge');
    const btn = document.querySelector('.char-grid button[data-target="cosmo"]');
    const unlocked = isCosmoUnlocked();

    if(card){
      if(unlocked) card.classList.remove('disabled');
      else card.classList.add('disabled');
    }
    if(badge){
      badge.style.display = unlocked ? 'none' : 'block';
    }
    if(btn){
      if(unlocked){
        btn.classList.remove('locked');
      }else{
        btn.classList.add('locked'); // keep clickable (we intercept click)
        btn.disabled = false;
      }
    }
  }

  function openCosmoLockPopup(){
    const lockBox = document.getElementById('lockMessage');
    const lockText = document.getElementById('lockText');
    const buyBtn = document.getElementById('lockBuyBtn');
    if(!lockBox || !lockText) return;

    lockText.innerText = "Personaggio BLOCCATO Sblocca acquistandolo con " + COSMO_COST + " Frammenti d'Etere";
    if(buyBtn){
      buyBtn.style.display = 'inline-block';
      buyBtn.textContent = "COMPRA (" + COSMO_COST + ")";
      buyBtn.onclick = function(){
        if(tryPurchaseCosmo()){
          try{ lockBox.style.display='none'; }catch(e){}
          // auto-select after purchase (optional, keeps UX smooth)
          try{
            const gridBtn = document.querySelector('.char-grid button[data-target="cosmo"]');
            if(gridBtn){
              document.querySelectorAll('.char-grid button').forEach(b=>b.classList.remove('selected'));
              gridBtn.classList.add('selected');
            }
            // sync selection state
            if(typeof window.selectedCharacter !== 'undefined') window.selectedCharacter = 'cosmo';
            if(typeof selectedCharacter !== 'undefined') selectedCharacter = 'cosmo';
            if(typeof updateMenuStatsDisplay === "function") updateMenuStatsDisplay('cosmo');
          }catch(e){}
        }else{
          lockText.innerText = "Etere insufficiente Servono " + COSMO_COST + " frammenti";
        }
      };
    }
    lockBox.style.display = 'block';
  }

  function tryPurchaseCosmo(){
    try{
      // 'ether' is the game's currency variable in this file
      const current = Math.max(0, Math.floor(Number(window.ether) || Number(ether) || 0));
      if(current < COSMO_COST) return false;

      const next = current - COSMO_COST;

      // write back to both window.ether and local scope if present
      try{ window.ether = next; }catch(e){}
      try{ ether = next; }catch(e){}

      // persist via existing helpers
      if(typeof saveEther === "function") saveEther();
      if(typeof updateEther === "function") updateEther();

      setCosmoUnlocked();
      applyCosmoUI();
      return true;
    }catch(e){
      return false;
    }
  }

  // initial UI sync
  applyCosmoUI();

  // Intercept COSMO click in CAPTURE phase so other handlers can't swallow it
  document.querySelectorAll('.char-grid button[data-target="cosmo"]').forEach(function(btn){
    btn.addEventListener('click', function(e){
      if(isCosmoUnlocked()) return; // allow normal selection flow
      e.preventDefault();
      e.stopPropagation();
      e.stopImmediatePropagation();
      openCosmoLockPopup();
    }, true);
  });

  // Also intercept potential clicks on the hidden big card (safety)
  const cosmoCard = document.getElementById('card-cosmo');
  if(cosmoCard){
    cosmoCard.addEventListener('click', function(e){
      if(isCosmoUnlocked()) return;
      e.preventDefault();
      e.stopPropagation();
      openCosmoLockPopup();
    }, true);
  }

  // When closing popup, ensure buy button hides (avoid stale)
  const closeBtn = document.getElementById('lockCloseBtn');
  if(closeBtn){
    closeBtn.addEventListener('click', function(e){
      try{ e.preventDefault(); e.stopPropagation(); }catch(err){}
      try{ const lockBox = document.getElementById('lockMessage'); if(lockBox) lockBox.style.display='none'; }catch(err){}
      try{ const buyBtn = document.getElementById('lockBuyBtn'); if(buyBtn) buyBtn.style.display='none'; }catch(err){}
    });
  }
});
</script>

</html>
