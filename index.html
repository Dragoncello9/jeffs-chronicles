<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Platform Fighter - Complete</title>
  <!-- Link ai font da Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=VT323&display=swap" rel="stylesheet">
  <style>
    *{margin:0;padding:0;box-sizing:border-box}
    html,body{height:100%}
    body{
      font-family:'VT323', monospace; /* Font di gioco */
      background:#000;
      color:#fff;
      display:flex;
      justify-content:center;
      align-items:center;
      height:100vh;
      overflow:hidden;
      position:relative;
    }

    #bgDefault,#bgDark{
      position:absolute;left:0;top:0;width:100%;height:100%;
      background-size:cover;background-position:center;
      transition:opacity 900ms ease;z-index:0;pointer-events:none
    }
    #bgDefault{opacity:1}
    #bgDark{opacity:0}

    #fadeOverlay{position:absolute;left:0;top:0;width:100%;height:100%;background:#000;opacity:0;transition:opacity 650ms ease;z-index:3;pointer-events:none}

    #gameContainer{
      position:relative;width:1200px;height:700px;
      max-width:calc(100vw - 40px);max-height:calc(100vh - 40px);
      z-index:2;display:flex;justify-content:center;align-items:center
    }

    #gameCanvas{
      background:transparent;border:4px solid #fff;
      box-shadow:0 0 30px rgba(255,255,255,0.5);
      image-rendering:pixelated;display:block
    }

    .ui-overlay{position:absolute;top:18px;left:18px;z-index:10;text-shadow:2px 2px 4px #000}

    .hp-bar{width:200px;height:30px;background:#333;border:3px solid #fff;margin-top:8px;position:relative}
    .hp-fill{height:100%;background:linear-gradient(90deg,#e74c3c,#c0392b);transition:width 0.25s}

    .score{position:absolute;top:18px;right:18px;color:#f39c12;font-size:22px;text-shadow:2px 2px 4px #000;z-index:10}
    .timer{position:absolute;top:18px;left:50%;transform:translateX(-50%);font-size:32px;color:#f39c12;text-shadow:2px 2px 4px #000;z-index:10}
    .level-indicator{position:absolute;top:60px;left:50%;transform:translateX(-50%);font-size:18px;z-index:10}
    .super-cooldown{position:absolute;top:100px;left:18px;font-size:14px;color:#f39c12;z-index:10}

    .menu,.end-screen{
      position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);
      background:rgba(0,0,0,0.9);padding:30px;border:4px solid #fff;
      text-align:center;z-index:20;width:calc(100% - 80px);max-width:760px;
      font-family:'Press Start 2P', cursive; /* Font menu */
    }

    .menu h1,.end-screen h1{
      font-size:38;color:#e74c3c;text-shadow:3px 3px 6px #000;margin-bottom:12px
    }

    .character-select{display:flex;gap:16px;justify-content:center;margin:18px 0;flex-wrap:wrap}

    /* Ridotte leggermente le card personaggio per evitare sovrapposizioni */
    .character-card{
      background:#222;border:3px solid #555;padding:12px;
      width:180px; /* ridotta da 200px a 180px */
      cursor:pointer;transition:all .2s;position:relative;
      display:flex;flex-direction:column;align-items:center;
    }
    .character-card:hover{transform:scale(1.03);border-color:#e74c3c}
    .character-card.selected{border-color:#f39c12;background:#333}
    .character-card.disabled{ filter:grayscale(1); opacity:0.55; cursor:not-allowed; }

    /* Immagine personaggio pi√π piccola per evitare sovrapposizioni */
    .character-card img{
      width:110px; /* dimensione immagine ridotta */
      height:auto;
      display:block;
      image-rendering:pixelated;
      margin-bottom:8px;
    }

    /* Riquadro attorno al "tasto" per selezionare il personaggio */
    .character-card .select-btn{
      display:inline-block;
      border:3px solid #fff; /* riquadro visibile */
      padding:8px 10px;
      margin-top:10px;
      background:transparent;
      color:#fff;
      font-family:'Press Start 2P', cursive;
      font-size:12px;
      text-decoration:none;
      cursor:pointer;
    }
    .character-card .select-btn:active{transform:translateY(1px)}

    /* Riquadro leggermente pi√π grande per il nome (evita sovrapposizione con record) */
    .character-card .name-box{
      min-height:34px; /* ingrandito per non sovrapporre il record */
      padding:6px 8px;
      width:100%;
      text-align:center;
      font-size:13px;
      color:#fff;
      background:rgba(0,0,0,0.15);
      border:2px solid rgba(255,255,255,0.06);
      margin-bottom:6px;
      box-sizing:border-box;
    }

    /* Posizionamento del record: sotto il nome del personaggio, non assoluto */
    .record-badge{
      position:static; /* rimosso absolute per evitare sovrapposizioni */
      margin-top:6px;
      font-size:11px;
      color:#ccc;
      background:transparent;
      z-index:2;
    }

    .lock-badge{
      position:absolute;top:8px;right:8px;
      font-size:12px;color:#f39c12;background:#000;padding:3px 6px;border:1px solid #f39c12
    }

    .btn{ background:#e74c3c;color:#fff;border:none;padding:10px 22px; font-size:16px;cursor:pointer;margin:8px; font-family:'Press Start 2P', cursive; /* Bottoni in stile menu */ }

    .damage-number{position:absolute;font-size:20px;font-weight:bold;color:#e74c3c;text-shadow:2px 2px 4px #000;pointer-events:none;animation:floatUp 1s ease-out forwards;z-index:200}
    @keyframes floatUp{to{transform:translateY(-50px);opacity:0}}

    .pickup-label{position:absolute;font-size:14px;color:#fff;text-shadow:2px 2px 4px #000}
    .menu-stats{font-size:13px;color:#ddd;margin-top:8px}

    @media (max-width:900px){
      #gameContainer{width:900px;height:525px}
      .menu,.end-screen{width:calc(100% - 40px);max-width:680px}
    }
/* Pulsante immagine stile */
.img-btn{
  background:transparent;border:0;padding:6px;cursor:pointer;display:inline-flex;
  align-items:center;justify-content:center;transition:transform 160ms ease, box-shadow 160ms ease;
}
.img-btn img{
  width:72px;height:72px;display:block;image-rendering:pixelated;
  border:3px solid #fff;border-radius:8px;transition:transform 160ms ease, box-shadow 160ms ease;
}
.img-btn:hover img{transform:scale(1.08);box-shadow:0 6px 18px rgba(0,0,0,0.6);}

/* Modale guida */
.guide-modal{
  position:fixed;left:0;top:0;width:100%;height:100%;
  background:rgba(0,0,0,0.75);display:flex;justify-content:center;align-items:center;
  z-index:60;padding:20px;
}
.guide-modal-content{
  background:rgba(10,10,10,0.98);border:4px solid #fff;max-width:980px;width:100%;max-height:90vh;
  overflow:auto;padding:22px;font-family:'VT323', monospace;color:#fff;position:relative;
  box-shadow:0 0 30px rgba(0,0,0,0.8);
}
.guide-close{
  position:absolute;right:12px;top:12px;background:transparent;border:2px solid #fff;color:#fff;
  width:36px;height:36px;border-radius:4px;cursor:pointer;font-size:18px;
}
.guide-body h3{color:#f39c12;margin-top:12px}
.guide-body p, .guide-body ul{font-size:14px;line-height:1.45;color:#ddd}
.guide-body ul{margin-left:18px}
@media (max-width:900px){
  .guide-modal-content{max-width:calc(100% - 20px);padding:14px}
  .guide-body p{font-size:13px}
}
  </style>
</head>
<body>
<div id="bgDefault"></div>
<div id="bgDark"></div>
<div id="fadeOverlay"></div>
<div id="gameContainer">
  <canvas id="gameCanvas" width="1200" height="700"></canvas>

  <div class="ui-overlay" id="uiOverlay" style="display:none;">
    <div>HP: <span id="hpText">100</span></div>
    <div class="hp-bar"><div id="hpFill" class="hp-fill" style="width:100%"></div></div>
    <div style="margin-top:6px;">Buff Attacco: <span id="atkBuffDisplay">0s</span></div>
  </div>

  <div class="score" id="scoreDisplay" style="display:none;">Score: 0</div>
  <div class="timer" id="timerDisplay" style="display:none;">45</div>
  <div class="level-indicator" id="levelDisplay" style="display:none;">Level 1</div>
  <div class="super-cooldown" id="superCooldown" style="display:none;">Super: Ready</div>

  <div class="menu" id="mainMenu">
    <h1>‚öîÔ∏è JEFF‚ÄôS CHRONICLES‚öîÔ∏è</h1>
    <h2>Seleziona il tuo combattente</h2>

    <div class="character-select">
      <div class="character-card" data-char="jimmy" id="card-jimmy">
        <h3>JIMMY</h3>
        <p>"üî´"</p>
        <div class="menu-stats">HP: <span id="menu-hp-jimmy">-</span> Danno: <span id="menu-dmg-jimmy">-</span></div>
        <div class="record-badge" id="record-jimmy">Record: 0</div>
      </div>

      <div class="character-card" data-char="rooney" id="card-rooney">
        <h3>ROONEY</h3>
        <p>"üê±"</p>
        <div class="menu-stats">HP: <span id="menu-hp-rooney">-</span> Danno: <span id="menu-dmg-rooney">-</span></div>
        <div class="record-badge" id="record-rooney">Record: 0</div>
      </div>

      <div class="character-card" data-char="jeff" id="card-jeff">
        <h3>JEFF</h3>
        <p>"üó°Ô∏è"</p>
        <div class="menu-stats">HP: <span id="menu-hp-jeff">-</span> Danno: <span id="menu-dmg-jeff">-</span></div>
        <div class="record-badge" id="record-jeff">Record: 0</div>
      </div>

      <!-- Voltryx card (locked until all three records > 50000) -->
      <div class="character-card disabled" data-char="voltryx" id="card-voltryx" title="Sblocca completando 50.000 punti con ogni personaggio">
        <h3>VOLTRYX</h3>
        <p>"ü¶ä"</p>
        <div class="menu-stats">HP: <span id="menu-hp-voltryx">-</span> Danno: <span id="menu-dmg-voltryx">-</span></div>
        <div class="record-badge" id="record-voltryx">Record: 0</div>
        <div class="lock-badge" id="voltryxLockBadge">LOCKED</div>
      </div>


      <!-- Kouvagia card (locked until 51.000 score with Voltryx) -->
      <div class="character-card disabled" data-char="kouvagia" id="card-kouvagia" title="Sblocca facendo 51.000 punti con Voltryx">
        <h3>KOUVAGIA</h3>
        <p>"ü¶â"</p>
        <div class="menu-stats">HP: <span id="menu-hp-kouvagia">-</span> Danno: <span id="menu-dmg-kouvagia">-</span></div>
        <div class="record-badge" id="record-kouvagia">Record: 0</div>
        <div class="lock-badge" id="kouvagiaLockBadge">LOCKED</div>
      </div>

      <!-- Salsy card (locked until 70.000 score with Jimmy, Rooney, Jeff, Voltryx and Kouvagia) -->
      <div class="character-card disabled" data-char="salsy" id="card-salsy" title="Sblocca facendo 70.000 punti con Jimmy, Rooney, Jeff, Voltryx e Kouvagia">
        <h3>SALSY</h3>
        <p>"‚öúÔ∏è"</p>
        <div class="menu-stats">HP: <span id="menu-hp-salsy">-</span> Danno: <span id="menu-dmg-salsy">-</span></div>
        <div class="record-badge" id="record-salsy">Record: 0</div>
        <div class="lock-badge" id="salsyLockBadge">LOCKED</div>
      </div>

    
    </div>

    <button class="btn" id="startBtn">INIZIA BATTAGLIA</button>
<!-- Pulsante immagine per aprire la guida -->
<button id="guideImgBtn" class="img-btn" aria-label="Apri guida" title="Apri guida" type="button" style="display:inline-block;">
  <img id="guideImg" src="https://i.postimg.cc/JztT9fJH/bea.png " alt="Guida" />
</button>
    <p style="margin-top:12px;font-size:15px;color:#ddd">Controlli: WASD - Muovi | J - Attacco | K - Super Mossa | Spazio - Schivata</p>
  </div>

  <div class="end-screen" id="endScreen" style="display:none;">
    <h1 id="endTitle">GAME OVER</h1>
    <p id="endMessage">Score Finale: 0</p>
    <p id="endSub">Hai raggiunto il Livello 1</p>
    <p id="recordMessage">Record Personaggio: 0</p>
    <button class="btn" id="restartBtn">RIPROVA</button>
    <button class="btn" id="menuBtn">TORNA AL MENU</button>
  </div>
</div>
<!-- Modale guida -->
<div id="guideModal" class="guide-modal" aria-hidden="true" role="dialog" aria-labelledby="guideTitle" style="display:none;">
  <div class="guide-modal-content" role="document">
    <button class="guide-close" id="guideClose" aria-label="Chiudi guida">‚úï</button>
    <h2 id="guideTitle">Guida completa a Jeff‚Äôs Chronicles</h2>
    <div class="guide-body">

      <h3>üìò GUIDA COMPLETA ‚Äì JEFF‚ÄôS CHRONICLES</h3>

      <h3>1) PANORAMICA GENERALE</h3>
      <p><strong>Jeff‚Äôs Chronicles</strong> √® un arena-fighter a schermo fisso. Il giocatore sceglie un combattente e affronta ondate di nemici e boss all‚Äôinterno di un‚Äôarena chiusa, cercando di ottenere il punteggio pi√π alto possibile prima della fine del tempo.</p>
      <p>Il gioco combina: azione rapida, gestione dei cooldown, uso intelligente di dash, super e pickup, progressione tramite record personali. Ogni partita √® diversa grazie alla variet√† di nemici, livelli e potenziamenti.</p>

      <h3>2) OBIETTIVO, LIVELLI E PUNTEGGIO</h3>
      <p><strong>Obiettivo del livello</strong>: eliminare tutti i nemici presenti nell‚Äôarena e sopravvivere fino allo scadere del tempo.</p>
      <p><strong>Livelli</strong>: cambiano per tipo di nemici, numero di avversari, tempo disponibile e presenza di boss. La difficolt√† aumenta progressivamente.</p>
      <p><strong>Punteggio</strong>: ogni nemico ucciso fornisce <strong>+100 √ó livello corrente</strong>. Subire danno comporta <strong>‚àí50 punti</strong> (il punteggio non scende mai sotto zero). I livelli avanzati permettono di ottenere score molto pi√π elevati.</p>

      <h3>3) CONTROLLI</h3>
      <ul>
        <li><strong>W A S D</strong> ‚Üí Movimento</li>
        <li><strong>J</strong> ‚Üí Attacco base</li>
        <li><strong>K</strong> ‚Üí Super mossa</li>
        <li><strong>Spazio</strong> ‚Üí Dash / Schivata</li>
      </ul>

      <h3>4) INTERFACCIA (HUD)</h3>
      <p>Durante la partita sono sempre visibili: HP e barra della vita, timer del livello, livello corrente, cooldown della super, punteggio totale e indicatori di buff attivi. Tenere d‚Äôocchio il timer e la super √® fondamentale per sopravvivere nei livelli avanzati.</p>

      <h3>5) MOVIMENTO E DASH</h3>
      <p>Il movimento √® libero in 8 direzioni.</p>
      <p><strong>Dash / Schivata</strong>: √® uno scatto rapido che rende pi√π difficile essere colpiti. Ha un cooldown breve. Serve per evitare attacchi corpo a corpo, schivare proiettili e laser e riposizionarsi rapidamente. Alcuni personaggi hanno dash pi√π lunghi o pi√π veloci rispetto ad altri.</p>

      <h3>6) ATTACCO BASE</h3>
      <p>Ogni personaggio ha: un tipo di attacco unico, un range specifico e un cooldown personale. Il gioco utilizza un aim-assist leggero: quando attacchi, il personaggio tende a orientarsi verso il nemico pi√π vicino per rendere i colpi pi√π fluidi.</p>

      <h3>7) SUPER MOSSA</h3>
      <p>Ogni personaggio possiede una super unica. Le super hanno cooldown lunghi. Possono colpire pi√π nemici, marchiare bersagli o creare zone di danno. Usarle nel momento giusto √® la chiave per superare i livelli pi√π difficili.</p>

      <h3>8) DIFESA, SCUDI E STATUS</h3>
      <p><strong>Scudi</strong>: alcuni personaggi possiedono scudi con durabilit√†. Esistono pickup che forniscono invulnerabilit√† temporanea.</p>
      <p><strong>Status negativi</strong>: <strong>Poison</strong> (perdita di HP nel tempo). I danni da status possono uccidere se non gestiti.</p>

      <h3>9) PICKUP E POTENZIAMENTI</h3>
      <p>I pickup iniziano a comparire nei livelli avanzati.</p>
      <ul>
        <li><strong>Heal</strong>: cura il 25% degli HP massimi.</li>
        <li><strong>Atk</strong>: aumenta il danno per alcuni secondi.</li>
        <li><strong>Super</strong>: ricarica immediatamente la super.</li>
        <li><strong>Speed</strong>: aumenta la velocit√† di movimento.</li>
        <li><strong>Shield</strong>: invulnerabilit√† temporanea.</li>
        <li><strong>Gold</strong>: cura totale + grande aumento del danno + super pronta.</li>
        <li><strong>Malus</strong>: applica poison.</li>
      </ul>
      <p>Usare correttamente i pickup pu√≤ ribaltare completamente una partita.</p>

      <h3>10) PERSONAGGI ‚Äì FUNZIONALIT√Ä E MECCANICHE</h3>

      <h4>üî´ JIMMY </h4>
      <p><strong>Ruolo</strong>: inseguimento e eliminazione rapida di bersagli.</p>
      <p><strong>Attacco base (Grapple)</strong>: Jimmy aggancia automaticamente un nemico vicino. Finch√© √® agganciato, lo insegue in modo automatico. Quando lo raggiunge, infligge danni elevati. Se il bersaglio muore o scompare, il grapple termina.</p>
      <p><strong>Scudo a durabilit√†</strong>: durante gli attacchi Jimmy attiva uno scudo. Ogni colpo assorbito consuma 1 punto di durabilit√†. Quando la durabilit√† √® zero, lo scudo si rompe e smette di funzionare temporaneamente.</p>
      <p><strong>Super</strong>: seleziona pi√π bersagli. Jimmy li insegue uno dopo l‚Äôaltro colpendoli con danni potenziati. Durante la super √® molto pi√π difficile da fermare.</p>
      <p><strong>Passiva ‚Äì Jetpack</strong>: ogni tot secondi si attiva automaticamente. Fornisce aumento di velocit√† e garantisce maggiore sicurezza nei movimenti.</p>
      <p><strong>Stile consigliato</strong>: aggressivo e mobile.</p>

      <h4>üê± ROONEY</h4>
      <p><strong>Ruolo</strong>: resistenza e danni ravvicinati.</p>
      <p><strong>Attacco base</strong>: serie di pugni potenti a corto raggio. Ottimo contro nemici lenti o raggruppati.</p>
      <p><strong>Super</strong>: colpo ad area intorno a Rooney. Danni elevati distribuiti su pi√π nemici. Ideale contro ondate numerose.</p>
      <p><strong>Stile consigliato</strong>: restare vicino ai nemici e controllare lo spazio.</p>

      <h4>üó°Ô∏è JEFF </h4>
      <p><strong>Ruolo</strong>: controllo dell‚Äôarena.</p>
      <p><strong>Attacco base</strong>: fendente ad arco con la spada. Buona velocit√† e affidabilit√†.</p>
      <p><strong>Super</strong>: crea una grande area intorno a Jeff. Infligge danni periodici a tutti i nemici all‚Äôinterno. Molto efficace contro boss e gruppi.</p>
      <p><strong>Stile consigliato</strong>: posizionamento intelligente.</p>

      <div id="guide-voltryx-locked" style="margin-top:10px;padding:10px;border:2px dashed rgba(255,255,255,0.35);background:rgba(255,255,255,0.05);">
        <h4>ü¶ä VOLTRYX </h4>
        <p><em>Questo personaggio √® bloccato. La descrizione apparir√† automaticamente appena lo sblocchi.</em></p>
      </div>
      <div id="guide-voltryx" style="display:none;">
        <h4>ü¶ä VOLTRYX </h4>
        <p><strong>Ruolo</strong>: versatilit√† totale.</p>
        <p><strong>Attacco base</strong>: da lontano spara un proiettile energetico ad area; da vicino esegue due pugni rapidi.</p>
        <p><strong>Super</strong>: genera una sfera energetica che rilascia impulsi di danno ad area, colpendo ripetutamente i nemici nel raggio.</p>
        <p><strong>Stile consigliato</strong>: alternare distanza e mischia.</p>
        <p><strong>Sblocco</strong>: oltre 50.000 punti con Jimmy, Rooney e Jeff.</p>
      </div>

      <div id="guide-kouvagia-locked" style="margin-top:10px;padding:10px;border:2px dashed rgba(255,255,255,0.35);background:rgba(255,255,255,0.05);">
        <h4>ü¶â KOUVAGIA </h4>
        <p><em>Questo personaggio √® bloccato. La descrizione apparir√† automaticamente appena lo sblocchi.</em></p>
      </div>
      <div id="guide-kouvagia" style="display:none;">
        <h4>ü¶â KOUVAGIA </h4>
        <p><strong>Ruolo</strong>: sopravvivenza e danni da contatto.</p>
        <p><strong>Attacco base</strong>: dash offensivo che infligge danni ai nemici attraversati. Al termine del dash esplode infliggendo danni ad area.</p>
        <p><strong>Passiva ‚Äì Dash offensivo</strong>: ogni schivata infligge danni ai nemici vicini.</p>
        <p><strong>Passiva ‚Äì Cura su uccisione</strong>: ogni nemico ucciso a distanza ravvicinata cura Kouvagia.</p>
        <p><strong>Super</strong>: cura completa e genera un‚Äôonda che respinge i nemici.</p>
        <p><strong>Stile consigliato</strong>: usare spesso il dash e restare nel caos.</p>
        <p><strong>Sblocco</strong>: 51.000 punti con Voltryx.</p>
      </div>

      <div id="guide-salsy-locked" style="margin-top:10px;padding:10px;border:2px dashed rgba(255,255,255,0.35);background:rgba(255,255,255,0.05);">
        <h4>‚öúÔ∏è SALSY </h4>
        <p><em>Questo personaggio √® bloccato. La descrizione apparir√† automaticamente appena lo sblocchi.</em></p>
      </div>
      <div id="guide-salsy" style="display:none;">
        <h4>‚öúÔ∏è SALSY </h4>
        <p><strong>Ruolo</strong>: burst damage e controllo dei bersagli.</p>
        <p><strong>Attacco base</strong>: doppio fendente consecutivo. Pu√≤ colpire lo stesso nemico due volte con un singolo attacco.</p>
        <p><strong>Super ‚Äì Marchio</strong>: marchia fino a 3 nemici. I nemici marchiati subiscono danni raddoppiati per alcuni secondi.</p>
        <p><strong>Passiva ‚Äì Boost velocit√†</strong>: periodicamente ottiene un aumento temporaneo di velocit√†, perfetto per entrare e uscire dai combattimenti.</p>
        <p><strong>Stile consigliato</strong>: colpisci, marchia e ritirati.</p>
        <p><strong>Sblocco</strong>: 70.000 punti con tutti gli altri personaggi.</p>
      </div>

      <h3>11) NEMICI E PERICOLI</h3>
      <p>Nemici melee, veloci, resistenti e a distanza. Nemici con poison. Nemici con laser che richiedono schivata precisa. Boss con attacchi speciali e grandi quantit√† di HP.</p>

      <h3>12) CONSIGLI FINALI</h3>
      <ul>
        <li>Usa il dash pi√π spesso di quanto pensi.</li>
        <li>Le super vanno usate nei momenti critici.</li>
        <li>Evitare danni √® importante anche per il punteggio.</li>
        <li>Ogni personaggio √® forte se usato nel modo giusto.</li>
      </ul>

      <h3>üèÅ CONCLUSIONE</h3>
      <p><strong>Jeff‚Äôs Chronicles</strong> premia abilit√†, strategia e conoscenza dei personaggi. Impara i loro meccanismi, sfrutta i pickup e punta al record massimo.</p>

    </div>
  </div>
</div>
      
<script>
const HP_MULT=1.40;
const DAMAGE_MULT=0.85;
const SUPER_DAMAGE_MULT=0.8;
const JEFF_SUPER_RADIUS=Math.round(320*0.8);
const GOLD_PROB=0.10;
const JEFF_ATTACK_RANGE_MULT=0.8;
const JIMMY_SUPER_ADDITIONAL_MULT=0.85;
const JIMMY_BASE_ADDITIONAL_MULT=1.10;

const URL_DEFAULT='https://i.postimg.cc/8CBFTKs4/Progetto-senza-titolo.png';
const URL_DARK='https://i.postimg.cc/JhpWH3jJ/Copilot-20251209-232827.png';


const URL_FINAL='https://i.postimg.cc/pTHFKHgz/Progetto-senza-titolo-(2).png';
const canvas=document.getElementById('gameCanvas');
const ctx=canvas.getContext('2d');

const bgDefault=document.getElementById('bgDefault');
const bgDark=document.getElementById('bgDark');
const fadeOverlay=document.getElementById('fadeOverlay');
let _bgTier=0; // 0=default,1=dark,2=final

bgDefault.style.backgroundImage=`url('${URL_DEFAULT}')`;
bgDark.style.backgroundImage=`url('${URL_DARK}')`;
bgDefault.style.backgroundSize=bgDark.style.backgroundSize='cover';
bgDefault.style.backgroundPosition=bgDark.style.backgroundPosition='center';

let gameState='menu';
let selectedCharacter=null;
let player=null;
let currentLevel=0;
let score=0;
let timer=45;
let enemies=[];
let particles=[];
let pickups=[];
let projectiles=[];

let lasers=[];
let keys={};
let lastSecondTick=Date.now();
let levelAdvanceLock=false;
let shakeAmount=0;

const images={rooney:new Image(),jimmy:new Image(),jeff:new Image(),voltryx:new Image(),kouvagia:new Image(),salsy:new Image()};
images.rooney.src='https://i.postimg.cc/d3C41cds/pixelcut-export.png';
images.jimmy.src='https://i.postimg.cc/7LD8rXpW/pixelcut-export-(1).png';
images.jeff.src='https://i.postimg.cc/26GB7cDQ/image.png';
images.voltryx.src='https://i.postimg.cc/6Qhqq2Mv/Voltryx.png';
images.kouvagia.src='https://i.postimg.cc/26DT9cQH/Kouvagia.png';
images.salsy.src='https://i.ibb.co/20zSkjsB/salsy.png';
// --- Pickup images (keep pickup size small; same dimensions already used) ---
const pickupImgs={
  heal: new Image(),
  shield: new Image(),
  speed: new Image(),
  atk: new Image(),
  super: new Image(),
  gold: new Image(),
  malus: new Image(),
};
pickupImgs.heal.src='https://i.postimg.cc/c4jNccLC/heal.png';
pickupImgs.shield.src='https://i.postimg.cc/9XnS3QHh/shield.png';
pickupImgs.speed.src='https://i.postimg.cc/DzCV8QHb/speed.png';
pickupImgs.atk.src='https://i.postimg.cc/cHjVcxsS/ATK.png';
pickupImgs.super.src='https://i.postimg.cc/3rss4xSD/Super.png';
pickupImgs.gold.src='https://i.postimg.cc/wjVZGc6h/gold.png';
pickupImgs.malus.src='https://i.postimg.cc/tT1cJKFm/malus.png';

function getPickupImage(type){
  // internal type names
  const key = (type==='shieldPickup') ? 'shield' : type;
  return pickupImgs[key] || null;
}
 
const enemyImages={
  slime:new Image(),drone:new Image(),boss1:new Image(),mech:new Image(),
  shadow:new Image(),boss2:new Image(),shooter:new Image(),attacker:new Image(),boss3:new Image(),
  veleno:new Image(),oneyes:new Image(),boss4:new Image()
};
enemyImages.slime.src='https://i.postimg.cc/NFVhJNLC/pixelcut-export-(2).png';
enemyImages.drone.src='https://i.postimg.cc/13x9HtxZ/image-(1).png';
enemyImages.boss1.src='https://i.postimg.cc/gj2Ycc5Z/boss1.png';
enemyImages.mech.src='https://i.postimg.cc/zvyGSXkT/mech.png';
enemyImages.shadow.src='https://i.postimg.cc/zGvYyP0s/shadow.png';
enemyImages.boss2.src='https://i.postimg.cc/htLT7pv1/boss2.png';
enemyImages.shooter.src='https://i.postimg.cc/ZnmCZhPN/shooter.png';
enemyImages.attacker.src='https://i.postimg.cc/pdtNsXPz/attacker.png';
enemyImages.boss3.src='https://i.postimg.cc/P5S3wXPJ/boss3.png';


enemyImages.veleno.src='https://i.postimg.cc/3xNWGRWY/veleno.png';
enemyImages.oneyes.src='https://i.postimg.cc/g2xkJTBG/oneyes.png';
enemyImages.boss4.src='https://i.postimg.cc/2n4Q7r0B/boss4.png';
const characterStats={
  jimmy:{
    hp:255,
    speed:8*0.75,
    damage:47,
    range:600,
    cooldown:800,
    name:'Jimmy',
    attackType:'grapple',
    superCooldown:7000,
    superDuration:3000
  },
  rooney:{
    hp:360,
    speed:6*0.75,
    damage:Math.round(80*DAMAGE_MULT),
    range:150,
    cooldown:520,
    name:'Rooney',
    attackType:'punch',
    superCooldown:13000,
    superDuration:750
  },
  jeff:{
    hp:270, 
    speed:7*0.75,
    damage:Math.round(57*DAMAGE_MULT), // 38
    range:Math.round(320*JEFF_ATTACK_RANGE_MULT),
    cooldown:700,
    name:'Jeff',
    attackType:'sword',
    superCooldown:11000,
    superDuration:2800
  },
  voltryx:{
    hp:280, 
    speed:9*0.75,               
    damage:Math.round(52*DAMAGE_MULT),
    range:Math.round(600), 
    cooldown:650,
    name:'Voltryx',
    attackType:'hybrid',
    superCooldown:9000,
    superDuration:1700 
  },
  kouvagia:{
    hp:310,
    speed:7*0.75,
    damage:55,
    range:220,
    cooldown:760,
    name:'Kouvagia',
    attackType:'kouvagia',
    superCooldown:14000,
    superDuration:650
  },
  salsy:{
    hp:270,
    speed:7.9*0.75,  // leggermente pi√π veloce di prima
    damage:33,       // per colpo (x2)
    range:280,       // medio ravvicinata
    cooldown:770,
    name:'Salsy',
    attackType:'salsySword',
    superCooldown:8000,
    superDuration:400
  }
};

const levelConfigs=[
  {enemyType:'slime',enemyHP:45,enemyDamage:9,enemySpeed:2*0.75,time:45,enemyCount:4},
  {enemyType:'slime',enemyHP:50,enemyDamage:10,enemySpeed:2*0.75,time:45,enemyCount:9 },
  {enemyType:'drone',enemyHP:40,enemyDamage:11,enemySpeed:3*0.75,time:40,enemyCount:6},
  {enemyType:'drone',enemyHP:40,enemyDamage:12,enemySpeed:3*0.75,time:40,enemyCount:7},
  {enemyType:'boss1',enemyHP:150,enemyDamage:20,enemySpeed:2.8*0.75,time:60,enemyCount:1},
  {enemyType:'mech',enemyHP:60,enemyDamage:16,enemySpeed:2.5*0.75,time:35,enemyCount:7},
  {enemyType:'shadow',enemyHP:50,enemyDamage:17,enemySpeed:4*0.75,time:30,enemyCount:6},
  {enemyType:'shadow',enemyHP:52,enemyDamage:18,enemySpeed:4 *0.75,time:30,enemyCount:6},
  {enemyType:'mech',enemyHP:65,enemyDamage:16,enemySpeed:2.5*0.75,time:35,enemyCount:8},
  {enemyType:'boss2',enemyHP:300,enemyDamage:27,enemySpeed:3*0.75,time:60,enemyCount:1},
  {enemyType:'shooter',enemyHP:45,enemyDamage:20,enemySpeed:2.5*0.75,time:45,enemyCount:5},
  {enemyType:'shooter',enemyHP:45,enemyDamage:21,enemySpeed:2.7*0.75,time:45,enemyCount:7},
  {enemyType:'attacker',enemyHP:90,enemyDamage:17,enemySpeed:3.2*0.75,time:50,enemyCount:5},
  {enemyType:'attacker',enemyHP:99,enemyDamage:19,enemySpeed:3.4*0.75,time:50,enemyCount:6},
  {enemyType:'boss3',enemyHP:666,enemyDamage:33,enemySpeed:2.4*0.75,time:100,enemyCount:1}
  ,{enemyType:'veleno',enemyHP:70,enemyDamage:15,enemySpeed:3.1*0.75,time:50,enemyCount:7} // Level 16
  ,{enemyType:'veleno',enemyHP:80,enemyDamage:15,enemySpeed:3.3*0.75,time:50,enemyCount:9} // Level 17
  ,{enemyType:'oneyes',enemyHP:65,enemyDamage:10,enemySpeed:2.8*0.75,time:55,enemyCount:6} // Level 18
  ,{enemyType:'oneyes',enemyHP:75,enemyDamage:12,enemySpeed:3.0*0.75,time:55,enemyCount:7} // Level 19
  ,{enemyType:'boss4',enemyHP:800,enemyDamage:35,enemySpeed:2.2*0.75,time:120,enemyCount:1} // Level 20

];

const RECORDS_KEY='pf_records_v17'; // bumped key to include salsy + new unlock rules // bumped key to include voltryx
let records=loadRecords();

function loadRecords(){
  try{
    const r=localStorage.getItem(RECORDS_KEY);
    if(r){
      const obj=JSON.parse(r);
      return Object.assign({jimmy:0,rooney:0,jeff:0,voltryx:0,kouvagia:0,salsy:0}, obj);
    }
  }catch(e){}
  return {jimmy:0,rooney:0,jeff:0,voltryx:0,kouvagia:0,salsy:0};
}
function saveRecords(){
  try{localStorage.setItem(RECORDS_KEY,JSON.stringify(records))}catch(e){}
}
function updateMenuRecordsDisplay(){
  document.getElementById('record-jimmy').textContent=`Record: ${records.jimmy||0}`;
  document.getElementById('record-rooney').textContent=`Record: ${records.rooney||0}`;
  document.getElementById('record-jeff').textContent=`Record: ${records.jeff||0}`;
  document.getElementById('record-voltryx').textContent=`Record: ${records.voltryx||0}`;
  document.getElementById('record-kouvagia').textContent=`Record: ${records.kouvagia||0}`;
  document.getElementById('record-salsy').textContent=`Record: ${records.salsy||0}`;
  updateVoltryxUnlockUI();
  updateKouvagiaUnlockUI();
  updateSalsyUnlockUI();
  updateGuideUnlockUI();
}
function allThreeAbove50k(){
  return (records.jimmy||0)>50000 && (records.rooney||0)>50000 && (records.jeff||0)>50000;
}
function updateVoltryxUnlockUI(){
  const card=document.getElementById('card-voltryx');
  const badge=document.getElementById('voltryxLockBadge');
  if(allThreeAbove50k()){
    card.classList.remove('disabled');
    badge.textContent='UNLOCKED';
    badge.style.color='#2ecc71';
    badge.style.borderColor='#2ecc71';
    card.title='Voltryx sbloccata!';
  }else{
    card.classList.add('disabled');
    badge.textContent='LOCKED';
    badge.style.color='#f39c12';
    badge.style.borderColor='#f39c12';
    card.title='Sblocca completando 50.000 punti con Jimmy, Rooney e Jeff';
  }
}



function voltryxAbove51k(){
  return (records.voltryx||0) >= 51000;
}

function updateKouvagiaUnlockUI(){
  const card=document.getElementById('card-kouvagia');
  const badge=document.getElementById('kouvagiaLockBadge');
  if(!card||!badge) return;
  if(voltryxAbove51k()){
    card.classList.remove('disabled');
    badge.textContent='UNLOCKED';
    badge.style.color='#2ecc71';
    badge.style.borderColor='#2ecc71';
    card.title='Kouvagia sbloccato!';
  }else{
    card.classList.add('disabled');
    badge.textContent='LOCKED';
    badge.style.color='#f39c12';
    badge.style.borderColor='#f39c12';
    card.title='Sblocca facendo 51.000 punti con Voltryx';
  }
}


function allPrevAbove70k(){
  return (records.jimmy||0)>=70000 && (records.rooney||0)>=70000 && (records.jeff||0)>=70000 && (records.voltryx||0)>=70000 && (records.kouvagia||0)>=70000;
}
function updateSalsyUnlockUI(){
  const card=document.getElementById('card-salsy');
  const badge=document.getElementById('salsyLockBadge');
  if(!card||!badge) return;
  if(allPrevAbove70k()){
    card.classList.remove('disabled');
    badge.textContent='UNLOCKED';
    badge.style.color='#2ecc71';
    badge.style.borderColor='#2ecc71';
    card.title='Salsy sbloccata!';
  }else{
    card.classList.add('disabled');
    badge.textContent='LOCKED';
    badge.style.color='#f39c12';
    badge.style.borderColor='#f39c12';
    card.title='Sblocca facendo 70.000 punti con Jimmy, Rooney, Jeff, Voltryx e Kouvagia';
  }
}


function updateGuideUnlockUI(){
  const vUnlocked = allThreeAbove50k();
  const kUnlocked = voltryxAbove51k();
  const sUnlocked = allPrevAbove70k();

  const vBox=document.getElementById('guide-voltryx');
  const vLock=document.getElementById('guide-voltryx-locked');
  if(vBox&&vLock){ vBox.style.display = vUnlocked ? 'block' : 'none'; vLock.style.display = vUnlocked ? 'none' : 'block'; }

  const kBox=document.getElementById('guide-kouvagia');
  const kLock=document.getElementById('guide-kouvagia-locked');
  if(kBox&&kLock){ kBox.style.display = kUnlocked ? 'block' : 'none'; kLock.style.display = kUnlocked ? 'none' : 'block'; }

  const sBox=document.getElementById('guide-salsy');
  const sLock=document.getElementById('guide-salsy-locked');
  if(sBox&&sLock){ sBox.style.display = sUnlocked ? 'block' : 'none'; sLock.style.display = sUnlocked ? 'none' : 'block'; }
}


function createParticles(x,y,color,count=10,size=4){
  for(let i=0;i<count;i++){
    particles.push({
      x:x+Math.random()*20-10,
      y:y+Math.random()*20-10,
      vx:(Math.random()-0.5)*6,
      vy:(Math.random()-0.5)*6,
      life:30,
      color,size
    });
  }
}
function updateParticles(){
  particles=particles.filter(p=>{
    p.x+=p.vx;p.y+=p.vy;p.vy+=0.2;p.life--;
    return p.life>0
  });
}
function drawParticles(){
  particles.forEach(p=>{
    ctx.fillStyle=p.color;
    ctx.globalAlpha=p.life/30;
    ctx.fillRect(p.x,p.y,p.size,p.size)
  });
  ctx.globalAlpha=1
}
function showDamageNumber(x,y,dmg){
  const div=document.createElement('div');
  div.className='damage-number';
  div.textContent=`-${dmg}`;
  const rect=canvas.getBoundingClientRect();
  div.style.left=(rect.left+x)+'px';
  div.style.top=(rect.top+y-10)+'px';
  document.body.appendChild(div);
  setTimeout(()=>div.remove(),1000)
}

function markMult(enemy){
  return (enemy && enemy.salsyMarkUntil && Date.now() < enemy.salsyMarkUntil) ? 2 : 1;
}
function applyEnemyDamage(enemy, baseDmg){
  const finalDmg = Math.max(0, Math.round(baseDmg * markMult(enemy)));
  enemy.hp -= finalDmg;
  return finalDmg;
}

function shakeScreen(){shakeAmount=8}

// Extended projectile to support friendly, AoE, homing, pulse damage
function spawnProjectile(opts){
  // opts: {x,y,vx,vy,damage,ttl,color,radius,friendly,aoeRadius,aoeFullDamage,homing,speed,isVoltryxSuper,pulseInterval,lastPulse,targetRef}
  const p={
    x:opts.x,y:opts.y,vx:opts.vx||0,vy:opts.vy||0,
    damage:opts.damage||10,created:Date.now(),
    ttl:opts.ttl||3000,color:opts.color||'#fff',
    radius:opts.radius||6,friendly:!!opts.friendly,
    aoeRadius:opts.aoeRadius||0,aoeFullDamage:!!opts.aoeFullDamage,homing:!!opts.homing,
    speed:opts.speed||Math.hypot(opts.vx||0,opts.vy||0)||6,
    isVoltryxSuper:!!opts.isVoltryxSuper,
    pulseInterval:opts.pulseInterval||0,
    lastPulse:opts.lastPulse||0,
  targetRef:opts.targetRef||null
  };
  projectiles.push(p);
}

function updateProjectiles(){
  const now=Date.now();

    // Grapple safety: prevent rare stuck state (e.g., Jimmy vs shooter)
    if(this.isGrappling){
      if(!this.grappleTarget || !enemies.includes(this.grappleTarget) || (this.grappleStartTime && now-this.grappleStartTime>1400)){
        this.isGrappling=false;this.grappleTarget=null;this.vx=0;this.vy=0;
          this.grappleStartTime=0;
        this.grappleStartTime=0;
        if(this.type==='jimmy' && this.shieldActive && !this.isDoingSuper) this.shieldActive=false;
      }
    }

  projectiles=projectiles.filter(p=>{
    // homing behavior towards nearest enemy (for friendly projectiles)
    if(p.homing && p.friendly && enemies.length>0){
      // find nearest enemy
      let closest=null, best=Infinity;
      for(const e of enemies){
        const dx=(e.x+e.width/2)-p.x;
        const dy=(e.y+e.height/2)-p.y;
        const d=Math.hypot(dx,dy);
        if(d<best){best=d;closest=e}
      }
      if(closest){
        const dx=(closest.x+closest.width/2)-p.x;
        const dy=(closest.y+closest.height/2)-p.y;
        const len=Math.hypot(dx,dy)||1;
        const steerX=(dx/len)*p.speed;
        const steerY=(dy/len)*p.speed;
        // soft steer
        p.vx = p.vx*0.6 + steerX*0.4;
        p.vy = p.vy*0.6 + steerY*0.4;
      }
    }

    p.x+=p.vx;
    p.y+=p.vy;

    // Bounds
    const aliveInBounds = p.x>=-60 && p.x<=canvas.width+60 && p.y>=-60 && p.y<=canvas.height+60;

    // Voltryx super orb pulse AoE damage
    if(p.isVoltryxSuper){
      if(!p.lastPulse || now - p.lastPulse >= p.pulseInterval){
        p.lastPulse = now;
        // damage all enemies within aoeRadius
        for(let i=enemies.length-1;i>=0;i--){
          const e=enemies[i];
          const dist=Math.hypot((e.x+e.width/2)-p.x,(e.y+e.height/2)-p.y);
          if(dist <= p.aoeRadius){
            const dmg = p.aoeFullDamage ? Math.round(p.damage) : Math.round(p.damage*SUPER_DAMAGE_MULT);
            const _dmg=dmg; const _final=applyEnemyDamage(e,_dmg);
            createParticles(e.x,e.y,'#f39c12',12,5);
            showDamageNumber(e.x,e.y, _final);
            if(e.hp<=0){
              createParticles(e.x,e.y,'#fff176',30,6);
              enemies.splice(i,1);
              score+=100*currentLevel;
                if(this.type==='kouvagia'){this.hp=Math.min(this.maxHP,this.hp+3);createParticles(this.x,this.y,'#2ecc71',6,3);}
            }
          }
        }
      }
    }

    // Collision: friendly hits enemies
    if(p.friendly){
      for(let i=enemies.length-1;i>=0;i--){
        const e=enemies[i];
        const dx=(e.x+e.width/2)-p.x;
        const dy=(e.y+e.height/2)-p.y;
        const dist=Math.hypot(dx,dy);
        if(dist <= (p.radius + Math.max(e.width,e.height)/2)*0.8){
          // impact
          if(p.aoeRadius>0){
            // area explosion
            for(let j=enemies.length-1;j>=0;j--){
              const ee=enemies[j];
              const d2=Math.hypot((ee.x+ee.width/2)-p.x,(ee.y+ee.height/2)-p.y);
              if(d2<=p.aoeRadius){
                const dmg = p.aoeFullDamage ? Math.round(p.damage) : Math.round(p.damage*SUPER_DAMAGE_MULT);
                const _dmg=dmg; const _final=applyEnemyDamage(ee,_dmg);
                createParticles(ee.x,ee.y,'#ffb74d',8,4);
                showDamageNumber(ee.x,ee.y, _final);
                if(ee.hp<=0){
                  createParticles(ee.x,ee.y,'#fff176',30,6);
                  enemies.splice(j,1);
                  score+=100*currentLevel;
                }
              }
            }
          }else{
            // single target
            const dmg=Math.round(p.damage);
            const _dmg=dmg; const _final=applyEnemyDamage(e,_dmg);
            createParticles(e.x,e.y,'#ffd54f',8,4);
            showDamageNumber(e.x,e.y, _final);
            if(e.hp<=0){
              createParticles(e.x,e.y,'#fff176',30,6);
              enemies.splice(i,1);
              score+=100*currentLevel;
                if(this.type==='kouvagia'){this.hp=Math.min(this.maxHP,this.hp+3);createParticles(this.x,this.y,'#2ecc71',6,3);}
            }
          }
          return false; // projectile consumed
        }
      }
    }else{
      // enemy projectiles hit player
      if(player && p.x>player.x && p.x<player.x+player.width && p.y>player.y && p.y<player.y+player.height){
        player.takeDamage(p.damage);
        return false;
      }
    }

    return (now-p.created)<p.ttl && aliveInBounds;
  });
}

function drawProjectiles(){
  projectiles.forEach(p=>{
    ctx.fillStyle=p.color;
    ctx.beginPath();
    ctx.globalAlpha = p.isVoltryxSuper ? 0.8 : 1;
    ctx.arc(p.x,p.y,p.isVoltryxSuper ? 18 : p.radius,0,Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;
    if(p.isVoltryxSuper){
      // draw a soft aura
      ctx.strokeStyle='rgba(243,156,18,0.5)';
      ctx.lineWidth=4;
      ctx.beginPath();
      ctx.arc(p.x,p.y,p.aoeRadius,0,Math.PI*2);
      ctx.stroke();
    }
  });
}

// Laser hazards (OneEyes + Boss4)
function spawnLaser(opts){
  // opts: {x,y,angle,length,width,ttl,damage,kind,chargeMs,chargedAt}
  lasers.push({
    x:opts.x,y:opts.y,angle:opts.angle||0,length:opts.length||520,width:opts.width||14,
    created:Date.now(),ttl:opts.ttl||1000,damage:opts.damage||15,
    kind:opts.kind||'laser', chargeMs:opts.chargeMs||0, chargedAt:Date.now()+ (opts.chargeMs||0),
    hitCooldown:220, lastHit:0,
    hitOnce:false
  });
}

function updateLasers(){
  const now=Date.now();
  lasers = lasers.filter(L=>{
    const alive = (now - L.created) < (L.ttl + (L.chargeMs||0));
    if(!alive) return false;

    // During charge: no damage
    const active = now >= L.chargedAt;

    if(active && player){
      // Collision: distance from player center to laser segment
      const px = player.x + player.width/2;
      const py = player.y + player.height/2;

      const x2 = L.x + Math.cos(L.angle)*L.length;
      const y2 = L.y + Math.sin(L.angle)*L.length;

      // projection
      const vx = x2 - L.x, vy = y2 - L.y;
      const wx = px - L.x, wy = py - L.y;
      const c1 = wx*vx + wy*vy;
      const c2 = vx*vx + vy*vy;
      let t = c2 ? (c1 / c2) : 0;
      t = Math.max(0, Math.min(1, t));
      const cx = L.x + t*vx;
      const cy = L.y + t*vy;
      const dist = Math.hypot(px - cx, py - cy);

      if(dist <= (L.width/2 + Math.max(player.width, player.height)*0.20)){
        // OneEyes: il danno pu√≤ essere preso una sola volta per raggio
        if(L.kind==='oneyes'){
          if(!L.hitOnce){
            L.hitOnce=true;
            player.takeDamage(L.damage);
          }
        } else {
          if(now - L.lastHit >= L.hitCooldown){
            L.lastHit = now;
            player.takeDamage(L.damage);
          }
        }
      }
    }

    return true;
  });
}

function drawLasers(){
  const now=Date.now();
  lasers.forEach(L=>{
    const active = now >= L.chargedAt;
    const x2 = L.x + Math.cos(L.angle)*L.length;
    const y2 = L.y + Math.sin(L.angle)*L.length;

    ctx.save();
    ctx.lineCap='round';

    if(!active){
      // charge preview
      ctx.globalAlpha = 0.55;
      ctx.strokeStyle = 'rgba(255,255,255,0.7)';
      ctx.lineWidth = Math.max(6, L.width*0.5);
      ctx.beginPath(); ctx.moveTo(L.x,L.y); ctx.lineTo(x2,y2); ctx.stroke();
      ctx.globalAlpha = 1;
    } else {
      // active beam
      ctx.globalAlpha = (L.kind==='photon') ? 0.92 : 0.75;
      ctx.strokeStyle = (L.kind==='photon') ? 'rgba(243,156,18,0.9)' : 'rgba(52,152,219,0.9)';
      ctx.lineWidth = L.width;
      ctx.beginPath(); ctx.moveTo(L.x,L.y); ctx.lineTo(x2,y2); ctx.stroke();

      // glow
      ctx.globalAlpha = 0.28;
      ctx.lineWidth = L.width*1.9;
      ctx.beginPath(); ctx.moveTo(L.x,L.y); ctx.lineTo(x2,y2); ctx.stroke();
      ctx.globalAlpha = 1;
    }

    ctx.restore();
  });
}

function spawnPickup(x,y,type,value=0){
  pickups.push({x,y,type,value,created:Date.now(),ttl:20000,w:28,h:28});
}
function spawnPickupsForLevel(level){
  pickups=[];
  if(level<4) return;
  const count=1+Math.floor(Math.random()*2);
  for(let i=0;i<count;i++){
    const types=['heal','atk','super','speed','shieldPickup','malus'];
    const isGold=Math.random()<GOLD_PROB;
    const type=isGold?'gold':types[Math.floor(Math.random()*types.length)];
    const x=60+Math.random()*(canvas.width-120);
    const y=60+Math.random()*(canvas.height-180);
    pickups.push({type,x,y,radius:18,created:Date.now()});
  }
}
function drawPickups(){
  pickups.forEach(p=>{
    const img = getPickupImage(p.type);
    // Keep the existing small pickup size:
    // - if pickup defines w/h use those
    // - else if pickup defines radius use diameter
    // - fallback to 28px
    const w = (p.w!=null)?p.w: (p.radius!=null)?(p.radius*2):28;
    const h = (p.h!=null)?p.h: (p.radius!=null)?(p.radius*2):28;
    const dw = w*2;
    const dh = h*2;

    if(img && img.complete && img.naturalWidth>0){
      ctx.drawImage(img, p.x - dw/2, p.y - dh/2, dw, dh);
    } else {
      // Fallback if image not yet loaded
      if(p.type==='heal')ctx.fillStyle='#2ecc71';
      else if(p.type==='atk')ctx.fillStyle='#e74c3c';
      else if(p.type==='super')ctx.fillStyle='#f1c40f';
      else if(p.type==='gold')ctx.fillStyle='gold';
      else if(p.type==='speed')ctx.fillStyle='#3498db';
      else if(p.type==='shieldPickup')ctx.fillStyle='#7fdbff';
      else if(p.type==='malus')ctx.fillStyle='#8b0000';
      ctx.beginPath();
      ctx.arc(p.x,p.y,(p.radius!=null)?p.radius:Math.min(w,h)/2,0,Math.PI*2);
      ctx.fill();
    }
  });
}

function updatePickups(playerRef){
  pickups=pickups.filter(p=>{
    if(Date.now()-p.created>p.ttl) return false;
    const dist=Math.hypot((p.x-playerRef.x),(p.y-playerRef.y));
    if(dist<p.radius+Math.max(playerRef.width,playerRef.height)/2){
      applyPickupEffect(playerRef,p.type);
      return false;
    }
    return true;
  });
}
function applyPickupEffect(playerRef,type){
  if(type==='heal'){
    const healAmount=Math.round(playerRef.maxHP*0.25);
    playerRef.hp=Math.min(playerRef.maxHP,playerRef.hp+healAmount);
    createParticles(playerRef.x,playerRef.y,'#2ecc71',20);
  } else if(type==='atk'){
    playerRef.attackBuffMultiplier=1.6;
    playerRef.attackBuffUntil=Date.now()+10000;
    createParticles(playerRef.x,playerRef.y,'#e74c3c',20);
  } else if(type==='super'){
    playerRef.lastSuper=Date.now()-playerRef.superCooldown-100;
    createParticles(playerRef.x,playerRef.y,'#f1c40f',20);
  } else if(type==='gold'){
    playerRef.hp=playerRef.maxHP;
    playerRef.attackBuffMultiplier=2.0;
    playerRef.attackBuffUntil=Date.now()+15000;
    playerRef.lastSuper=Date.now()-playerRef.superCooldown-100;
    createParticles(playerRef.x,playerRef.y,'gold',40);
    for(let i=0;i<8;i++) createParticles(playerRef.x+(Math.random()-0.5)*40,playerRef.y+(Math.random()-0.5)*40,'#fff176',6);
  } else if(type==='speed'){
    playerRef.speed=playerRef._baseSpeed*1.5;
    playerRef.speedBuffUntil=Date.now()+7000;
    createParticles(playerRef.x,playerRef.y,'#3498db',20);
  } else if(type==='shieldPickup'){
    playerRef.pickupShieldUntil=Date.now()+6000;
    playerRef.invulnerable=true;
    createParticles(playerRef.x,playerRef.y,'#7fdbff',30);
  } else if(type==='malus'){
    playerRef.poisonUntil=Date.now()+10000;
    playerRef.poisonTickLast=Date.now();
    playerRef.poisonTickDamage=1;
    createParticles(playerRef.x,playerRef.y,'#8b0000',30);
  }
}

class Player{
  constructor(type){
    const s=characterStats[type];
    this.type=type;
    this.x=canvas.width/2;this.y=canvas.height/2;
    this.width=80;this.height=90;
    this.vx=0;this.vy=0;
    this.maxHP=s.hp;this.hp=s.hp;
    this.speed=s.speed;this._baseSpeed=s.speed;
    this.damage=s.damage;this.range=s.range;
    this.cooldown=s.cooldown;this.attackType=s.attackType;
    this.lastAttack=0;this.facingRight=true;
    this.dashCooldown=0;this.attacking=false;this.attackTime=0;
    this.combo=0;this.damageTaken=0;this.isDashing=false;this.dashTime=0;
    this.superCooldown=s.superCooldown;this.superDuration=s.superDuration;
    this.lastSuper=-s.superCooldown;this.isDoingSuper=false;this.superStartTime=0;
    this.superTargets=[];this.grappleTarget=null;this.isGrappling=false;
    this.grappleStartTime=0; // safety timeout for grapple
    this.aimAssistRadius=400;this.aimAssistStrength=0.35;
    this._superHitDone=false;this._superPhase=0;
    this.shieldActive=false;this.shieldDurability=4;this.shieldMaxDurability=4;this.shieldBroken=false;this.shieldBrokenTime=0;this.shieldRegenMs=6000;
    this.attackBuffMultiplier=1;this.attackBuffUntil=0;this.speedBuffUntil=0;this.pickupShieldUntil=0;this.invulnerable=false;
    this._dashSpeedMult=3;
    this._dashDuration=200;

    // Kouvagia dash-attack helpers
    this._kouvagiaDashActive=false;
    this._kouvagiaDashHitCd=0;
    this._kouvagiaExplosionPending=false;
    this._kouvagiaSuperFxStart=0;
    this._kouvagiaSuperFxUntil=0;

    // Jimmy jetpack
    this.jetpackCooldown=15000;
    this.lastJetpack=Date.now()-this.jetpackCooldown;
    this.isJetpacking=false;
    this.jetpackDuration=3000;
    this._jetpackSpeedMultiplier=2;

    this.lastSuper=-99999;
    this.poisonUntil=0;
    this.poisonTickLast=0;
    this.poisonTickDamage=1;
  }

  findClosestEnemy(radius=this.aimAssistRadius){
    let closest=null;let best=radius;
    enemies.forEach(e=>{
      const dx=(e.x+e.width/2)-(this.x+this.width/2);
      const dy=(e.y+e.height/2)-(this.y+this.height/2);
      const dist=Math.hypot(dx,dy);
      if(dist<best){best=dist;closest=e}
    });
    return closest;
  }

  update(){
    const now=Date.now();

    if(this.shieldBroken&&now-this.shieldBrokenTime>this.shieldRegenMs){
      this.shieldBroken=false;this.shieldDurability=this.shieldMaxDurability
    }
    if(this.attackBuffUntil && now>this.attackBuffUntil){this.attackBuffMultiplier=1;this.attackBuffUntil=0}
    if(this.speedBuffUntil && now>this.speedBuffUntil){
      this.speed=this._baseSpeed;this.speedBuffUntil=0;this.isJetpacking=false;this.invulnerable=false
    }
    if(this.pickupShieldUntil && now>this.pickupShieldUntil){this.pickupShieldUntil=0;this.invulnerable=false}

    // Jimmy jetpack passive
    if(this.type==='jimmy'){
      if(!this.isJetpacking && now-this.lastJetpack>=this.jetpackCooldown && !this.isDoingSuper){
        this.isJetpacking=true;
        this.lastJetpack=now;
        this.invulnerable=true;
        this.speed=this._baseSpeed * this._jetpackSpeedMultiplier;
        this.speedBuffUntil=now+this.jetpackDuration;
      }
      if(this.isJetpacking && now>=this.speedBuffUntil){
        this.isJetpacking=false;
        this.invulnerable=false;
        this.speed=this._baseSpeed;
      }
    }


    // Salsy passive: speed boost every 12s for 2s (slightly faster bursts)
    if(this.type==='salsy'){
      if(!this._salsyBoostCooldown){ this._salsyBoostCooldown=12000; this._salsyBoostDuration=2000; this.lastSalsyBoost=now-this._salsyBoostCooldown; this.salsyBoostUntil=0; }
      if(!this.isDoingSuper && now - this.lastSalsyBoost >= this._salsyBoostCooldown){
        this.lastSalsyBoost = now;
        this.salsyBoostUntil = now + this._salsyBoostDuration;
        // don't overwrite other speed buffs permanently; apply multiplicative while active
      }
      if(this.salsyBoostUntil && now < this.salsyBoostUntil){
        // base speed plus temporary boost (stacking with pickup speed buff by multiplying current speed floor)
        const base = this._baseSpeed;
        // if pickup speed buff is active, this.speed is already > base; keep that and add a small extra
        const current = Math.max(this.speed, base);
        this.speed = current * 1.25;
      }else if(this.salsyBoostUntil && now >= this.salsyBoostUntil){
        this.salsyBoostUntil = 0;
        // restore to pickup/buff or base
        this.speed = (this.speedBuffUntil && now < this.speedBuffUntil) ? this.speed : this._baseSpeed;
      }
    }

    // Poison
    if(this.poisonUntil && now < this.poisonUntil){
      if(!this.poisonTickLast) this.poisonTickLast = now;
      if(now - this.poisonTickLast >= 1000){
        this.poisonTickLast = now;
        this.hp = Math.max(0, this.hp - (this.poisonTickDamage||1));
        createParticles(this.x,this.y,'#8b0000',6,3);
        if(this.hp<=0 && gameState==='playing') endGame(false);
      }
    } else this.poisonTickLast = 0;

    // Movement
    let moveX=0,moveY=0;
    if(!this.isGrappling){
      if(keys['a']){moveX=-1;this.facingRight=false}
      if(keys['d']){moveX=1;this.facingRight=true}
      if(keys['w'])moveY=-1;
      if(keys['s'])moveY=1
    }
    if(moveX!==0&&moveY!==0){moveX*=0.707;moveY*=0.707}

    if(this.isDashing){
      const dashSpeed=this.speed*(this._dashSpeedMult||3);
      this.vx=(this.facingRight?1:-1)*dashSpeed;
      if(this.type==='kouvagia' && this._kouvagiaDashActive){this.vy=0;}

      // Kouvagia: deal damage during dash (tick-based)
      if(this.type==='kouvagia' && this._kouvagiaDashActive){
        if(this._kouvagiaDashHitCd<=0){
          this._kouvagiaDashHitCd=4; // roughly every few frames
          for(let i=enemies.length-1;i>=0;i--){
            const e=enemies[i];
            const dist=Math.hypot((e.x+e.width/2)-(this.x+this.width/2),(e.y+e.height/2)-(this.y+this.height/2));
            if(dist<110){
              const dmg=Math.round(40*this.attackBuffMultiplier);
              const _dmg=dmg; const _final=applyEnemyDamage(e,_dmg);
              createParticles(e.x,e.y,'#e84393',10,5);
              showDamageNumber(e.x,e.y, _final);
              if(e.hp<=0){
                createParticles(e.x,e.y,'#fff176',30,6);
                enemies.splice(i,1);
                score+=100*currentLevel;
                if(this.type==='kouvagia'){this.hp=Math.min(this.maxHP,this.hp+3);createParticles(this.x,this.y,'#2ecc71',6,3);}
              }
            }
          }
        }else this._kouvagiaDashHitCd--;
      }
      if(now-this.dashTime>(this._dashDuration||200)){
        this.isDashing=false; this.vx=0; this.vy=0; this._dashSpeedMult=3; this._dashDuration=200; if(this.type==='kouvagia'){this._kouvagiaDashActive=false;}
        // Kouvagia: explosion at end of dash
        if(this.type==='kouvagia' && this._kouvagiaExplosionPending){
          this._kouvagiaExplosionPending=false;
    this._kouvagiaSuperFxStart=0;
    this._kouvagiaSuperFxUntil=0;
          this._kouvagiaDashActive=false;
          for(let i=enemies.length-1;i>=0;i--){
            const e=enemies[i];
            const dist=Math.hypot((e.x+e.width/2)-(this.x+this.width/2),(e.y+e.height/2)-(this.y+this.height/2));
            if(dist<165){
              const dmg=Math.round(65*this.attackBuffMultiplier);
              const _dmg=dmg; const _final=applyEnemyDamage(e,_dmg);
              createParticles(e.x,e.y,'#fd79a8',16,5);
              showDamageNumber(e.x,e.y, _final);
              if(e.hp<=0){
                createParticles(e.x,e.y,'#fff176',30,6);
                enemies.splice(i,1);
                score+=100*currentLevel;
                if(this.type==='kouvagia'){this.hp=Math.min(this.maxHP,this.hp+3);createParticles(this.x,this.y,'#2ecc71',6,3);}
              }
            }
          }
          shakeScreen();
        }

      }
    } else if(!this.isGrappling){
      this.vx=moveX*this.speed+this.vx*0.1;
      this.vy=moveY*this.speed+this.vy*0.1;
    }

    // Grapple chase
    if(this.isGrappling&&this.grappleTarget){
      if(!enemies.includes(this.grappleTarget)){
        this.isGrappling=false;this.grappleTarget=null
      } else {
        const dx=this.grappleTarget.x-this.x;const dy=this.grappleTarget.y-this.y;
        const dist=Math.hypot(dx,dy);const speedMult=5;
        if(dist>48){
          this.vx=(dx/(dist||1))*this.speed*speedMult;
          this.vy=(dy/(dist||1))*this.speed*speedMult
        } else {
          const dmg=Math.round(this.damage*this.attackBuffMultiplier);
          const _dmg=dmg; const _final=applyEnemyDamage(this.grappleTarget,_dmg);
          createParticles(this.grappleTarget.x,this.grappleTarget.y,'#e74c3c',18,6);
          showDamageNumber(this.grappleTarget.x,this.grappleTarget.y,_final);
          if(this.grappleTarget.hp<=0){
            const idx=enemies.indexOf(this.grappleTarget);
            if(idx>-1){
              createParticles(this.grappleTarget.x,this.grappleTarget.y,'#fff176',30,6);
              enemies.splice(idx,1);score+=100*currentLevel
            }
          }
          this.isGrappling=false;this.grappleTarget=null;this.vx=0;this.vy=0;
          this.grappleStartTime=0;
        }
      }
    }

    // Super handling
    if(this.isDoingSuper){
      const elapsed=now-this.superStartTime;
      if(this.type==='jimmy'){this.invulnerable=true;this.shieldActive=true}

      if(this.attackType==='punch'){
        if(!this._superHitDone&&elapsed>=300){
          this._superHitDone=true;
          if(this.type==='rooney'){
            const hitList=[];
            enemies.forEach((enemy)=>{const dist=Math.hypot(enemy.x-this.x,enemy.y-this.y);if(dist<350)hitList.push(enemy)});
            const n=hitList.length||1;
            const baseRooney=200;
            const multiplier = 0.75 + (4 - n)*0.25;
            const perEnemy = Math.max(8, Math.round(baseRooney * SUPER_DAMAGE_MULT * multiplier * this.attackBuffMultiplier));
            for(let i=hitList.length-1;i>=0;i--){
              const enemy=hitList[i];
              const _dmg=perEnemy; const _final=applyEnemyDamage(enemy,_dmg);
              createParticles(enemy.x,enemy.y,'#f39c12',18,6);
              showDamageNumber(enemy.x,enemy.y, _final);
              if(enemy.hp<=0){
                const idx=enemies.indexOf(enemy);
                if(idx>-1){createParticles(enemy.x,enemy.y,'#fff176',30,6);enemies.splice(idx,1);score+=100*currentLevel}
              }
            }
          } else {
            enemies.forEach((enemy,idx)=>{
              const dist=Math.hypot(enemy.x-this.x,enemy.y-this.y);
              if(dist<350){
                const base=(this.type==='jimmy')?300:140;
                const mult=(this.type==='jimmy')?(SUPER_DAMAGE_MULT*JIMMY_SUPER_ADDITIONAL_MULT):SUPER_DAMAGE_MULT;
                let extra=1;if(this.type==='rooney'&&dist<150)extra=1.5;
                const dmg=Math.round(base*mult*extra*this.attackBuffMultiplier);
                const _dmg=dmg; const _final=applyEnemyDamage(enemy,_dmg);
                createParticles(enemy.x,enemy.y,'#f39c12',30,6);
                showDamageNumber(enemy.x,enemy.y, _final);
                if(enemy.hp<=0){
                  createParticles(enemy.x,enemy.y,'#fff176',30,6);
                  enemies.splice(idx,1);
                  score+=100*currentLevel
                }
              }
            });
          }
          shakeScreen();
        }
        if(elapsed>=this.superDuration)this.endSuper();

      } else if(this.attackType==='grapple'){
        if(this.superTargets.length>0){
          const target=this.superTargets[0];
          if(!enemies.includes(target))this.superTargets.shift();
          else{
            const dx=target.x-this.x;const dy=target.y-this.y;const dist=Math.hypot(dx,dy);const chaseSpeed=this.speed*6;
            if(dist>50){this.vx=(dx/(dist||1))*chaseSpeed;this.vy=(dy/(dist||1))*chaseSpeed}
            else{
              const base=120;
              const mult=(this.type==='jimmy')?(SUPER_DAMAGE_MULT*JIMMY_SUPER_ADDITIONAL_MULT):SUPER_DAMAGE_MULT;
              const dmg=Math.round(base*mult*this.attackBuffMultiplier*(this.type==='jimmy'?2.0:1));
              const _dmg=dmg; const _final=applyEnemyDamage(target,_dmg);
              createParticles(target.x,target.y,'#e74c3c',15,6);
              showDamageNumber(target.x,target.y, _final);
              if(target.hp<=0){
                createParticles(target.x,target.y,'#fff176',30,6);
                const idx=enemies.indexOf(target);
                if(idx>-1){enemies.splice(idx,1);score+=100*currentLevel}
              }
              this.superTargets.shift();this._superPhase=Date.now()
            }
          }
        } else {if(now-this.superStartTime>=Math.min(this.superDuration,1200))this.endSuper()}
      } else if(this.attackType==='sword'){
        if(elapsed>=0&&elapsed<this.superDuration){
          if(!this._lastSwordTick||now-this._lastSwordTick>=180){
            this._lastSwordTick=now;
            enemies.forEach((enemy,idx)=>{
              const dist=Math.hypot(enemy.x-this.x,enemy.y-this.y);
              if(dist<JEFF_SUPER_RADIUS){
                const tickDmg=Math.round(28*SUPER_DAMAGE_MULT);
                const _dmg=tickDmg; const _final=applyEnemyDamage(enemy,_dmg);
                createParticles(enemy.x,enemy.y,'#9b59b6',8,4);
                showDamageNumber(enemy.x,enemy.y, _final);
                if(enemy.hp<=0){
                  createParticles(enemy.x,enemy.y,'#fff176',30,6);
                  enemies.splice(idx,1);
                  score+=100*currentLevel
                }
              }
            });
          }
        } else this.endSuper();

      
      } else if(this.attackType==='salsySword'){
        if(elapsed>=this.superDuration) this.endSuper();

      } else if(this.attackType==='kouvagia'){
        if(elapsed>=this.superDuration) this.endSuper();
} else if(this.attackType==='hybrid'){
        
        if(now - this.superStartTime >= this.superDuration){
          this.endSuper();
        }
      }
    }

    // integrate velocity
    this.x+=this.vx;this.y+=this.vy;
    if(!keys['a']&&!keys['d']&&!this.isDashing&&!this.isGrappling)this.vx*=0.86;
    if(!keys['w']&&!keys['s']&&!this.isGrappling)this.vy*=0.86;

    const margin=10;
    if(this.x<margin)this.x=margin;
    if(this.x+this.width>canvas.width-margin)this.x=canvas.width-this.width-margin;
    if(this.y<margin)this.y=margin;
    if(this.y+this.height>canvas.height-50-margin)this.y=canvas.height-50-this.height-margin;

    if(this.dashCooldown>0)this.dashCooldown--;

    if(this.attacking&&Date.now()-this.attackTime>300){
      this.attacking=false;
      if(this.type==='jimmy'&&this.shieldActive&&!this.isDoingSuper){
        this.shieldActive=false;
      }
    }
  }

  dodge(){
    if(this.dashCooldown<=0&&!this.isDoingSuper){
      this.isDashing=true;this.dashTime=Date.now();

      // Kouvagia passive: dodge deals 10 damage to nearby enemies
      if(this.type==='kouvagia'){
        for(let i=enemies.length-1;i>=0;i--){
          const e=enemies[i];
          const dist=Math.hypot((e.x+e.width/2)-(this.x+this.width/2),(e.y+e.height/2)-(this.y+this.height/2));
          if(dist<95){
            const _dmg=10; const _final=applyEnemyDamage(e,_dmg);
            createParticles(e.x,e.y,'#ff7675',8,4);
            showDamageNumber(e.x,e.y, _final);
            if(e.hp<=0){
              createParticles(e.x,e.y,'#fff176',30,6);
              enemies.splice(i,1);
              score+=100*currentLevel;
                if(this.type==='kouvagia'){this.hp=Math.min(this.maxHP,this.hp+3);createParticles(this.x,this.y,'#2ecc71',6,3);}
            }
          }
        }
      }
      if(this.type==='jimmy' || this.type==='voltryx' || this.type==='kouvagia'){
        this._dashSpeedMult=4;
        this._dashDuration=300;
        this.dashCooldown=90;
      } else {
        this._dashSpeedMult=3;
        this._dashDuration=200;
        this.dashCooldown=90;
      }
    }
  }

  attack(){
    const now=Date.now();
    if(now-this.lastAttack<this.cooldown||this.isDoingSuper)return false;
    this.lastAttack=now;this.attacking=true;this.attackTime=now;

    if(this.type==='jimmy'&&!this.shieldBroken){this.shieldActive=true;}

    const assistTarget=this.findClosestEnemy();
    if(assistTarget){
      const dx=(assistTarget.x+assistTarget.width/2)-(this.x+this.width/2);
      this.facingRight=dx>=0;
      const dist=Math.hypot(dx,(assistTarget.y+assistTarget.height/2)-(this.y+this.height/2));
      if(dist>10){
        const nx=dx/dist;
        const ny=((assistTarget.y+assistTarget.height/2)-(this.y+this.height/2))/dist;
        this.vx+=nx*this.speed*this.aimAssistStrength;
        this.vy+=ny*this.speed*this.aimAssistStrength;
      }
    }

    if(this.attackType==='punch'){
      if(this.type==='rooney'){
        const multipliers=[1,1.15,1.25];
        for(let i=0;i<3;i++){
          setTimeout(((idx)=>{
            return ()=>{
              let closestEnemy=null;let closestDist=this.range+40;
              enemies.forEach(enemy=>{
                const dx=enemy.x-this.x;const dy=enemy.y-this.y;
                const dist=Math.hypot(dx,dy);
                if(dist<closestDist&&Math.abs(dy)<220){closestDist=dist;closestEnemy=enemy}
              });
              if(closestEnemy){
                const baseDmg=this.damage;
                const dmg=Math.round(baseDmg * multipliers[idx] * this.attackBuffMultiplier);
                const _dmg=dmg; const _final=applyEnemyDamage(closestEnemy,_dmg);
                createParticles(closestEnemy.x,closestEnemy.y,'#e67e22',12,5);
                showDamageNumber(closestEnemy.x,closestEnemy.y, _final);
                if(closestEnemy.hp<=0){
                  createParticles(closestEnemy.x,closestEnemy.y,'#fff176',30,6);
                  const idxEnemy=enemies.indexOf(closestEnemy);
                  if(idxEnemy>-1){enemies.splice(idxEnemy,1);score+=100*currentLevel}
                }
              }
            };
          })(i), i*120);
        }
      } else {
        let closestEnemy=null;let closestDist=this.range;
        enemies.forEach(enemy=>{
          const dx=enemy.x-this.x;const dy=enemy.y-this.y;
          const dist=Math.hypot(dx,dy);
          if(dist<closestDist&&Math.abs(dy)<220){closestDist=dist;closestEnemy=enemy}
        });
        if(closestEnemy){
          const dmg=Math.round(this.damage*this.attackBuffMultiplier);
          const _dmg=dmg; const _final=applyEnemyDamage(closestEnemy,_dmg);
          createParticles(closestEnemy.x,closestEnemy.y,'#e67e22',12,5);
          showDamageNumber(closestEnemy.x,closestEnemy.y, _final);
          if(closestEnemy.hp<=0){
            createParticles(closestEnemy.x,closestEnemy.y,'#fff176',30,6);
            enemies.splice(enemies.indexOf(closestEnemy),1);
            score+=100*currentLevel;
          }
        } else if(assistTarget){
          const distA=Math.hypot((assistTarget.x-this.x),(assistTarget.y-this.y));
          if(distA<this.range+120){
            const dmg=Math.round(this.damage*0.9*this.attackBuffMultiplier);
            const _dmg=dmg; const _final=applyEnemyDamage(assistTarget,_dmg);
            createParticles(assistTarget.x,assistTarget.y,'#e67e22',12,5);
            showDamageNumber(assistTarget.x,assistTarget.y, _final);
            if(assistTarget.hp<=0){
              createParticles(assistTarget.x,assistTarget.y,'#fff176',30,6);
              enemies.splice(enemies.indexOf(assistTarget),1);
              score+=100*currentLevel;
            }
          }
        }
      }

    } else if(this.attackType==='grapple'){
      let closestEnemy=assistTarget;
      if(!closestEnemy){
        let closestDist=this.range;
        enemies.forEach(enemy=>{
          const dist=Math.hypot(enemy.x-this.x,enemy.y-this.y);
          if(dist<closestDist){closestDist=dist;closestEnemy=enemy}
        })
      }
      if(closestEnemy){
        this.grappleTarget=closestEnemy;this.isGrappling=true;this.grappleStartX=this.x;this.grappleStartY=this.y;this.grappleStartTime=Date.now()
      }

    } else if(this.attackType==='salsySword'){
      // Two consecutive fan slashes (25x2) at medium-close range
      const attackAngle=this.facingRight?0:Math.PI;
      const arcWidth=Math.PI*1.35;
      const doSwing = ()=>{
        enemies.forEach(enemy=>{
          const dx=enemy.x-this.x;const dy=enemy.y-this.y;const dist=Math.hypot(dx,dy);
          const angle=Math.atan2(dy,dx);
          let angleDiff=angle-attackAngle;
          while(angleDiff>Math.PI)angleDiff-=Math.PI*2;
          while(angleDiff<-Math.PI)angleDiff+=Math.PI*2;
          if(dist<this.range && Math.abs(angleDiff)<arcWidth/2+0.15){
            const base=25*this.attackBuffMultiplier;
            const dmg=applyEnemyDamage(enemy, base);
            createParticles(enemy.x,enemy.y,'#f1c40f',10,4);
            showDamageNumber(enemy.x,enemy.y,dmg);
            if(enemy.hp<=0){
              createParticles(enemy.x,enemy.y,'#fff176',30,6);
              enemies.splice(enemies.indexOf(enemy),1);
              score+=100*currentLevel;
            }
          }
        });
      };
      doSwing();
      setTimeout(doSwing, 120);

    } else if(this.attackType==='sword'){
      const attackAngle=this.facingRight?0:Math.PI;const arcWidth=Math.PI*1.6;
      enemies.forEach(enemy=>{
        const dx=enemy.x-this.x;const dy=enemy.y-this.y;const dist=Math.hypot(dx,dy);
        const angle=Math.atan2(dy,dx);
        let angleDiff=angle-attackAngle;
        while(angleDiff>Math.PI)angleDiff-=Math.PI*2;
        while(angleDiff<-Math.PI)angleDiff+=Math.PI*2;
        if(dist<this.range&&Math.abs(angleDiff)<arcWidth/2+0.2){
          const dmg=Math.round(this.damage*this.attackBuffMultiplier);
          const _dmg=dmg; const _final=applyEnemyDamage(enemy,_dmg);
          createParticles(enemy.x,enemy.y,'#9b59b6',10,4);
          showDamageNumber(enemy.x,enemy.y, _final);
          if(enemy.hp<=0){
            createParticles(enemy.x,enemy.y,'#fff176',30,6);
            enemies.splice(enemies.indexOf(enemy),1);
            score+=100*currentLevel
          }
        }
      });
      if(assistTarget){
        const distAssist=Math.hypot((assistTarget.x-this.x),(assistTarget.y-this.y));
        if(distAssist<this.range+60){
          const dmg=Math.round(this.damage*0.7*this.attackBuffMultiplier);
          const _dmg=dmg; const _final=applyEnemyDamage(assistTarget,_dmg);
          createParticles(assistTarget.x,assistTarget.y,'#9b59b6',10,4);
          showDamageNumber(assistTarget.x,assistTarget.y, _final);
          if(assistTarget.hp<=0){
            createParticles(assistTarget.x,assistTarget.y,'#fff176',30,6);
            enemies.splice(enemies.indexOf(assistTarget),1);
            score+=100*currentLevel
          }
        }
      }

    
    } else if(this.attackType==='kouvagia'){

      // Kouvagia: mini dash forward dealing damage during dash + small/medium AoE on stop
      this.isDashing=true;
      this.dashTime=Date.now();
      this._dashSpeedMult=5.2;
      this._dashDuration=260;
      this.dashCooldown=95;

      this._kouvagiaDashActive=true;
      this._kouvagiaDashHitCd=0;
      this._kouvagiaExplosionPending=true;

    } else if(this.attackType==='hybrid'){
      
      const target=assistTarget || this.findClosestEnemy(800);
      const dist = target ? Math.hypot((target.x+target.width/2)-(this.x+this.width/2),(target.y+target.height/2)-(this.y+this.height/2)) : Infinity;

      if(dist>150 && target){
        // Ranged: small energy sphere with small AoE
        const dx=(target.x+target.width/2)-(this.x+this.width/2);
        const dy=(target.y+target.height/2)-(this.y+this.height/2);
        const len=Math.hypot(dx,dy)||1;
        const speed=9;
        const vx=(dx/len)*speed;
        const vy=(dy/len)*speed;
        const baseAoeDmg = Math.round(50 * this.attackBuffMultiplier);
        spawnProjectile({
          x:this.x+this.width/2, y:this.y+this.height/2,
          vx, vy, speed,
          damage:baseAoeDmg, ttl:2000, color:'#ffb74d',
          radius:7, friendly:true, aoeRadius:60, aoeFullDamage:true, homing:false
        });
        createParticles(this.x+this.width/2,this.y+this.height/2,'#ffa726',8,3);
      } else {
        // Close: two quick punches, slightly less strong than Rooney
        const perPunchBase=50; // Rooney base ~60; Voltryx slightly less
        const punch = ()=>{
          let closest=null;let best=160;
          enemies.forEach(e=>{
            const d=Math.hypot(e.x-this.x,e.y-this.y);
            if(d<best && Math.abs(e.y-this.y)<220){best=d;closest=e}
          });
          if(closest){
            const dmg=Math.round(perPunchBase*this.attackBuffMultiplier);
            const _dmg=dmg; const _final=applyEnemyDamage(closest,_dmg);
            createParticles(closest.x,closest.y,'#e67e22',12,5);
            showDamageNumber(closest.x,closest.y, _final);
            if(closest.hp<=0){
              createParticles(closest.x,closest.y,'#fff176',30,6);
              enemies.splice(enemies.indexOf(closest),1);
              score+=100*currentLevel;
            }
          }
        };
        punch();
        setTimeout(punch, 120);
      }
    }

    return true;
  }

  superAttack(){
    const now=Date.now();
    if(now-this.lastSuper<this.superCooldown||this.isDoingSuper)return false;
    this.lastSuper=now;this.isDoingSuper=true;this.superStartTime=now;this._HitDone=false;

    if(this.type==='jimmy'){this.invulnerable=true;this.shieldActive=true}

    if(this.attackType==='grapple'){
      const sorted=enemies.slice().sort((a,b)=>{
        const da=Math.hypot(a.x-this.x,a.y-this.y);
        const db=Math.hypot(b.x-this.x,b.y-this.y);
        return da-db
      });
      this.superTargets=sorted.slice(0,6)
    }
    else if(this.attackType==='punch'){
      createParticles(this.x+this.width/2,this.y+this.height/2,'#f39c12',20,6);
    }
    else if(this.attackType==='sword'){
      createParticles(this.x+this.width/2,this.y+this.height/2,'#9b59b6',20,6);
    }

    else if(this.attackType==='salsySword'){
      // Mark up to 3 enemies; marked enemies take double damage for a while
      const sorted=enemies.slice().sort((a,b)=>{
        const da=Math.hypot((a.x+a.width/2)-(this.x+this.width/2),(a.y+a.height/2)-(this.y+this.height/2));
        const db=Math.hypot((b.x+b.width/2)-(this.x+this.width/2),(b.y+b.height/2)-(this.y+this.height/2));
        return da-db;
      });
      const targets=sorted.slice(0,3);
      const until=now+7000;
      targets.forEach(t=>{
        t.salsyMarkUntil=until;
        createParticles(t.x,t.y,'#f1c40f',22,5);
      });
      createParticles(this.x+this.width/2,this.y+this.height/2,'#f1c40f',26,6);
    }

    else if(this.attackType==='kouvagia'){

      // Kouvagia super: full heal + large knockback + tiny damage + visual FX
      this.hp=this.maxHP;
      this._kouvagiaSuperFxStart=now;
      this._kouvagiaSuperFxUntil=now+900;
      createParticles(this.x+this.width/2,this.y+this.height/2,'#55efc4',60,6);

      const R=360;
      for(let i=0;i<enemies.length;i++){
        const e=enemies[i];
        const dx=(e.x+e.width/2)-(this.x+this.width/2);
        const dy=(e.y+e.height/2)-(this.y+this.height/2);
        const dist=Math.hypot(dx,dy)||1;
        if(dist<=R){
          // tiny damage
          const dmg=3;
          const _final=applyEnemyDamage(e,dmg);
          showDamageNumber(e.x,e.y,_final);
          createParticles(e.x,e.y,'#81ecec',8,4);
          // knockback
          const push=120;
          e.x += (dx/dist)*push;
          e.y += (dy/dist)*push;
        }
      }
      shakeScreen();
    }
else if(this.attackType==='hybrid'){
     
      const dmgPerPulse = Math.round(100 * this.attackBuffMultiplier);
      spawnProjectile({
        x:this.x+this.width/2,y:this.y+this.height/2,
        vx:(this.facingRight?1:-1)*4,vy:0,speed:6,
        damage:dmgPerPulse,ttl:this.superDuration,color:'#f39c12',
        radius:14,friendly:true,aoeRadius:120,homing:true,
        isVoltryxSuper:true,pulseInterval:260,lastPulse:0
      });
      createParticles(this.x+this.width/2,this.y+this.height/2,'#f39c12',26,6);
      shakeScreen();
    }

    return true;
  }

  endSuper(){
    this.isDoingSuper=false;this._superHitDone=false;this._lastSwordTick=null;
    this.superTargets=[];this.grappleTarget=null;this.isGrappling=false;
    this.vx*=0.5;this.vy*=0.5;this.invulnerable=false;
    if(this.type==='jimmy')this.shieldActive=false
  }

  takeDamage(damage){
    if(this.invulnerable||(this.pickupShieldUntil&&Date.now()<this.pickupShieldUntil))return;
    if(this.shieldActive&&!this.shieldBroken){
      this.shieldDurability-=1;
      createParticles(this.x,this.y,'#3498db',12,5);
      if(this.shieldDurability<=0){this.shieldBroken=true;this.shieldBrokenTime=Date.now();this.shieldActive=false}
      return;
    }
    this.hp-=damage;
    if(!isFinite(this.hp)) this.hp = 0;
    this.hp = Math.max(0, this.hp);
    this.damageTaken++;
    this.combo=0;
    score=Math.max(0,score-50);
    createParticles(this.x,this.y,'#c0392b',12,5);
    shakeScreen();
    if(this.hp<=0 && gameState==='playing') endGame(false);
  }

  draw(){
    if(images[this.type]&&images[this.type].complete){
      ctx.save();
      if(!this.facingRight){
        ctx.scale(-1,1);
        ctx.drawImage(images[this.type],-this.x-this.width,this.y,this.width,this.height)
      }else ctx.drawImage(images[this.type],this.x,this.y,this.width,this.height);
      ctx.restore()
    } else {
      ctx.fillStyle='#3498db';ctx.fillRect(this.x,this.y,this.width,this.height)
    }


    // Salsy mark indicator
    if(this.salsyMarkUntil && Date.now() < this.salsyMarkUntil){
      ctx.save();
      ctx.font='22px "Press Start 2P", monospace';
      ctx.textAlign='center';
      ctx.fillStyle='#f1c40f';
      ctx.fillText('‚öúÔ∏è', this.x+this.width/2, this.y-10);
      ctx.restore();
    }

    if(this.shieldActive&&!this.shieldBroken){
      ctx.beginPath();ctx.strokeStyle='rgba(127,219,255,0.85)';ctx.lineWidth=6;
      ctx.arc(this.x+this.width/2,this.y+this.height/2,Math.max(this.width,this.height),0,Math.PI*2);ctx.stroke();
      ctx.fillStyle='#fff';ctx.fillRect(this.x,this.y-16,this.width,6);
      ctx.fillStyle='#7fdbff';ctx.fillRect(this.x,this.y-16,this.width*(this.shieldDurability/this.shieldMaxDurability),6)
    }

    if(this.attacking&&!this.isGrappling){
      ctx.save();
      if(this.attackType==='punch'){
        ctx.strokeStyle='rgba(230,126,34,0.7)';ctx.lineWidth=8;ctx.beginPath();
        const punchX=this.x+this.width/2+(this.facingRight?this.range:-this.range);
        ctx.moveTo(this.x+this.width/2,this.y+this.height/2);
        ctx.lineTo(punchX,this.y+this.height/2);ctx.stroke()
      }else if(this.attackType==='sword'){
        ctx.strokeStyle='rgba(155,89,182,0.6)';ctx.lineWidth=5;
        const angle=this.facingRight?0:Math.PI;const arcWidth=Math.PI*1.2;
        ctx.beginPath();ctx.arc(this.x+this.width/2,this.y+this.height/2,this.range,angle-arcWidth/2,angle+arcWidth/2);ctx.stroke()
      }else if(this.attackType==='salsySword'){
        // Visual telegraph: Salsy fan slash area
        const angle=this.facingRight?0:Math.PI;const arcWidth=Math.PI*1.35;
        ctx.fillStyle='rgba(241,196,15,0.12)';
        ctx.strokeStyle='rgba(241,196,15,0.75)';
        ctx.lineWidth=6;
        ctx.beginPath();
        ctx.moveTo(this.x+this.width/2,this.y+this.height/2);
        ctx.arc(this.x+this.width/2,this.y+this.height/2,this.range,angle-arcWidth/2,angle+arcWidth/2);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
      }else if(this.attackType==='hybrid'){
        ctx.strokeStyle='rgba(243,156,18,0.6)';ctx.lineWidth=6;
        ctx.beginPath();
        ctx.arc(this.x+this.width/2,this.y+this.height/2,60,0,Math.PI*2);
        ctx.stroke();
      }
      ctx.restore()
    }

    if(this.isDoingSuper){
      if(this.attackType==='punch'){
        ctx.save();ctx.strokeStyle='rgba(243,156,18,0.45)';ctx.lineWidth=12;ctx.beginPath();
        const arcRadius=350;ctx.arc(this.x+this.width/2,this.y+this.height/2,arcRadius,0,Math.PI*2);ctx.stroke();ctx.restore()
      }
      else if(this.attackType==='sword'){
        ctx.save();ctx.strokeStyle='rgba(155,89,182,0.45)';ctx.lineWidth=10;ctx.beginPath();
        const swordRadius=JEFF_SUPER_RADIUS;ctx.arc(this.x+this.width/2,this.y+this.height/2,swordRadius,0,Math.PI*2);ctx.stroke();ctx.restore()
      }
      else if(this.attackType==='grapple'){
        ctx.save();ctx.strokeStyle='rgba(231,76,60,0.45)';ctx.lineWidth=6;
        this.superTargets.forEach(t=>{ctx.beginPath();ctx.arc(t.x+t.width/2,t.y+t.height/2,40,0,Math.PI*2);ctx.stroke()});
        ctx.restore()
      }
      else if(this.attackType==='hybrid'){
        // aura while super is active
        ctx.save();ctx.strokeStyle='rgba(243,156,18,0.35)';ctx.lineWidth=8;
        ctx.beginPath();ctx.arc(this.x+this.width/2,this.y+this.height/2,140,0,Math.PI*2);ctx.stroke();ctx.restore()
      }
      else if(this.attackType==='salsySword'){
        // Show 1-3 target reticles + launch lines during Salsy super
        ctx.save();
        ctx.strokeStyle='rgba(241,196,15,0.75)';
        ctx.fillStyle='rgba(241,196,15,0.10)';
        ctx.lineWidth=5;
        const px=this.x+this.width/2, py=this.y+this.height/2;
        const list=(this.superTargets||[]).slice(0,3);
        list.forEach((t,i)=>{
          const tx=t.x+t.width/2, ty=t.y+t.height/2;
          // dashed aim line
          ctx.setLineDash([10,6]);
          ctx.beginPath();ctx.moveTo(px,py);ctx.lineTo(tx,ty);ctx.stroke();
          ctx.setLineDash([]);
          // reticle
          ctx.beginPath();ctx.arc(tx,ty,26,0,Math.PI*2);ctx.stroke();
          ctx.beginPath();ctx.arc(tx,ty,10,0,Math.PI*2);ctx.fill();ctx.stroke();
        });
        ctx.restore();
      }
    }

    if(this.isGrappling&&this.grappleTarget){
      ctx.strokeStyle='rgba(231,76,60,0.8)';ctx.lineWidth=3;ctx.setLineDash([10,5]);
      ctx.beginPath();ctx.moveTo(this.x+this.width/2,this.y+this.height/2);
      ctx.lineTo(this.grappleTarget.x+this.grappleTarget.width/2,this.grappleTarget.y+this.grappleTarget.height/2);
      ctx.stroke();ctx.setLineDash([])
    }

    if(this.isJetpacking){
      ctx.save();
      ctx.fillStyle='rgba(255,215,0,0.9)';
      ctx.beginPath();
      ctx.ellipse(this.x+this.width/2,this.y+this.height+12,18,8,0,0,Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    // === KOUVAGIA: visualizzazione aree attacco + effetto super ===
    if(this.type==='kouvagia'){
      // Area danno durante dash-attacco
      if(this.isDashing && this._kouvagiaDashActive){
        ctx.save();
        ctx.strokeStyle='rgba(232,67,147,0.55)';
        ctx.lineWidth=6;
        ctx.beginPath();
        ctx.arc(this.x+this.width/2,this.y+this.height/2,110,0,Math.PI*2);
        ctx.stroke();
        ctx.restore();
      }

      // Area esplosione finale (breve telegraph)
      if(this._kouvagiaExplosionPending && this.isDashing){
        ctx.save();
        ctx.strokeStyle='rgba(253,121,168,0.45)';
        ctx.lineWidth=6;
        ctx.beginPath();
        ctx.arc(this.x+this.width/2,this.y+this.height/2,165,0,Math.PI*2);
        ctx.stroke();
        ctx.restore();
      }

      // Effetto super: onda espansiva + flash
      const nowFx=Date.now();
      if(this._kouvagiaSuperFxUntil && nowFx < this._kouvagiaSuperFxUntil){
        const t=(nowFx-(this._kouvagiaSuperFxStart||nowFx)) / (this._kouvagiaSuperFxUntil-(this._kouvagiaSuperFxStart||nowFx)+1);
        const r=60 + t*360;
        ctx.save();
        ctx.strokeStyle='rgba(85,239,196,'+(0.9 - t*0.8)+')';
        ctx.lineWidth=12;
        ctx.beginPath();
        ctx.arc(this.x+this.width/2,this.y+this.height/2,r,0,Math.PI*2);
        ctx.stroke();
        // flash leggero
        ctx.fillStyle='rgba(85,239,196,'+(0.12*(1-t))+')';
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.restore();
      }
    }

  }
}

class Enemy{
  constructor(type,level){
    const cfg=levelConfigs[Math.max(0,Math.min(levelConfigs.length-1,level-1))];
    const mult=1+0.15*level;
    this.type=type;
    this.x=Math.random()*(canvas.width-100)+50;
    this.y=Math.random()*(canvas.height-150)+50;
    this.width=Math.round(40*1.2);
    this.height=Math.round(40*1.2);
    this.vx=(Math.random()-0.5)*cfg.enemySpeed*mult;
    this.vy=(Math.random()-0.5)*cfg.enemySpeed*mult;
    this.maxHP=Math.round(cfg.enemyHP*(1+0.25*level));
    this.hp=this.maxHP;
    const baseDamage=Math.round(cfg.enemyDamage*(1+0.10*level));
    this.damage=(level>=7)?Math.round(baseDamage*0.8):baseDamage;
    this.speed=cfg.enemySpeed*mult;
    if(level===8)this.speed*=0.925;
    this.lastAttack=0;this.attackCooldown=2000;this.spawnFreezeUntil=Date.now()+500;
    // Special enemies
    if(this.type==='veleno'){
      this.attackCooldown=1400;
      this.poisonDuration=6000;
      this.poisonTickDamage=2;
    }
    if(this.type==='oneyes'){
      this.attackCooldown=1600;
      this.keepAway=300;
      this.preferRange=520;
    }
    if(this.type==='boss4'){
      this.width=Math.round(78*1.2);
      this.height=Math.round(78*1.2);
      this.attackCooldown=950;
      this.beamCooldown=12000;
      this.lastBeam=Date.now()-this.beamCooldown;
      this.isChargingBeam=false;
    }

  }
  update(player){
    if(Date.now()<this.spawnFreezeUntil)return;
    const now=Date.now();

    const cx=this.x+this.width/2;
    const cy=this.y+this.height/2;
    const px=player.x+player.width/2;
    const py=player.y+player.height/2;

    let dx=px-cx;
    let dy=py-cy;
    let dist=Math.hypot(dx,dy)||1;

    // Default: chase
    let nx=dx/dist;
    let ny=dy/dist;

    // OneEyes: keep distance + shoot lasers
    if(this.type==='oneyes'){
      // keep away if too close
      if(dist < (this.keepAway||300)){
        nx = -nx; ny = -ny;
      } else if(dist > (this.preferRange||520)){
        // slightly approach if too far
        // nx,ny already towards player
      } else {
        // strafe / small drift
        const t = nx; nx = -ny*0.7; ny = t*0.7;
      }

      this.vx = nx*this.speed;
      this.vy = ny*this.speed;

      // shoot laser (1s duration), with higher cooldown
      if(dist>220 && (now-this.lastAttack)>this.attackCooldown){
        const angle=Math.atan2(dy,dx);
        spawnLaser({
          x:cx, y:cy,
          angle,
          length:650,
          width:18,
          ttl:1000,
          damage:18,
          kind:'oneyes',
          chargeMs:0
        });
        createParticles(cx,cy,'#74b9ff',16,4);
        this.lastAttack=now;
      }
    }

    // Boss4: slow melee + photon beam every 12s
    else if(this.type==='boss4'){
      // During charge, slow down a lot
      if(this.isChargingBeam){
        this.vx *= 0.8;
        this.vy *= 0.8;
      } else {
        // chase slowly
        this.vx = nx*this.speed*0.92;
        this.vy = ny*this.speed*0.92;
      }

      // melee hit
      if(dist<70 && (now-this.lastAttack)>this.attackCooldown && !player.isDashing){
        player.takeDamage(this.damage);
        this.lastAttack=now;
        createParticles(player.x,player.y,'#e17055',14,4);
      }

      // photon beam
      if((now-this.lastBeam) >= (this.beamCooldown||12000) && !this.isChargingBeam){
        this.isChargingBeam=true;
        this.lastBeam=now;
        const angle=Math.atan2(dy,dx);
        // charge + beam
        spawnLaser({
          x:cx, y:cy,
          angle,
          length:760,
          width:28,
          ttl:1000,
          damage:50,
          kind:'photon',
          chargeMs:750
        });
        // visual charge
        createParticles(cx,cy,'#f1c40f',40,6);
        shakeScreen();
        setTimeout(()=>{ this.isChargingBeam=false; }, 900);
      }
    }

    // Veleno: melee + non-stack poison
    else {
      this.vx = nx*this.speed;
      this.vy = ny*this.speed;

      // melee attack
      if(dist<60 && (now-this.lastAttack)>this.attackCooldown && !player.isDashing){
        if(this.type==='veleno'){
          player.takeDamage(15);
          // apply poison only if not already poisoned (non-stackable)
          if(!player.poisonUntil || now >= player.poisonUntil){
            player.poisonUntil = now + (this.poisonDuration||6000);
            player.poisonTickLast = now;
            player.poisonTickDamage = this.poisonTickDamage||2;
            createParticles(player.x,player.y,'#00b894',26,4);
          } else {
            // hit without re-applying poison
            createParticles(player.x,player.y,'#00b894',10,3);
          }
        } else {
          player.takeDamage(this.damage);
        }
        this.lastAttack=now;
      }
    }

    this.x+=this.vx;this.y+=this.vy;
    if(this.x<0)this.x=0;if(this.x+this.width>canvas.width)this.x=canvas.width-this.width;
    if(this.y<0)this.y=0;if(this.y+this.height>canvas.height-50)this.y=canvas.height-50-this.height;
  }
draw(){
    const imgKey = (this.type==='boss' || this.type==='boss1') ? 'boss1' : this.type;
    const img = enemyImages[imgKey];
    if(img && img.complete){
      ctx.drawImage(img,this.x,this.y,this.width,this.height);
    } else {
      const colors={slime:'#2ecc71',drone:'#95a5a6',mech:'#e67e22',shadow:'#9b59b6',boss:'#e74c3c',shooter:'#95a5a6',attacker:'#e67e22',boss2:'#e74c3c',boss3:'#e74c3c'};
      ctx.fillStyle=colors[this.type]||'#e74c3c';
      ctx.fillRect(this.x,this.y,this.width,this.height);
    }
    const hpPercent=this.hp/this.maxHP;
    ctx.fillStyle='#333';ctx.fillRect(this.x,this.y-10,this.width,5);
    ctx.fillStyle=hpPercent>0.5?'#2ecc71':hpPercent>0.25?'#f39c12':'#e74c3c';
    ctx.fillRect(this.x,this.y-10,this.width*hpPercent,5);
  }
}

class ShooterEnemy extends Enemy{
  constructor(type,level){super(type,level);this.shootCooldown=Math.max(600,1800-level*40);this.lastShoot=0;this.bulletSpeed=5+level*0.15}
  update(player){
    if(Date.now()<this.spawnFreezeUntil)return;
    const dx=(player.x+player.width/2)-(this.x+this.width/2);
    const dy=(player.y+player.height/2)-(this.y+this.height/2);
    const dist=Math.hypot(dx,dy);
    if(dist<220){const nx=dx/(dist||1);const ny=dy/(dist||1);this.vx=-nx*this.speed;this.vy=-ny*this.speed}
    else if(dist>360){const nx=dx/(dist||1);const ny=dy/(dist||1);this.vx=nx*this.speed;this.vy=ny*this.speed}
    else{this.vx*=0.9;this.vy*=0.9}
    this.x+=this.vx;this.y+=this.vy;
    if(this.x<0)this.x=0;if(this.x+this.width>canvas.width)this.x=canvas.width-this.width;
    if(this.y<0)this.y=0;if(this.y+this.height>canvas.height-50)this.y=canvas.height-50-this.height;
    if(Date.now()-this.lastShoot>this.shootCooldown){
      this.lastShoot=Date.now();
      const len=Math.hypot(dx,dy)||1;
      const vx=(dx/len)*this.bulletSpeed;const vy=(dy/len)*this.bulletSpeed;
      spawnProjectile({
        x:this.x+this.width/2,y:this.y+this.height/2,
        vx,vy,damage:Math.max(1,Math.round(this.damage*0.6)),ttl:4000,
        color:'#ffd54f',radius:6,friendly:false
      })
    }
  }
  draw(){
    const img = enemyImages['shooter'];
    if(img && img.complete) ctx.drawImage(img,this.x,this.y,this.width,this.height);
    else super.draw();
    const hpPercent=this.hp/this.maxHP;
    ctx.fillStyle='#333';ctx.fillRect(this.x,this.y-10,this.width,5);
    ctx.fillStyle=hpPercent>0.5?'#2ecc71':hpPercent>0.25?'#f39c12':'#e74c3c';
    ctx.fillRect(this.x,this.y-10,this.width*hpPercent,5);
  }
}

class AttackReturnEnemy extends Enemy{
  constructor(type,level){super(type,level);this.homeX=this.x;this.homeY=this.y;this.state='idle';this.attackRange=60;this.attackCooldown=2200;this.lastAttackTime=0;this.attackSpeed=this.speed*2.5}
  update(player){
    if(Date.now()<this.spawnFreezeUntil)return;
    const dx=(player.x+player.width/2)-(this.x+this.width/2);
    const dy=(player.y+player.height/2)-(this.y+this.height/2);
    const distToPlayer=Math.hypot(dx,dy);
    if(this.state==='idle'){
      const wanderX=Math.sin(Date.now()/1000+this.homeX)*0.3;const wanderY=Math.cos(Date.now()/1000+this.homeY)*0.3;
      this.vx=wanderX*this.speed;this.vy=wanderY*this.speed;
      if(distToPlayer<220&&Date.now()-this.lastAttackTime>this.attackCooldown)this.state='attack'
    }
    else if(this.state==='attack'){
      const nx=dx/(distToPlayer||1);const ny=dy/(distToPlayer||1);
      this.vx=nx*this.attackSpeed;this.vy=ny*this.attackSpeed;
      if(distToPlayer<this.attackRange){player.takeDamage(this.damage);this.lastAttackTime=Date.now();this.state='returning'}
    }
    else if(this.state==='returning'){
      const hx=this.homeX-this.x;const hy=this.homeY-this.y;const distHome=Math.hypot(hx,hy);
      if(distHome>6){
        const nx=hx/(distHome||1);const ny=hy/(distHome||1);
        this.vx=nx*this.speed;this.vy=ny*this.speed
      }else{this.vx=0;this.vy=0;this.state='idle'}
    }
    this.x+=this.vx;this.y+=this.vy;
    if(this.x<0)this.x=0;if(this.x+this.width>canvas.width)this.x=canvas.width-this.width;
    if(this.y<0)this.y=0;if(this.y+this.height>canvas.height-50)this.y=canvas.height-50-this.height;
  }
  draw(){
    const img = enemyImages['attacker'];
    if(img && img.complete) ctx.drawImage(img,this.x,this.y,this.width,this.height);
    else super.draw();
    const hpPercent=this.hp/this.maxHP;
    ctx.fillStyle='#333';ctx.fillRect(this.x,this.y-10,this.width,5);
    ctx.fillStyle=hpPercent>0.5?'#2ecc71':hpPercent>0.25?'#f39c12':'#e74c3c';
    ctx.fillRect(this.x,this.y-10,this.width*hpPercent,5);
  }
}

class BossEnemy extends Enemy{
  constructor(type,level){
    super(type,level);
    this.phase=0;
    this.superCooldown=12000;
    this.lastSuper=0;
    this.superActive=false;
    this.superStart=0;
    this.superDuration=3000;
    this.bulletTimer=0;
    this.attackCooldown=1800;
    this.lastAttack=0;
    this.width=Math.round(120*1.2);
    this.height=Math.round(120*1.2);
  }
  update(player){
    if(Date.now()<this.spawnFreezeUntil)return;
    const dx=player.x-this.x;const dy=player.y-this.y;const dist=Math.hypot(dx,dy);
    const attackRange=60;
    if(dist>attackRange){
      const nx=dx/(dist||1);const ny=dy/(dist||1);
      this.vx=nx*this.speed;this.vy=ny*this.speed;
    } else {
      this.vx*=0.9;this.vy*=0.9;
      if(Date.now()-this.lastAttack>this.attackCooldown&&!player.isDashing){
        player.takeDamage(this.damage);
        this.lastAttack=Date.now();
      }
    }
    this.x+=this.vx;this.y+=this.vy;
    if(this.x<0)this.x=0;if(this.x+this.width>canvas.width)this.x=canvas.width-this.width;
    if(this.y<0)this.y=0;if(this.y+this.height>canvas.height-50)this.y=canvas.height-50-this.height;
    if(Date.now()-this.lastSuper>this.superCooldown){
      this.lastSuper=Date.now();this.superActive=true;this.superStart=Date.now()
    }
    if(this.superActive&&Date.now()-this.superStart>this.superDuration)this.superActive=false;
  }
  draw(){
    const key = (this.type==='boss' || this.type==='boss1') ? 'boss1' : (this.type==='boss2' ? 'boss2' : (this.type==='boss3' ? 'boss3' : this.type));
    const img = enemyImages[key];
    if(img && img.complete) ctx.drawImage(img,this.x,this.y,this.width,this.height);
    else super.draw();
    const hpPercent=this.hp/this.maxHP;
    ctx.fillStyle='#333';ctx.fillRect(this.x,this.y-10,this.width,5);
    ctx.fillStyle=hpPercent>0.5?'#2ecc71':hpPercent>0.25?'#f39c12':'#e74c3c';
    ctx.fillRect(this.x,this.y-10,this.width*hpPercent,5);
  }
}

function spawnEnemiesForLevel(level){
  enemies.length=0;
  const lvl = Math.max(1, Math.min(level, levelConfigs.length));
  const cfg=levelConfigs[lvl-1];
  const count=cfg.enemyCount;
  for(let i=0;i<count;i++){
    let e;
    if(cfg.enemyType==='shooter') e=new ShooterEnemy(cfg.enemyType,lvl);
    else if(cfg.enemyType==='attacker') e=new AttackReturnEnemy(cfg.enemyType,lvl);
    else if(cfg.enemyType==='boss1' || cfg.enemyType==='boss2' || cfg.enemyType==='boss3') e=new BossEnemy(cfg.enemyType,lvl);
    else e=new Enemy(cfg.enemyType,lvl);
    enemies.push(e);
  }
  spawnPickupsForLevel(lvl);
}

function updateBackgroundForLevel(level){
  // Levels 1-6: default bg, Levels 7-15: dark bg, Levels 16-20: final bg
  let tier=0;
  if(level>=16) tier=2;
  else if(level>=7) tier=1;

  const applyTier=()=>{
    if(tier===2){
      bgDark.style.backgroundImage=`url('${URL_FINAL}')`;
      bgDefault.style.opacity='0';
      bgDark.style.opacity='1';
    } else if(tier===1){
      bgDark.style.backgroundImage=`url('${URL_DARK}')`;
      bgDefault.style.opacity='0';
      bgDark.style.opacity='1';
    } else {
      bgDefault.style.opacity='1';
      bgDark.style.opacity='0';
    }
    _bgTier=tier;
  };

  // Dissolvenza: quando si entra nella "fase finale" (dal 15 -> 16) o cambia tier
  if(fadeOverlay && tier!==_bgTier){
    fadeOverlay.style.opacity='1';
    setTimeout(()=>{
      applyTier();
      setTimeout(()=>{ fadeOverlay.style.opacity='0'; }, 80);
    }, 380);
  } else {
    applyTier();
  }
}

function startGame(){
  currentLevel=1;score=0;timer=levelConfigs[0].time;
  player=new Player(selectedCharacter||'jimmy');
  enemies=[];particles=[];projectiles=[];lasers=[];pickups=[];
  spawnEnemiesForLevel(currentLevel);
  updateBackgroundForLevel(currentLevel);
  document.getElementById('mainMenu').style.display='none';
  document.getElementById('uiOverlay').style.display='block';
  document.getElementById('scoreDisplay').style.display='block';
  document.getElementById('timerDisplay').style.display='block';
  document.getElementById('levelDisplay').style.display='block';
  document.getElementById('superCooldown').style.display='block';
  gameState='playing';
}

function endGame(won){
  if(gameState!=='playing') return;
  gameState='ended';
  document.getElementById('endScreen').style.display='block';
  document.getElementById('endTitle').textContent=won?'VICTORY':'GAME OVER';
  document.getElementById('endMessage').textContent=`Score Finale: ${score}`;
  document.getElementById('endSub').textContent=`Hai raggiunto il Livello ${currentLevel}`;
  const rec=records[selectedCharacter]||0;
  if(score>rec){records[selectedCharacter]=score;saveRecords();}
  document.getElementById('recordMessage').textContent=`Record Personaggio: ${records[selectedCharacter]||0}`;
}

function nextLevel(){
  if(currentLevel < levelConfigs.length){
    currentLevel++;
    spawnEnemiesForLevel(currentLevel);
    timer=levelConfigs[Math.max(0,currentLevel-1)].time;
    updateBackgroundForLevel(currentLevel);
  } else {
    endGame(true);
  }
}

function gameLoop(){
  requestAnimationFrame(gameLoop);
  if(gameState!=='playing')return;
  const now=Date.now();

  if(now-lastSecondTick>1000){
    lastSecondTick=now;
    timer--;
    if(timer<=0){
      timer=0;
      endGame(false);
return;
    }
  }

  if(player) player.update();
  enemies.forEach(e=>{e.update(player)});
  updateParticles();
  updateProjectiles();
  updateLasers();
  if(player) updatePickups(player);

  for(let i=enemies.length-1;i>=0;i--){
    if(enemies[i].hp<=0){
      const dead=enemies.splice(i,1)[0];
      score+=100*currentLevel;
      createParticles(dead.x,dead.y,'#fff176',30,6);
      if(Math.random()<0.25) spawnPickup(dead.x+20,dead.y+20,'heal',Math.round(dead.maxHP*0.25));
      if(Math.random()<0.18) spawnPickup(dead.x+20,dead.y+20,'speed',0);
      if(Math.random()<0.12) spawnPickup(dead.x+20,dead.y+20,'shieldPickup',0);
      if(Math.random()<GOLD_PROB) spawnPickup(dead.x+20,dead.y+20,'gold',10);
    }
  }

  if(enemies.length===0){
    if(!levelAdvanceLock){
      levelAdvanceLock=true;
      setTimeout(()=>{
        if(gameState==='playing') nextLevel();
        levelAdvanceLock=false;
      }, 200);
    }
  }

  ctx.clearRect(0,0,canvas.width,canvas.height);
  if(shakeAmount>0){
    const sx=(Math.random()-0.5)*shakeAmount;const sy=(Math.random()-0.5)*shakeAmount;
    ctx.save();ctx.translate(sx,sy);shakeAmount*=0.9
  } else ctx.save();

  enemies.forEach(e=>e.draw());
  if(player) player.draw();
  drawProjectiles();
  drawLasers();
  drawParticles();
  drawPickups();

  ctx.restore();

  if(player){
    document.getElementById('hpText').textContent=Math.max(0,Math.round(player.hp));
    document.getElementById('hpFill').style.width=Math.max(0,Math.round((player.hp/player.maxHP)*100))+'%';
  } else {
    document.getElementById('hpText').textContent='0';
    document.getElementById('hpFill').style.width='0%';
  }

  document.getElementById('scoreDisplay').textContent=`Score: ${score}`;
  document.getElementById('timerDisplay').textContent=timer;
  document.getElementById('levelDisplay').textContent=`Level ${currentLevel}`;
  const superReady=(Date.now()-player.lastSuper>=player.superCooldown)?'Ready':Math.ceil((player.superCooldown-(Date.now()-player.lastSuper))/1000)+'s';
  document.getElementById('superCooldown').textContent=`Super: ${superReady}`;
  if(player.attackBuffUntil) document.getElementById('atkBuffDisplay').textContent=Math.max(0,Math.ceil((player.attackBuffUntil-Date.now())/1000))+'s';
  else document.getElementById('atkBuffDisplay').textContent='0s';
}

window.addEventListener('keydown',e=>{
  const k=e.key.toLowerCase();
  keys[k]=true;
  if(k==='j'&&gameState==='playing'){player.attack()}
  if(k==='k'&&gameState==='playing'){player.superAttack()}
  if(k===' '&&gameState==='playing'){player.dodge()}
});
window.addEventListener('keyup',e=>{keys[e.key.toLowerCase()]=false;});

document.querySelectorAll('.character-card').forEach(card=>{
  card.addEventListener('click',()=>{
    const char=card.getAttribute('data-char');
    if(char==='voltryx' && !allThreeAbove50k()){
      // keep disabled
      updateVoltryxUnlockUI();
      return;
    }
    if(char==='kouvagia' && !voltryxAbove51k()){
      updateKouvagiaUnlockUI();
      return;
    }
    if(char==='salsy' && !allPrevAbove70k()){
      updateSalsyUnlockUI();
      return;
    }
    document.querySelectorAll('.character-card').forEach(c=>c.classList.remove('selected'));
    card.classList.add('selected');
    selectedCharacter=char;
    updateMenuStatsDisplay(selectedCharacter);
  });
});

function updateMenuStatsDisplay(char){
  const s=characterStats[char];
  if(!s)return;
  document.getElementById(`menu-hp-${char}`).textContent=s.hp;
  document.getElementById(`menu-dmg-${char}`).textContent=
    char==='voltryx' ? `${Math.round(34*SUPER_DAMAGE_MULT)} (ranged AoE), ${50}x2 (melee)` : (char==='salsy' ? '25x2' : s.damage);
}

document.getElementById('startBtn').addEventListener('click',()=>{
  if(!selectedCharacter)selectedCharacter='jimmy';
  updateMenuRecordsDisplay();
  startGame();
});

document.getElementById('restartBtn').addEventListener('click',()=>{
  document.getElementById('endScreen').style.display='none';
  startGame();
});
document.getElementById('menuBtn').addEventListener('click',()=>{
  document.getElementById('endScreen').style.display='none';
  document.getElementById('mainMenu').style.display='block';
  gameState='menu';
  updateMenuRecordsDisplay();
});

function populateMenuStatsAll(){
  updateMenuStatsDisplay('jimmy');
  updateMenuStatsDisplay('rooney');
  updateMenuStatsDisplay('jeff');
  updateMenuStatsDisplay('voltryx');
updateMenuStatsDisplay('kouvagia');
}
populateMenuStatsAll();
updateMenuRecordsDisplay();
updateVoltryxUnlockUI();

gameLoop();
// --- Guida: apertura/chiusura e gestione stato di gioco ---
(function(){
  const guideImgBtn = document.getElementById('guideImgBtn');
  const guideModal = document.getElementById('guideModal');
  const guideClose = document.getElementById('guideClose');
  if(!guideImgBtn || !guideModal || !guideClose) return;
  let gameStateBeforeGuide = undefined;
  function showGuide(){
    guideModal.style.display = 'flex';
  updateGuideUnlockUI();
    guideModal.setAttribute('aria-hidden','false');
    if(typeof gameState !== 'undefined') gameStateBeforeGuide = gameState;
    gameState = 'menu';
    guideClose.focus();
    window._guideOpen = true;
  }
  function hideGuide(){
    guideModal.style.display = 'none';
    guideModal.setAttribute('aria-hidden','true');
    if(typeof gameStateBeforeGuide !== 'undefined') gameState = gameStateBeforeGuide;
    guideImgBtn.focus();
    window._guideOpen = false;
  }
  guideImgBtn.addEventListener('click', function(e){ e.preventDefault(); showGuide(); });
  guideClose.addEventListener('click', function(e){ e.preventDefault(); hideGuide(); });
  guideModal.addEventListener('click', function(e){ if(e.target === guideModal) hideGuide(); });
  document.addEventListener('keydown', function(e){
    if(e.key === 'Escape' && guideModal.style.display === 'flex') hideGuide();
  });
  const guideImg = document.getElementById('guideImg');
  if(guideImg) guideImg.addEventListener('dragstart', function(ev){ ev.preventDefault(); });
})();
</script>
</body>
</html>
